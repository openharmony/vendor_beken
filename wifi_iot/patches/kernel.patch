diff --git a/kernel/liteos_m/.gitignore b/kernel/liteos_m/.gitignore
index f31ded3..c40b991 100644
--- a/kernel/liteos_m/.gitignore
+++ b/kernel/liteos_m/.gitignore
@@ -1,16 +1,16 @@
-test
-*.si4project
-tags
-cscope.*
-*.swp
-/**/*_iar/project/
-!los_demo.eww
-!los_demo.ewp
-!los_demo.ewd
-!los_demo.ewt
-!los_demo.dep
-!*.icf
-targets/cortex-m7_nucleo_f767zi_gcc/build
-*.o
-*.d
-*.su
+test
+*.si4project
+tags
+cscope.*
+*.swp
+/**/*_iar/project/
+!los_demo.eww
+!los_demo.ewp
+!los_demo.ewd
+!los_demo.ewt
+!los_demo.dep
+!*.icf
+targets/cortex-m7_nucleo_f767zi_gcc/build
+*.o
+*.d
+*.su
diff --git a/kernel/liteos_m/BUILD.gn b/kernel/liteos_m/BUILD.gn
index 35e88fc..ac14516 100644
--- a/kernel/liteos_m/BUILD.gn
+++ b/kernel/liteos_m/BUILD.gn
@@ -1,63 +1,68 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-declare_args() {
-  enable_ohos_kernel_liteos_m_cppsupport = true
-  enable_ohos_kernel_liteos_m_cpup = true
-  enable_ohos_kernel_liteos_m_exchook = true
-  enable_ohos_kernel_liteos_m_kal = true
-  enable_ohos_kernel_liteos_m_fs = true
-  enable_ohos_kernel_liteos_m_backtrace = true
-}
-
-group("kernel") {
-  deps = [
-    "components/bounds_checking_function:sec",
-    "kernel:kernel",
-    "utils:utils",
-  ]
-  if (enable_ohos_kernel_liteos_m_cppsupport == true) {
-    deps += [ "components/cppsupport:cppsupport" ]
-  }
-  if (enable_ohos_kernel_liteos_m_cpup == true) {
-    deps += [ "components/cpup:cpup" ]
-  }
-  if (enable_ohos_kernel_liteos_m_exchook == true) {
-    deps += [ "components/exchook:exchook" ]
-  }
-  if (enable_ohos_kernel_liteos_m_backtrace == true) {
-    deps += [ "components/backtrace:backtrace" ]
-  }
-  if (enable_ohos_kernel_liteos_m_fs == true) {
-    deps += [ "components/fs:fs" ]
-  }
-  if (enable_ohos_kernel_liteos_m_kal == true) {
-    deps += [ "kal:kal" ]
-  }
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+import("config.gni")
+
+group("kernel") {
+  deps = [
+    "kernel:kernel",
+    "utils:utils",
+    "//third_party/bounds_checking_function:libsec_static",
+  ]
+  if (enable_ohos_kernel_liteos_m_cppsupport == true) {
+    deps += [ "components/cppsupport:cppsupport" ]
+  }
+  if (enable_ohos_kernel_liteos_m_cpup == true) {
+    deps += [ "components/cpup:cpup" ]
+  }
+  if (enable_ohos_kernel_liteos_m_exchook == true) {
+    deps += [ "components/exchook:exchook" ]
+  }
+  if (enable_ohos_kernel_liteos_m_backtrace == true) {
+    deps += [ "components/backtrace:backtrace" ]
+  }
+  if (enable_ohos_kernel_liteos_m_fs == true) {
+    deps += [ "components/fs:fs" ]
+  }
+  if (enable_ohos_kernel_liteos_m_pm == true) {
+    deps += [ "components/power:pm" ]
+  }
+  if (enable_ohos_kernel_liteos_m_kal == true) {
+    deps += [ "kal:kal" ]
+  }
+  if (enable_ohos_kernel_liteos_m_shell== true) {
+    deps += [ "components/shell:shell" ]
+  }
+  if (enable_ohos_kernel_liteos_m_test == true) {
+    deps += [ "testsuits:test" ]
+  }
+  if (enable_ohos_kernel_liteos_m_lwip == true) {
+    deps += [ ohos_kernel_liteos_m_lwip_path ]
+  }
+}
diff --git a/kernel/liteos_m/README.md b/kernel/liteos_m/README.md
index a3d1d4c..a5b23d6 100644
--- a/kernel/liteos_m/README.md
+++ b/kernel/liteos_m/README.md
@@ -1,79 +1,76 @@
-# LiteOS Cortex-M<a name="EN-US_TOPIC_0000001096757661"></a>
-
--   [Introduction](#section11660541593)
--   [Directory Structure](#section161941989596)
--   [Constraints](#section119744591305)
--   [Usage](#section3732185231214)
--   [Repositories Involved](#section1371113476307)
-
-## Introduction<a name="section11660541593"></a>
-
-The OpenHarmony LiteOS Cortex-M is the kernel designed for the lightweight operating system \(OS\) for the Internet of Things \(IoT\) field. It features small size, low power consumption, and high performance. In addition, it has a simple code structure, including the minimum kernel function set, kernel abstraction layer, optional components, and project directory, and is divided into the hardware-related and hardware-irrelevant layers. The hardware-related layers provide unified hardware abstraction layer \(HAL\) interfaces to improve hardware adaptability. The combination and classification of different compilation toolchains and chip architectures meet the requirements of the Artificial Intelligence of Things \(AIoT\) field for rich hardware and compilation toolchains.  [Figure1](#fig0865152210223)  shows the architecture of the OpenHarmony LiteOS Cortex-M kernel.
-
-**Figure  1**  Architecture of OpenHarmony the LiteOS Cortex-M kernel<a name="fig0865152210223"></a>  
-![](figures/architecture-of-openharmony-the-liteos-cortex-m-kernel.png "architecture-of-openharmony-the-liteos-cortex-m-kernel")
-
-## Directory Structure<a name="section161941989596"></a>
-
-```
-/kernel/liteos_m
-├── components           # Optional components
-│   ├── cppsupport       # C++ support
-│   └── cpup             # CPU possession (CPUP)
-├── kal                  # Kernel abstraction layer
-│   ├── cmsis            # CMSIS-compliant API support
-│   └── posix            # POSIX API support
-├── kernel               # Minimum function set support
-│   ├── arch             # Code of the kernel instruction architecture layer
-│   │   ├── arm          # Code of the ARM32 architecture
-│   │   └── include      # APIs exposed externally
-│   ├── include          # APIs exposed externally
-│   └── src              # Source code of the minimum function set of the kernel
-├── targets              # Board-level projects
-├── utils                # Common code
-```
-
-## Constraints<a name="section119744591305"></a>
-
-Programming languages: C and C++
-
-Currently applicable architectures: Cortex-M3, Cortex-M4, Cortex-M7, and RISC-V
-
-## Usage<a name="section3732185231214"></a>
-
-LiteOS Cortex-M provides projects for three chip architectures, which are located in the  **targets**  directory. The methods of compiling and using these projects are as follows:
-
--   Cortex-M3:
-
-The  **kernel/liteos\_m/targets/cortex-m3\_stm32f103\_simulator\_keil**  directory is the Keil project directory created based on the STM32F103 chip architecture. You can download and install Keil development tools from the Internet. To compile the Cortex-M3 project, go to the  **cortex-m3\_stm32f103\_simulator\_keil/project**  directory and double-click the  **los\_demo.uvproj**  file to open the desired project. After the compilation is successful, burn the file to the corresponding board using JLINK or STM32 ST-LINK Utility.
-
--   Cortex-M4:
-
-The  **kernel/liteos\_m/targets/cortex-m4\_stm32f429ig\_fire-challenger\_iar**  directory is the IAR project directory created based on the STM32F429IG chip architecture. You can download and install IAR development tools from the Internet. To compile the Cortex-M4 project, go to the  **cortex-m4\_stm32f429ig\_fire-challenger\_iar/project**  directory and double-click the  **los\_demo.eww**  file to open the desired project. After the compilation is successful, burn the file to the corresponding board using JLINK or STM32 ST-LINK Utility.
-
--   Cortex-M7:
-
-The  **kernel/liteos\_m/targets/cortex-m7\_nucleo\_f767zi\_gcc**  directory is the Makefile project directory created based on the STM32F767ZI chip architecture. The compilation commands are as follows:
-
-```
-cd kernel/liteos_m/targets/cortex-m7_nucleo_f767zi_gcc
-make clean; make
-```
-
-After the compilation is successful, the executable file  **NUCLEO-F767.hex**  is generated in the  **cortex-m7\_nucleo\_f767zi\_gcc/build**  directory. Burn the file to the corresponding board using STM32 ST-LINK Utility.
-
-## Change Log
-
-v1.0.1
-1. removed these KAL apis: `KalThreadGetInfo`,`KalDelayUs`,`KalTimerCreate`,`KalTimerStart`,`KalTimerChange`,`KalTimerStop`,`KalTimerDelete`,`KalTimerIsRunning`,`KalTickToMs`,`KalMsToTick`,`KalGetMemInfo`
-2. add some POSIX apis
-
-v1.0
-1. first release
-
-## Repositories Involved<a name="section1371113476307"></a>
-
-[Kernel subsystem](https://gitee.com/openharmony/docs/blob/master/en/readme/kernel.md)
-
-**kernel\_liteos\_m**
-
+# LiteOS Cortex-M<a name="EN-US_TOPIC_0000001096757661"></a>
+
+-   [Introduction](#section11660541593)
+-   [Directory Structure](#section161941989596)
+-   [Constraints](#section119744591305)
+-   [Usage](#section3732185231214)
+-   [Repositories Involved](#section1371113476307)
+
+## Introduction<a name="section11660541593"></a>
+
+The OpenHarmony LiteOS Cortex-M is the kernel designed for the lightweight operating system \(OS\) for the Internet of Things \(IoT\) field. It features small size, low power consumption, and high performance. In addition, it has a simple code structure, including the minimum kernel function set, kernel abstraction layer, optional components, and project directory, and is divided into the hardware-related and hardware-irrelevant layers. The hardware-related layers provide unified hardware abstraction layer \(HAL\) interfaces to improve hardware adaptability. The combination and classification of different compilation toolchains and chip architectures meet the requirements of the Artificial Intelligence of Things \(AIoT\) field for rich hardware and compilation toolchains.  [Figure1](#fig0865152210223)  shows the architecture of the OpenHarmony LiteOS Cortex-M kernel.
+
+**Figure  1**  Architecture of OpenHarmony the LiteOS Cortex-M kernel<a name="fig0865152210223"></a>  
+![](figures/architecture-of-openharmony-the-liteos-cortex-m-kernel.png "architecture-of-openharmony-the-liteos-cortex-m-kernel")
+
+## Directory Structure<a name="section161941989596"></a>
+
+The directory structure is listed as below, for the detailed directories, please refer to [arch_spec.md](arch_spec.md).
+
+```
+/kernel/liteos_m
+├── components           # Optional components
+│   ├── backtrace        # Backtrace support
+│   ├── cppsupport       # C++ support
+│   ├── cpup             # CPU possession (CPUP)
+│   ├── exchook          # Exception hook
+│   ├── fs               # File system
+│   └── net              # Network support
+├── kal                  # Kernel abstraction layer
+│   ├── cmsis            # CMSIS-compliant API support
+│   └── posix            # POSIX API support
+├── kernel               # Minimum function set support
+│   ├── arch             # Code of the kernel instruction architecture layer
+│   │   ├── arm          # Code of the ARM32 architecture
+│   │   └── include      # APIs exposed externally
+│   ├── include          # APIs exposed externally
+│   └── src              # Source code of the minimum function set of the kernel
+├── targets              # Board-level projects
+├── utils                # Common code
+```
+
+## Constraints<a name="section119744591305"></a>
+
+Programming languages: C and C++
+
+Currently applicable architectures: Cortex-M3, Cortex-M4, Cortex-M7, and RISC-V
+
+## Usage<a name="section3732185231214"></a>
+
+LiteOS Cortex-M provides projects for three chip architectures, which are located in the  **targets**  directory. The methods of compiling and using these projects are as follows:
+
+-   Cortex-M3:
+
+The  **kernel/liteos\_m/targets/cortex-m3\_stm32f103\_simulator\_keil**  directory is the Keil project directory created based on the STM32F103 chip architecture. You can download and install Keil development tools from the Internet. To compile the Cortex-M3 project, go to the  **cortex-m3\_stm32f103\_simulator\_keil/project**  directory and double-click the  **los\_demo.uvproj**  file to open the desired project. After the compilation is successful, burn the file to the corresponding board using JLINK or STM32 ST-LINK Utility.
+
+-   Cortex-M4:
+
+The  **kernel/liteos\_m/targets/cortex-m4\_stm32f429ig\_fire-challenger\_iar**  directory is the IAR project directory created based on the STM32F429IG chip architecture. You can download and install IAR development tools from the Internet. To compile the Cortex-M4 project, go to the  **cortex-m4\_stm32f429ig\_fire-challenger\_iar/project**  directory and double-click the  **los\_demo.eww**  file to open the desired project. After the compilation is successful, burn the file to the corresponding board using JLINK or STM32 ST-LINK Utility.
+
+-   Cortex-M7:
+
+The  **kernel/liteos\_m/targets/cortex-m7\_nucleo\_f767zi\_gcc**  directory is the Makefile project directory created based on the STM32F767ZI chip architecture. The compilation commands are as follows:
+
+```
+cd kernel/liteos_m/targets/cortex-m7_nucleo_f767zi_gcc
+make clean; make
+```
+
+After the compilation is successful, the executable file  **NUCLEO-F767.hex**  is generated in the  **cortex-m7\_nucleo\_f767zi\_gcc/build**  directory. Burn the file to the corresponding board using STM32 ST-LINK Utility.
+
+## Repositories Involved<a name="section1371113476307"></a>
+
+[Kernel subsystem](https://gitee.com/openharmony/docs/blob/master/en/readme/kernel.md)
+
+**kernel\_liteos\_m**
+
diff --git a/kernel/liteos_m/README_zh.md b/kernel/liteos_m/README_zh.md
index dabe1e6..fb98b8f 100644
--- a/kernel/liteos_m/README_zh.md
+++ b/kernel/liteos_m/README_zh.md
@@ -1,79 +1,126 @@
-# LiteOS-M内核<a name="ZH-CN_TOPIC_0000001096757661"></a>
-
--   [简介](#section11660541593)
--   [目录](#section161941989596)
--   [约束](#section119744591305)
--   [使用说明](#section3732185231214)
--   [相关仓](#section1371113476307)
-
-## 简介<a name="section11660541593"></a>
-
-OpenHarmony LiteOS-M内核是面向IoT领域构建的轻量级物联网操作系统内核，具有小体积、低功耗、高性能的特点，其代码结构简单，主要包括内核最小功能集、内核抽象层、可选组件以及工程目录等，分为硬件相关层以及硬件无关层，硬件相关层提供统一的HAL（Hardware Abstraction Layer）接口，提升硬件易适配性，不同编译工具链和芯片架构的组合分类，满足AIoT类型丰富的硬件和编译工具链的拓展。其架构图如图1所示：
-
-**图 1**  OpenHarmony LiteOS-M核内核架构图<a name="fig0865152210223"></a>  
-![](figures/OpenHarmony-LiteOS-M核内核架构图.png "OpenHarmony-LiteOS-M核内核架构图")
-
-## 目录<a name="section161941989596"></a>
-
-```
-/kernel/liteos_m
-├── components           # 可选组件
-│   ├── cppsupport       # C++支持
-│   └── cpup             # CPUP功能
-├── kal                  # 内核抽象层
-│   ├── cmsis            # cmsis标准接口支持
-│   └── posix            # posix标准接口支持
-├── kernel               # 内核最小功能集支持
-│   ├── arch             # 内核指令架构层代码
-│   │   ├── arm          # arm32架构的代码
-│   │   └── include      # 对外接口存放目录
-│   ├── include          # 对外接口存放目录
-│   └── src              # 内核最小功能集源码
-├── targets              # 板级工程目录
-├── utils                # 通用公共目录
-```
-
-## 约束<a name="section119744591305"></a>
-
-开发语言：C/C++；
-
-适用架构：当前只适用于cortex-m3、cortex-m4、cortex-m7、risc-v芯片架构。
-
-## 使用说明<a name="section3732185231214"></a>
-
-LiteOS-M内核提供了三种芯片架构的工程位于targets目录。三种架构的工程编译及使用方式如下：
-
--   cortex-m3：
-
-kernel/liteos\_m/targets/cortex-m3\_stm32f103\_simulator\_keil目录是基于STM32F103芯片架构构建的keil工程目录，keil开发工具可通过网络下载并安装。进入cortex-m3\_stm32f103\_simulator\_keil/project目录，双击los\_demo.uvproj文件即可打开相应工程，编译成功后即可通过JLINK或者STM32 ST-LINK Utility烧录至对应单板。
-
--   cortex-m4：
-
-kernel/liteos\_m/targets/cortex-m4\_stm32f429ig\_fire-challenger\_iar目录是基于STM32F429IG芯片架构构建的IAR工程目录，IAR开发工具可通过网络下载并安装。进入cortex-m4\_stm32f429ig\_fire-challenger\_iar/project目录，双击los\_demo.eww文件即可打开相应工程，编译成功后即可通过JLINK或者STM32 ST-LINK Utility烧录至对应单板。
-
--   cortex-m7：
-
-kernel/liteos\_m/targets/cortex-m7\_nucleo\_f767zi\_gcc目录是基于STM32F767ZI芯片架构构建的Makefile工程目录。编译方式如下：
-
-```
-cd kernel/liteos_m/targets/cortex-m7_nucleo_f767zi_gcc
-make clean; make
-```
-
-编译成功后在cortex-m7\_nucleo\_f767zi\_gcc/build目录下生成NUCLEO-F767.hex可执行文件，通过烧录工具STM32 ST-LINK Utility烧录到对应的单板。
-
-## 修改日志
-
-v1.0.1
-1. 删除以下KAL接口: `KalThreadGetInfo`,`KalDelayUs`,`KalTimerCreate`,`KalTimerStart`,`KalTimerChange`,`KalTimerStop`,`KalTimerDelete`,`KalTimerIsRunning`,`KalTickToMs`,`KalMsToTick`,`KalGetMemInfo`
-2. 添加部分POSIX接口
-
-v1.0
-1. 首次发布
-
-## 相关仓<a name="section1371113476307"></a>
-
-[内核子系统](https://gitee.com/openharmony/docs/blob/master/zh-cn/readme/%E5%86%85%E6%A0%B8%E5%AD%90%E7%B3%BB%E7%BB%9F.md)
-
-**kernel\_liteos\_m**
-
+# LiteOS-M内核<a name="ZH-CN_TOPIC_0000001096757661"></a>
+
+-   [简介](#section11660541593)
+-   [目录](#section161941989596)
+-   [约束](#section119744591305)
+-   [使用说明](#section3732185231214)
+-   [相关仓](#section1371113476307)
+
+## 简介<a name="section11660541593"></a>
+
+OpenHarmony LiteOS-M内核是面向IoT领域构建的轻量级物联网操作系统内核，具有小体积、低功耗、高性能的特点，其代码结构简单，主要包括内核最小功能集、内核抽象层、可选组件以及工程目录等，分为硬件相关层以及硬件无关层，硬件相关层提供统一的HAL（Hardware Abstraction Layer）接口，提升硬件易适配性，不同编译工具链和芯片架构的组合分类，满足AIoT类型丰富的硬件和编译工具链的拓展。其架构图如图1所示：
+
+**图 1**  OpenHarmony LiteOS-M核内核架构图<a name="fig0865152210223"></a>  
+![](figures/OpenHarmony-LiteOS-M核内核架构图.png "OpenHarmony-LiteOS-M核内核架构图")
+
+## 目录<a name="section161941989596"></a>
+
+目录结构如下，详细目录请参考[arch_spec_zh.md](arch_spec_zh.md)。
+
+```
+/kernel/liteos_m
+├── components           # 可选组件
+│   ├── backtrace        # 回溯栈支持
+│   ├── cppsupport       # C++支持
+│   ├── cpup             # CPUP功能
+│   ├── exchook          # 异常钩子
+│   ├── fs               # 文件系统
+│   └── net              # Network功能
+├── kal                  # 内核抽象层
+│   ├── cmsis            # cmsis标准接口支持
+│   └── posix            # posix标准接口支持
+├── kernel               # 内核最小功能集支持
+│   ├── arch             # 内核指令架构层代码
+│   │   ├── arm          # arm32架构的代码
+│   │   └── include      # 对外接口存放目录
+│   ├── include          # 对外接口存放目录
+│   └── src              # 内核最小功能集源码
+├── targets              # 板级工程目录
+├── utils                # 通用公共目录
+```
+
+## 约束<a name="section119744591305"></a>
+
+开发语言：C/C++；
+
+适用架构：当前只适用于cortex-m3、cortex-m4、cortex-m7、risc-v芯片架构。
+
+## 使用说明<a name="section3732185231214"></a>
+
+OpenHarmony LiteOS-M内核的编译构建系统是一个基于gn和ninja的组件化构建系统，支持按组件配置、裁剪和拼装，按需构建出定制化的产品。编译构建系统的详细信息可以参考[轻量和小型系统编译构建指导](https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/subsystems/%E8%BD%BB%E9%87%8F%E5%92%8C%E5%B0%8F%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%E6%9E%84%E5%BB%BA%E6%8C%87%E5%AF%BC.md)。本文主要介绍如何基于gn和ninja编译LiteOS-M工程，GCC+Makefile、IAR、Keil MDK等编译方式可以参考社区爱好者贡献的站点。
+
+### 搭建系统基础环境
+
+在搭建各个开发板环境前，需要完成OpenHarmony系统基础环境搭建。系统基础环境主要是指OpenHarmony的编译环境和开发环境，详细介绍请参考官方站点[Ubuntu编译环境准备](https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/quick-start/Ubuntu%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.md)。开发者需要根据环境搭建文档，完成下述软件的安装：Python3.7+、gn、ninja、hb。对于LiteOS-M内核，还需要安装Make构建工具和[ARM GCC编译工具链](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads)。
+
+### 获取OpenHarmony源码
+
+开发者需要在Linux服务器上通过Git克隆获取OpenHarmony最新源码，详细的源码获取方式，请见[源码获取](https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/get-code/%E6%BA%90%E7%A0%81%E8%8E%B7%E5%8F%96.md)。获取OpenHarmony完整仓代码后，假设克隆目录为`~/openHarmony`。
+
+### 获取示例工程源码
+
+以开发板Nucleo-F767Zi为例，演示如何编译运行`OpenHarmony LiteOS-M`内核工程。在本地目录，执行下述命令克隆示例代码。
+
+```
+git clone https://gitee.com/harylee/nucleo_f767zi.git
+```
+
+假设克隆到的代码目录为`~/nucleo_f767zi`。 执行如下命令把代码目录的`device`、`vendor`目录复制到`openHarmony`工程的相应目录。
+
+```
+mkdir ~/openHarmony/device/st
+
+cp -r ~/nucleo_f767zi/device/st/nucleo_f767zi ~/openHarmony/device/st/nucleo_f767zi
+
+chmod +x ~/openHarmony/device/st/nucleo_f767zi/build.sh
+
+cp -r ~/nucleo_f767zi/vendor/st ~/openHarmony/vendor/st
+```
+
+关于示例代码目录的说明，可以参考资料站点[板级目录规范](https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/porting/%E7%A7%BB%E6%A4%8D%E6%A6%82%E8%BF%B0-0.md#section6204129143013)。如果需要自行移植开发板，请参考[板级系统移植](https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/porting/%E6%9D%BF%E7%BA%A7%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D.md)。
+
+### 编译运行
+
+编译运行前，交叉编译工具链`bin`目录配置到`PATH`环境变量中或者配置`device/st/nucleo_f767zi/liteos_m/config.gni`文件中`board_toolchain_path`配置项为交叉编译工具链`bin`目录。
+在`OpenHarmony`根目录，执行`hb set`设置产品路径，选择`nucleo_f767zi`产品，然后执行`hb build`开启编译。如下：
+
+```
+user@dev:~/OpenHarmony$ hb set
+
+[OHOS INFO] Input code path: # 直接按回车，然后选择nucleo_f767zi产品即可
+
+OHOS Which product do you need? nucleo_f767zi@st
+
+user@dev:~/OpenHarmony$ hb build
+```
+
+最终的镜像生成在`~/openHarmony/out/nucleo_f767zi/`目录中，通过`STM32 ST-LINK Utility`软件将镜像文件下载至单板查看运行效果。
+
+### 社区移植工程链接
+
+LiteOS-M内核移植的具体开发板的工程由社区开发者提供，可以访问社区开发者代码仓获取。如果您移植支持了更多开发板，可以提供链接给我们进行社区分享。
+
+-   cortex-m3：
+
+    - STM32F103   https://gitee.com/rtos_lover/stm32f103_simulator_keil
+
+        该仓包含OpenHarmony LiteOS-M内核基于STM32F103芯片架构构建的Keil工程，支持Keil MDK方式进行编译。
+
+-   cortex-m4：
+
+    - 野火挑战者STM32F429IGTb   https://gitee.com/harylee/stm32f429ig_firechallenger
+
+        该仓包含OpenHarmony LiteOS-M内核移植支持`野火挑战者STM32F429IGTb`开发板的工程代码，支持Ninja、GCC、IAR等方式进行编译。
+
+-   cortex-m7：
+
+    - Nucleo-F767ZI   https://gitee.com/harylee/nucleo_f767zi
+
+        该仓包含OpenHarmony LiteOS-M内核移植支持`Nucleo-F767ZI`开发板的工程代码，支持Ninja、GCC、IAR等方式进行编译。
+
+## 相关仓<a name="section1371113476307"></a>
+
+[内核子系统](https://gitee.com/openharmony/docs/blob/master/zh-cn/readme/%E5%86%85%E6%A0%B8%E5%AD%90%E7%B3%BB%E7%BB%9F.md)
+
+**kernel\_liteos\_m**
+
diff --git a/kernel/liteos_m/arch_spec.md b/kernel/liteos_m/arch_spec.md
index 0b3650f..54b0aee 100644
--- a/kernel/liteos_m/arch_spec.md
+++ b/kernel/liteos_m/arch_spec.md
@@ -1,52 +1,76 @@
-```
-.
-├── components                                                  --- 可选组件，可裁剪，依赖kernel
-│   ├── cppsupport                                              --- C++支持
-│   └── cpup                                                    --- CPUP功能
-├── kal                                                         --- 内核抽象层
-│   ├── cmsis                                                   --- cmsis标准支持
-│   └── posix                                                   --- posix标准支持
-├── kernel                                                      --- 内核最小功能集支持
-│   ├── arch                                                    --- 硬件架构相关
-│   │   ├── arm                                                 --- arm32架构
-│   │   │   └── cortex-m4                                       --- cortex-m4架构
-│   │   │       └── iar                                         ---
-│   │   │           ├── los_atomic.h
-│   │   │           ├── los_context.h
-│   │   │           ├── los_interrupt.h
-│   │   │           └── los_mpu.h
-│   │   └── include
-│   │       ├── los_arch_atomic.h                               --- 定义通用arch的原子操作
-│   │       ├── los_arch_context.h                              --- 定义通用arch的上下文切换
-│   │       ├── los_arch.h                                      --- 定义通用arch初始化
-│   │       └── los_arch_interrupt.h                            --- 定义通用arch中断
-│   ├── include
-│   │   ├── los_config.h                                        --- 功能开关和配置参数
-│   │   ├── los_event.h                                         --- 事件
-│   │   ├── los_liteos.h                                        --- liteos最小功能集对外提供的头文件
-│   │   ├── los_memory.h                                        --- 堆内存管理
-│   │   ├── los_mutex.h                                         --- 互斥锁
-│   │   ├── los_queue.h                                         --- 队列
-│   │   ├── los_scheduler.h                                     --- 调度算法
-│   │   ├── los_sem.h                                           --- 信号量
-│   │   ├── los_task.h                                          --- 任务
-│   │   └── los_timer.h                                         --- 定时器
-│   └── src
-├── targets
-│   └── targets
-│       └── cortex-m4_stm32f429ig_fire-challenger_iar
-│           ├── board
-│           ├── dprintf.c
-│           ├── Libraries
-│           ├── main.c
-│           ├── project
-│           ├── target_config.h                                 --- 板级配置功能开关和配置参数
-│           └── Utilities
-└── utils
-    ├── include
-    │   ├── los_compiler.h                                      --- 编译工具配置，类型定义
-    │   ├── los_debug.h                                         --- debug，printf相关
-    │   ├── los_error.h                                         --- 错误定义
-    │   └── los_list.h
-    └── src
-```
+```
+.
+├── components                                                  --- Components available for porting and header files exposed externally
+│   ├── backtrace                                               --- Backtrace
+│   ├── cppsupport                                              --- C++
+│   ├── cpup                                                    --- CPUP
+│   ├── exchook                                                 --- Exception hook
+│   ├── fs                                                      --- File System
+│   └── net                                                     --- Network
+├── kal                                                         --- Kernel Abstraction Layer, APIs exposed externally, including CMSIS APIs and part of POSIX APIs
+│   ├── cmsis                                                   --- CMSIS
+│   └── posix                                                   --- POSIX
+├── kernel                                                      --- Code for defining the minimum kernel function set
+│   ├── arch                                                    --- Code of the kernel instruction architecture layer
+│   │   ├── arm                                                 --- ARM32 architecture
+│   │   │   ├── cortex-m3                                       --- Cortex-m3 architecture
+│   │   │   │   └── keil                                        --- Implementation of the Keil toolchain
+│   │   │   ├── cortex-m33                                      --- Cortex-m33 architecture
+│   │   │   │   │── gcc                                         --- Implementation of the GCC toolchain
+│   │   │   │   └── iar                                         --- Implementation of the IAR toolchain
+│   │   │   └── cortex-m4                                       --- Cortex-m4 architecture
+│   │   │   │   │── gcc                                         --- Implementation of the GCC toolchain
+│   │   │   │   └── iar                                         --- Implementation of the IAR toolchain
+│   │   │   └── cortex-m7                                       --- Cortex-m7 architecture
+│   │   │   │   │── gcc                                         --- Implementation of the GCC toolchain
+│   │   │   │   └── iar                                         --- Implementation of the IAR toolchain
+│   │   ├── risc-v                                              --- Risc-v architecture
+│   │   │   ├── nuclei                                          --- Nuclei architecture
+│   │   │   │   └── gcc                                         --- Implementation of the GCC toolchain
+│   │   │   └── riscv32                                         --- Riscv32 architecture
+│   │   │   │   └── gcc                                         --- Implementation of the GCC toolchain
+│   │   └── include
+│   │       ├── los_arch.h                                      --- Arch initialization
+│   │       ├── los_atomic.h                                    --- Atomic operations
+│   │       ├── los_context.h                                   --- Context switch
+│   │       ├── los_interrupt.h                                 --- Interrupts
+│   │       ├── los_mpu.h                                       --- Memory protection unit operations
+│   │       └── los_timer.h                                     --- Timer operations
+│   ├── include
+│   │   ├── los_config.h                                        --- Configuration parameters
+│   │   ├── los_event.h                                         --- Events management
+│   │   ├── los_membox.h                                        --- Membox management
+│   │   ├── los_memory.h                                        --- Heap memory management
+│   │   ├── los_mux.h                                           --- Mutex
+│   │   ├── los_queue.h                                         --- Queue
+│   │   ├── los_sched.h                                         --- Scheduler
+│   │   ├── los_sem.h                                           --- Semaphores
+│   │   ├── los_sortlink.h                                      --- Sort link
+│   │   ├── los_swtmr.h                                         --- Timer
+│   │   ├── los_task.h                                          --- Tasks
+│   │   └── los_tick.h                                          --- Tick
+│   └── src
+├── targets
+│   └── targets
+│       └── riscv_nuclei_demo_soc_gcc
+│       │   ├── GCC                                            --- Compilation config
+│       │   ├── OS_CONFIG                                      --- Board config
+│       │   ├── SoC                                            --- SOC codes
+│       │   └── Src                                            --- Application codes
+│       └── riscv_nuclei_gd32vf103_soc_gcc
+│       └── riscv_sifive_fe310_gcc
+└── utils
+    ├── internal
+    ├── BUILD.gn                                               --- Gn build config file
+    ├── los_compiler.h                                         --- Compiler configuration
+    ├── los_debug.c                                            --- Debugging facilities
+    ├── los_debug.h
+    ├── los_error.c                                            --- Errors codes and definitions
+    ├── los_error.h
+    ├── los_hook.c                                             --- Hook function facilities
+    ├── los_hook.h
+    ├── los_list.h                                             --- Doubly linked list
+    └── los_reg.h                                              --- Register macros
+    └── src
+```
+
diff --git a/kernel/liteos_m/arch_spec_zh.md b/kernel/liteos_m/arch_spec_zh.md
new file mode 100644
index 0000000..5928748
--- /dev/null
+++ b/kernel/liteos_m/arch_spec_zh.md
@@ -0,0 +1,76 @@
+```
+.
+├── components                                                  --- 移植可选组件，依赖内核，单独对外提供头文件
+│   ├── backtrace                                               --- 回溯栈支持
+│   ├── cppsupport                                              --- C++支持
+│   ├── cpup                                                    --- CPUP功能
+│   ├── exchook                                                 --- 异常钩子
+│   ├── fs                                                      --- 文件系统
+│   └── net                                                     --- 网络功能
+├── kal                                                         --- 内核抽象层，提供内核对外接口，当前支持CMSIS接口和部分POSIX接口
+│   ├── cmsis                                                   --- CMSIS标准支持
+│   └── posix                                                   --- POSIX标准支持
+├── kernel                                                      --- 内核最小功能集代码
+│   ├── arch                                                    --- 内核指令架构层代码
+│   │   ├── arm                                                 --- ARM32架构
+│   │   │   ├── cortex-m3                                       --- Cortex-m3架构
+│   │   │   │   └── keil                                        --- Keil编译工具链实现
+│   │   │   ├── cortex-m33                                      --- Cortex-m33架构
+│   │   │   │   │── gcc                                         --- GCC编译工具链实现
+│   │   │   │   └── iar                                         --- IAR编译工具链实现
+│   │   │   └── cortex-m4                                       --- Cortex-m4架构
+│   │   │   │   │── gcc                                         --- GCC编译工具链实现
+│   │   │   │   └── iar                                         --- IAR编译工具链实现
+│   │   │   └── cortex-m7                                       --- Cortex-m7架构
+│   │   │   │   │── gcc                                         --- GCC编译工具链实现
+│   │   │   │   └── iar                                         --- IAR编译工具链实现
+│   │   ├── risc-v                                              --- Risc-v架构
+│   │   │   ├── nuclei                                          --- Nuclei架构
+│   │   │   │   └── gcc                                         --- GCC编译工具链实现
+│   │   │   └── riscv32                                         --- Riscv32架构
+│   │   │   │   └── gcc                                         --- GCC编译工具链实现
+│   │   └── include
+│   │       ├── los_arch.h                                      --- 定义arch初始化
+│   │       ├── los_atomic.h                                    --- 定义通用arch原子操作
+│   │       ├── los_context.h                                   --- 定义通用arch上下文切换
+│   │       ├── los_interrupt.h                                 --- 定义通用arch中断
+│   │       ├── los_mpu.h                                       --- 定义通用arch内存保护
+│   │       └── los_timer.h                                     --- 定义通用arch定时器
+│   ├── include
+│   │   ├── los_config.h                                        --- 功能开关和配置参数
+│   │   ├── los_event.h                                         --- 事件
+│   │   ├── los_membox.h                                        --- 静态内存管理
+│   │   ├── los_memory.h                                        --- 动态内存管理
+│   │   ├── los_mux.h                                           --- 互斥锁
+│   │   ├── los_queue.h                                         --- 队列
+│   │   ├── los_sched.h                                         --- 调度算法
+│   │   ├── los_sem.h                                           --- 信号量
+│   │   ├── los_sortlink.h                                      --- 排序链表
+│   │   ├── los_swtmr.h                                         --- 定时器
+│   │   ├── los_task.h                                          --- 任务
+│   │   └── los_tick.h                                          --- Tick时钟
+   └── src
+├── targets
+│   └── targets
+│       └── riscv_nuclei_demo_soc_gcc
+│       │   ├── GCC                                             --- 编译相关
+│       │   ├── OS_CONFIG                                       --- 开发板配置功能开关和配置参数
+│       │   ├── SoC                                             --- SOC相关代码
+│       │   └── Src                                             --- Application相关代码
+│       └── riscv_nuclei_gd32vf103_soc_gcc
+│       └── riscv_sifive_fe310_gcc
+└── utils
+    ├── internal
+    ├── BUILD.gn                                                --- Gn构建文件
+    ├── los_compiler.h                                          --- 编译工具配置，类型定义
+    ├── los_debug.c                                             --- Debug，printf相关
+    ├── los_debug.h
+    ├── los_error.c                                             --- 错误处理
+    ├── los_error.h
+    ├── los_hook.c                                              --- 钩子函数注册和调用
+    ├── los_hook.h
+    ├── los_list.h                                              --- 双向链表
+    └── los_reg.h                                               --- 寄存器读写宏定义
+    └── src
+```
+
diff --git a/kernel/liteos_m/components/backtrace/BUILD.gn b/kernel/liteos_m/components/backtrace/BUILD.gn
index c6839ea..e63f4fa 100644
--- a/kernel/liteos_m/components/backtrace/BUILD.gn
+++ b/kernel/liteos_m/components/backtrace/BUILD.gn
@@ -1,40 +1,39 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-static_library("backtrace") {
-  sources = [ "los_backtrace.c" ]
-
-  include_dirs = [
-    "../../kernel/include",
-    "../../kernel/arch/include",
-    "../../utils",
-    "./",
-    "//third_party/bounds_checking_function/include",
-  ]
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("backtrace") {
+  sources = [ "los_backtrace.c" ]
+
+  include_dirs = [
+    "../../kernel/include",
+    "../../kernel/arch/include",
+    "../../utils",
+    "//third_party/bounds_checking_function/include",
+  ]
+}
diff --git a/kernel/liteos_m/components/backtrace/los_backtrace.c b/kernel/liteos_m/components/backtrace/los_backtrace.c
index dc0c42f..1cb41f7 100644
--- a/kernel/liteos_m/components/backtrace/los_backtrace.c
+++ b/kernel/liteos_m/components/backtrace/los_backtrace.c
@@ -33,11 +33,6 @@
 #include "los_task.h"
 #include "los_debug.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 #if (LOSCFG_BACKTRACE_TYPE != 0)
 #if (LOSCFG_BACKTRACE_TYPE == 1)
@@ -117,7 +112,7 @@ STATIC INLINE UINT32 OsStackAddrGet(UINTPTR *stackStart, UINTPTR *stackEnd, UINT
 {
     if (SP != 0) {
         *stackStart = SP;
-        if ((SP >= CODE_START_ADDR) && (SP < CSTACK_END_ADDR)) {
+        if ((SP >= CSTACK_START_ADDR) && (SP < CSTACK_END_ADDR)) {
             *stackEnd = CSTACK_END_ADDR;
         } else {
             UINT32 taskID = LOS_CurTaskIDGet();
@@ -125,7 +120,7 @@ STATIC INLINE UINT32 OsStackAddrGet(UINTPTR *stackStart, UINTPTR *stackEnd, UINT
             *stackEnd = (UINTPTR)taskCB->topOfStack + taskCB->stackSize;
             if ((SP < (UINTPTR)taskCB->topOfStack) || (SP >= *stackEnd)) {
                 PRINT_ERR("msp statck [0x%x, 0x%x], cur task stack [0x%x, 0x%x], cur sp(0x%x) is overflow!\n",
-                           CODE_START_ADDR, CSTACK_END_ADDR, (UINTPTR)taskCB->topOfStack, *stackEnd, SP);
+                          CSTACK_START_ADDR, CSTACK_END_ADDR, (UINTPTR)taskCB->topOfStack, *stackEnd, SP);
                 return LOS_NOK;
             }
         }
@@ -133,9 +128,9 @@ STATIC INLINE UINT32 OsStackAddrGet(UINTPTR *stackStart, UINTPTR *stackEnd, UINT
         if (HalSpGet() != HalPspGet()) {
             *stackStart = HalMspGet();
             *stackEnd = CSTACK_END_ADDR;
-            if ((*stackStart < CODE_START_ADDR) || (*stackStart >= CSTACK_END_ADDR)) {
+            if ((*stackStart < CSTACK_START_ADDR) || (*stackStart >= CSTACK_END_ADDR)) {
                 PRINT_ERR("msp stack [0x%x, 0x%x], cur sp(0x%x) is overflow!\n",
-                           CODE_START_ADDR, CSTACK_END_ADDR, *stackStart);
+                          CSTACK_START_ADDR, CSTACK_END_ADDR, *stackStart);
                 return LOS_NOK;
             }
             PRINTK("msp, start = %x, end = %x\n", *stackStart, *stackEnd);
@@ -146,7 +141,7 @@ STATIC INLINE UINT32 OsStackAddrGet(UINTPTR *stackStart, UINTPTR *stackEnd, UINT
             *stackEnd = (UINTPTR)taskCB->topOfStack + taskCB->stackSize;
             if ((*stackStart < (UINTPTR)taskCB->topOfStack) || (*stackStart >= *stackEnd)) {
                 PRINT_ERR("psp stack [0x%x, 0x%x], cur sp(0x%x) is overflow, cur task id is %d!\n",
-                           taskCB->topOfStack, *stackEnd, *stackStart, taskID);
+                          taskCB->topOfStack, *stackEnd, *stackStart, taskID);
                 return LOS_NOK;
             }
             PRINTK("psp, start = %x, end = %x\n", *stackStart, *stackEnd);
@@ -184,45 +179,6 @@ STATIC INLINE UINTPTR OsAddrIsValid(UINTPTR sp)
 
     return pc;
 }
-
-VOID LOS_RecordLR(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR SP)
-{
-    if (LR == NULL) {
-        return;
-    }
-
-    UINTPTR stackStart;
-    UINTPTR stackEnd;
-    UINT32 count = 0;
-    UINT32 index = 0;
-    UINTPTR sp;
-    UINTPTR pc;
-    UINT32 ret;
-
-    ret = OsStackAddrGet(&stackStart, &stackEnd, SP);
-    if (ret != LOS_OK) {
-        return;
-    }
-
-    /* Traverse the stack space and find the LR address. */
-    for (sp = stackStart; sp < stackEnd; sp += sizeof(UINTPTR)) {
-        pc = OsAddrIsValid(sp);
-        if ((pc != 0) && (count < LRSize)) {
-            if (index++ < jumpCount) {
-                continue;
-            }
-            LR[count] = pc;
-            count++;
-            if (count == LRSize) {
-                break;
-            }
-        }
-    }
-
-    if (count < LRSize) {
-        LR[count] = 0;
-    }
-}
 #elif (LOSCFG_BACKTRACE_TYPE == 2)
 STATIC INLINE BOOL OsBackTraceFpCheck(UINT32 value);
 #define OS_BACKTRACE_START     1
@@ -232,7 +188,7 @@ STATIC INLINE BOOL OsBackTraceFpCheck(UINT32 value);
 #define OS_FP_CHECK(value)     (((UINT32)(value) != FP_INIT_VALUE) && OS_FP_ALIGN(value))
 
 STATIC INLINE UINTPTR OsFpGet(VOID)
-{
+{
     UINTPTR fp = 0;
     __asm volatile("mv %0, s0" : "=r"(fp));
     dsb();
@@ -243,8 +199,8 @@ VOID LOS_RecordLR(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR SP)
 {
     UNUSED(SP);
     UINT32 backFp = OsFpGet();
-    UINT32 tmpFp;
-    UINT32 backRa;
+    UINT32 tmpFp;
+    UINT32 backRa;
     UINT32 count = 0;
     UINT32 index = 0;
 
@@ -253,7 +209,7 @@ VOID LOS_RecordLR(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR SP)
     }
 
     while (OS_FP_CHECK(backFp)) {
-        tmpFp = backFp;
+        tmpFp = backFp;
         backRa = *((UINT32 *)(UINTPTR)(tmpFp - OS_RA_OFFSET));
         backFp = *((UINT32 *)(UINTPTR)(tmpFp - OS_FP_OFFSET));
         if (index++ < jumpCount) {
@@ -264,8 +220,163 @@ VOID LOS_RecordLR(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR SP)
         count++;
         if ((count == LRSize) || (backFp == tmpFp) ||
             (!OsStackDataIsCodeAddr(backRa))) {
-            break;
-        }
+            break;
+        }
+    }
+
+    if (count < LRSize) {
+        LR[count] = 0;
+    }
+}
+#elif (LOSCFG_BACKTRACE_TYPE == 3)
+#define OS_BACKTRACE_START  1
+#define OS_JALX_INS_MASK    0x7F
+#define OS_JAL_INS_LOW      0x6F
+#define OS_JAL_16_INS_MASK  0x2001
+#define OS_JALR_INS_LOW     0x67
+#define OS_JALR_16_INS_MASK 0x9002
+#define OS_JR_16_INS_MASK   0x8002
+#define OS_J_16_INS_MASK    0xA001
+
+STATIC INLINE BOOL OsInsIsJump(UINTPTR addr)
+{
+    UINT16 ins1 = *((UINT16 *)addr);
+    UINT16 ins2 = *((UINT16 *)(addr + 2)); // 2, for the mask
+
+    /* Jal ins */
+    if (((ins1 & OS_JALX_INS_MASK) == OS_JAL_INS_LOW) ||
+        ((ins1 & OS_JAL_16_INS_MASK) == OS_JAL_16_INS_MASK) ||
+        ((ins2 & OS_JAL_16_INS_MASK) == OS_JAL_16_INS_MASK)) {
+        return TRUE;
+    }
+
+    /* Jalr ins */
+    if (((ins1 & OS_JALX_INS_MASK) == OS_JALR_INS_LOW) ||
+        ((ins1 & OS_JALR_16_INS_MASK) == OS_JALR_16_INS_MASK) ||
+        ((ins2 & OS_JALR_16_INS_MASK) == OS_JALR_16_INS_MASK)) {
+        return TRUE;
+    }
+
+    /* Jr ins */
+    if (((ins1 & OS_JR_16_INS_MASK) == OS_JR_16_INS_MASK) ||
+        ((ins2 & OS_JR_16_INS_MASK) == OS_JR_16_INS_MASK)) {
+        return TRUE;
+    }
+
+    /* J ins */
+    if (((ins1 & OS_J_16_INS_MASK) == OS_J_16_INS_MASK) ||
+        ((ins2 & OS_J_16_INS_MASK) == OS_J_16_INS_MASK)) {
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+STATIC INLINE UINTPTR OsSpGet(VOID)
+{
+    UINTPTR sp = 0;
+    __asm volatile("mv %0, sp" : "=r"(sp));
+    dsb();
+    return sp;
+}
+
+STATIC INLINE UINT32 OsStackAddrGet(UINTPTR *stackStart, UINTPTR *stackEnd, UINTPTR SP)
+{
+    if (SP != 0) {
+        *stackStart = SP;
+        if ((SP >= CSTACK_START_ADDR) && (SP < CSTACK_END_ADDR)) {
+            *stackEnd = CSTACK_END_ADDR;
+        } else {
+            UINT32 taskID = LOS_CurTaskIDGet();
+            LosTaskCB *taskCB = OS_TCB_FROM_TID(taskID);
+            *stackEnd = (UINTPTR)taskCB->topOfStack + taskCB->stackSize;
+            if ((SP < (UINTPTR)taskCB->topOfStack) || (SP >= *stackEnd)) {
+                PRINT_ERR("msp statck [0x%x, 0x%x], cur task stack [0x%x, 0x%x], cur sp(0x%x) is overflow!\n",
+                          CSTACK_START_ADDR, CSTACK_END_ADDR, (UINTPTR)taskCB->topOfStack, *stackEnd, SP);
+                return LOS_NOK;
+            }
+        }
+    } else {
+        if (!LOS_TaskIsRunning()) {
+            *stackStart = OsSpGet();
+            *stackEnd = CSTACK_END_ADDR;
+            if ((*stackStart < CSTACK_START_ADDR) || (*stackStart >= CSTACK_END_ADDR)) {
+                PRINT_ERR("msp stack [0x%x, 0x%x], cur sp(0x%x) is overflow!\n",
+                          CSTACK_START_ADDR, CSTACK_END_ADDR, *stackStart);
+                return LOS_NOK;
+            }
+        } else {
+            *stackStart = OsSpGet();
+            UINT32 taskID = LOS_CurTaskIDGet();
+            LosTaskCB *taskCB = OS_TCB_FROM_TID(taskID);
+            *stackEnd = (UINTPTR)taskCB->topOfStack + taskCB->stackSize;
+            if ((*stackStart < (UINTPTR)taskCB->topOfStack) || (*stackStart >= *stackEnd)) {
+                PRINT_ERR("psp stack [0x%x, 0x%x], cur sp(0x%x) is overflow, cur task id is %d!\n",
+                          taskCB->topOfStack, *stackEnd, *stackStart, taskID);
+                return LOS_NOK;
+            }
+        }
+    }
+
+    return LOS_OK;
+}
+
+STATIC INLINE UINTPTR OsAddrIsValid(UINTPTR sp)
+{
+    UINTPTR pc;
+    BOOL ret;
+
+    pc = *((UINTPTR *)sp);
+
+    ret = OsStackDataIsCodeAddr(pc);
+    if (ret == FALSE) {
+        return 0;
+    }
+
+    ret = OsInsIsJump(pc - sizeof(UINTPTR));
+    if (ret == FALSE) {
+        return 0;
+    }
+
+    return pc;
+}
+#else
+#error Unknown backtrace type.
+#endif
+
+#if (LOSCFG_BACKTRACE_TYPE == 1) || (LOSCFG_BACKTRACE_TYPE == 3)
+VOID LOS_RecordLR(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR SP)
+{
+    if (LR == NULL) {
+        return;
+    }
+
+    UINTPTR stackStart;
+    UINTPTR stackEnd;
+    UINT32 count = 0;
+    UINT32 index = 0;
+    UINTPTR sp;
+    UINTPTR pc;
+    UINT32 ret;
+
+    ret = OsStackAddrGet(&stackStart, &stackEnd, SP);
+    if (ret != LOS_OK) {
+        return;
+    }
+
+    /* Traverse the stack space and find the LR address. */
+    for (sp = stackStart; sp < stackEnd; sp += sizeof(UINTPTR)) {
+        pc = OsAddrIsValid(sp);
+        if ((pc != 0) && (count < LRSize)) {
+            if (index++ < jumpCount) {
+                continue;
+            }
+            LR[count] = pc;
+            count++;
+            if (count == LRSize) {
+                break;
+            }
+        }
     }
 
     if (count < LRSize) {
@@ -298,15 +409,10 @@ VOID LOS_BackTrace(VOID)
     PRINTK("----- traceback end -----\r\n");
 }
 
-VOID LOS_BackTraceInit(VOID)
+VOID OSBackTraceInit(VOID)
 {
     OsBackTraceHookSet(LOS_RecordLR);
 }
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
diff --git a/kernel/liteos_m/components/backtrace/los_backtrace.h b/kernel/liteos_m/components/backtrace/los_backtrace.h
index b0d27d4..a38c189 100644
--- a/kernel/liteos_m/components/backtrace/los_backtrace.h
+++ b/kernel/liteos_m/components/backtrace/los_backtrace.h
@@ -46,7 +46,7 @@ extern "C" {
 #if (LOSCFG_BACKTRACE_TYPE != 0)
 #if (LOSCFG_BACKTRACE_TYPE == 1)
 /* The default name of the code section and CSTACK section are given below,
-   and the user can be adjust it according to the linker script file. */
+   and the user can adjust it according to the linker script file. */
 #if defined(__ICCARM__)
 /* The default code section name is .text */
 #define CODE_SECTION_NAME    ".text"
@@ -91,9 +91,9 @@ extern CHAR *CODE_SECTION_END(CODE_SECTION_NAME);
 #define CSTACK_START_ADDR   ((UINTPTR)&CSTACK_SECTION_START(CSTACK_SECTION_NAME))
 #define CSTACK_END_ADDR     ((UINTPTR)&CSTACK_SECTION_END(CSTACK_SECTION_NAME))
 #elif defined(__GNUC__)
-/* The defalut code section start address */
+/* The default code section start address */
 #define CODE_SECTION_START      _stext
-/* The defalut code section end address */
+/* The default code section end address */
 #define CODE_SECTION_END        _etext
 /* The default C stack section start address */
 #define CSTACK_SECTION_START    _sstack
@@ -115,18 +115,26 @@ extern CHAR *CSTACK_SECTION_END;
 #else
 #error Unknown compiler.
 #endif
-#elif (LOSCFG_BACKTRACE_TYPE == 2)
+#elif (LOSCFG_BACKTRACE_TYPE == 2) || (LOSCFG_BACKTRACE_TYPE == 3)
 #if defined(__GNUC__)
-/* The defalut code section start address */
+/* The default code section start address */
 #define CODE_SECTION_START      __text_start
-/* The defalut code section end address */
+/* The default code section end address */
 #define CODE_SECTION_END        __text_end
+/* The default C stack section start address */
+#define CSTACK_SECTION_START    __except_stack_top
+/* The default C stack section end address */
+#define CSTACK_SECTION_END      __start_and_irq_stack_top
 
 extern CHAR *CODE_SECTION_START;
 extern CHAR *CODE_SECTION_END;
+extern CHAR *CSTACK_SECTION_START;
+extern CHAR *CSTACK_SECTION_END;
 
-#define CODE_START_ADDR         ((UINTPTR)&CODE_SECTION_START)
-#define CODE_END_ADDR           ((UINTPTR)&CODE_SECTION_END)
+#define CODE_START_ADDR     ((UINTPTR)&CODE_SECTION_START)
+#define CODE_END_ADDR       ((UINTPTR)&CODE_SECTION_END)
+#define CSTACK_START_ADDR   ((UINTPTR)&CSTACK_SECTION_START)
+#define CSTACK_END_ADDR     ((UINTPTR)&CSTACK_SECTION_END)
 #else
 #error Unknown compiler.
 #endif
@@ -145,7 +153,7 @@ STATIC INLINE BOOL OsStackDataIsCodeAddr(UINTPTR value)
 
 /* This function is currently used to register the memory leak check hook,
    other uses do not need to be called temporarily. */
-VOID LOS_BackTraceInit(VOID);
+VOID OSBackTraceInit(VOID);
 
 /* This function is used to print the function call stack. */
 VOID LOS_BackTrace(VOID);
diff --git a/kernel/liteos_m/components/bounds_checking_function/BUILD.gn b/kernel/liteos_m/components/bounds_checking_function/BUILD.gn
old mode 100755
new mode 100644
diff --git a/kernel/liteos_m/components/bounds_checking_function/README.OpenSource b/kernel/liteos_m/components/bounds_checking_function/README.OpenSource
index 578713d..c07b384 100644
--- a/kernel/liteos_m/components/bounds_checking_function/README.OpenSource
+++ b/kernel/liteos_m/components/bounds_checking_function/README.OpenSource
@@ -1,13 +1,13 @@
-[
-    {
-        "Name"                  : "bounds_checking_function",
-        "License"               : "Mulan Permissive Software License，Version 2",
-        "License File"          : "LICENSE",
-        "Version Number"        : "v1.1.10",
-        "Owner"                 : "jianghan2@huawei.com",
-        "PDM Number"            : "05835DMT",
-        "Upstream URL"          : "https://gitee.com/openeuler/bounds_checking_function",
-        "Use Application URL"   : "http://pdm.huawei.com/Windchill/hwdispatcher/iris/?status=view&pboid=OR:ext.huawei.huaweipbo.HuaweiPBO:70160914898&virtualid=basicinfo&lang=en",
-        "Description"           : "following the standard of C11 Annex K (bound-checking interfaces), functions of the common memory/string operation classes, such as memcpy_s, strcpy_s, are selected and implemented."
-    }
+[
+    {
+        "Name"                  : "bounds_checking_function",
+        "License"               : "Mulan Permissive Software License，Version 2",
+        "License File"          : "LICENSE",
+        "Version Number"        : "v1.1.10",
+        "Owner"                 : "jianghan2@huawei.com",
+        "PDM Number"            : "05835DMT",
+        "Upstream URL"          : "https://gitee.com/openeuler/bounds_checking_function",
+        "Use Application URL"   : "http://pdm.huawei.com/Windchill/hwdispatcher/iris/?status=view&pboid=OR:ext.huawei.huaweipbo.HuaweiPBO:70160914898&virtualid=basicinfo&lang=en",
+        "Description"           : "following the standard of C11 Annex K (bound-checking interfaces), functions of the common memory/string operation classes, such as memcpy_s, strcpy_s, are selected and implemented."
+    }
 ]
\ No newline at end of file
diff --git a/kernel/liteos_m/components/cppsupport/BUILD.gn b/kernel/liteos_m/components/cppsupport/BUILD.gn
index d74632f..423dc79 100644
--- a/kernel/liteos_m/components/cppsupport/BUILD.gn
+++ b/kernel/liteos_m/components/cppsupport/BUILD.gn
@@ -1,37 +1,34 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-static_library("cppsupport") {
-  sources = [ "los_cppsupport.c" ]
-
-  include_dirs = [
-    "../../utils",
-    "./",
-  ]
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("cppsupport") {
+  sources = [ "los_cppsupport.c" ]
+
+  include_dirs = [ "../../utils" ]
+}
diff --git a/kernel/liteos_m/components/cppsupport/los_cppsupport.c b/kernel/liteos_m/components/cppsupport/los_cppsupport.c
index dcdbe8b..53f8e0a 100644
--- a/kernel/liteos_m/components/cppsupport/los_cppsupport.c
+++ b/kernel/liteos_m/components/cppsupport/los_cppsupport.c
@@ -1,60 +1,50 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "los_cppsupport.h"
-
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
-
-typedef VOID (*InitFunc)(VOID);
-
-INT32 LOS_CppSystemInit(UINTPTR initArrayStart, UINTPTR initArrayEnd)
-{
-    UINTPTR *start;
-    InitFunc initFunc = NULL;
-
-    for (start = (UINTPTR *)initArrayStart; start < (UINTPTR *)initArrayEnd; start++){
-        initFunc = (InitFunc)(*start);
-        initFunc();
-    }
-
-    return 0;
-}
-
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_cppsupport.h"
+
+
+typedef VOID (*InitFunc)(VOID);
+
+INT32 LOS_CppSystemInit(UINTPTR initArrayStart, UINTPTR initArrayEnd)
+{
+    UINTPTR *start;
+    InitFunc initFunc = NULL;
+
+    for (start = (UINTPTR *)initArrayStart; start < (UINTPTR *)initArrayEnd; start++){
+        initFunc = (InitFunc)(*start);
+        initFunc();
+    }
+
+    return 0;
+}
+
+
diff --git a/kernel/liteos_m/components/cppsupport/los_cppsupport.h b/kernel/liteos_m/components/cppsupport/los_cppsupport.h
index 6ede711..4fc0b25 100644
--- a/kernel/liteos_m/components/cppsupport/los_cppsupport.h
+++ b/kernel/liteos_m/components/cppsupport/los_cppsupport.h
@@ -1,77 +1,77 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- * @defgroup los_cppsupport c++
- * @ingroup kernel
- */
-
-#ifndef _LOS_CPPSUPPORT_H
-#define _LOS_CPPSUPPORT_H
-
-#include "los_compiler.h"
-
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
-
-/**
- * @ingroup los_cppsupport
- * @brief System cppsupport initialization.
- *
- * @par Description:
- * This API is used to initialize the cppsupport .
- * @attention
- * <ul>
- * <li>initArrayStart is the start address of .init_array section,
- * initArrayEnd is the end address of .init_array section.</li>
- * <li>initArrayStart must be smaller than initArrayEnd,
- * initArrayStart and initArrayEnd should be 4(32 bits platform) or 8(64 bits platform) bytes alignment.</li>
- * </ul>
- *
- *
- * @retval 0 always return 0.
- * @par Dependency:
- * <ul><li>los_cppsupport.h: the header file that contains the API declaration.</li></ul>
- * @see None.
- */
-extern INT32 LOS_CppSystemInit(UINTPTR initArrayStart, UINTPTR initArrayEnd);
-
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
-
-#endif /* _LOS_CPPSUPPORT_H */
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @defgroup los_cppsupport c++
+ * @ingroup kernel
+ */
+
+#ifndef _LOS_CPPSUPPORT_H
+#define _LOS_CPPSUPPORT_H
+
+#include "los_compiler.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/**
+ * @ingroup los_cppsupport
+ * @brief System cppsupport initialization.
+ *
+ * @par Description:
+ * This API is used to initialize the cppsupport .
+ * @attention
+ * <ul>
+ * <li>initArrayStart is the start address of .init_array section,
+ * initArrayEnd is the end address of .init_array section.</li>
+ * <li>initArrayStart must be smaller than initArrayEnd,
+ * initArrayStart and initArrayEnd should be 4(32 bits platform) or 8(64 bits platform) bytes alignment.</li>
+ * </ul>
+ *
+ *
+ * @retval 0 always return 0.
+ * @par Dependency:
+ * <ul><li>los_cppsupport.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern INT32 LOS_CppSystemInit(UINTPTR initArrayStart, UINTPTR initArrayEnd);
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_CPPSUPPORT_H */
diff --git a/kernel/liteos_m/components/cpup/BUILD.gn b/kernel/liteos_m/components/cpup/BUILD.gn
index acd1d08..4bf36c9 100644
--- a/kernel/liteos_m/components/cpup/BUILD.gn
+++ b/kernel/liteos_m/components/cpup/BUILD.gn
@@ -1,40 +1,39 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-static_library("cpup") {
-  sources = [ "los_cpup.c" ]
-
-  include_dirs = [
-    "../../kernel/include",
-    "../../kernel/arch/include",
-    "../../utils",
-    "./",
-    "//third_party/bounds_checking_function/include",
-  ]
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("cpup") {
+  sources = [ "los_cpup.c" ]
+
+  include_dirs = [
+    "../../kernel/include",
+    "../../kernel/arch/include",
+    "../../utils",
+    "//third_party/bounds_checking_function/include",
+  ]
+}
diff --git a/kernel/liteos_m/components/cpup/los_cpup.c b/kernel/liteos_m/components/cpup/los_cpup.c
old mode 100755
new mode 100644
index 4456d59..9c0c31b
--- a/kernel/liteos_m/components/cpup/los_cpup.c
+++ b/kernel/liteos_m/components/cpup/los_cpup.c
@@ -33,12 +33,7 @@
 #include "securec.h"
 #include "los_memory.h"
 #include "los_debug.h"
-#include "los_timer.h"
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
+#include "los_tick.h"
 
 #if (LOSCFG_BASE_CORE_CPUP == 1)
 
@@ -61,15 +56,6 @@ LITE_OS_SEC_BSS OsCpupCB  *g_cpup = NULL;
 LITE_OS_SEC_BSS UINT64    g_lastRecordTime;
 LITE_OS_SEC_BSS UINT16    g_hisPos; /* <current Sampling point of historyTime */
 
-
-LITE_OS_SEC_TEXT_MINOR STATIC INLINE UINT64 OsGetCurrentCyclesCount(VOID)
-{
-    UINT32 high = 0;
-    UINT32 low = 0;
-    HalGetCpuCycle(&high, &low);
-    return (((UINT64)high << 32) + low); // 32 means bits of word
-}
-
 /*****************************************************************************
 Function   : OsCpupInit
 Description: initialization of CPUP
@@ -110,7 +96,7 @@ LITE_OS_SEC_TEXT_MINOR VOID OsTskCycleStart(VOID)
 
     taskID = g_losTask.newTask->taskID;
     g_cpup[taskID].cpupID = taskID;
-    g_cpup[taskID].startTime = OsGetCurrentCyclesCount();
+    g_cpup[taskID].startTime = LOS_SysCycleGet();
 
     return;
 }
@@ -135,7 +121,7 @@ LITE_OS_SEC_TEXT_MINOR VOID OsTskCycleEnd(VOID)
         return;
     }
 
-    cpuCycle = OsGetCurrentCyclesCount();
+    cpuCycle = LOS_SysCycleGet();
 
     if (cpuCycle < g_cpup[taskID].startTime) {
         cpuCycle += g_cyclesPerTick;
@@ -163,7 +149,7 @@ LITE_OS_SEC_TEXT_MINOR VOID OsTskCycleEndStart(VOID)
     }
 
     taskID = g_losTask.runTask->taskID;
-    cpuCycle = OsGetCurrentCyclesCount();
+    cpuCycle = LOS_SysCycleGet();
 
     if (g_cpup[taskID].startTime != 0) {
         if (cpuCycle < g_cpup[taskID].startTime) {
@@ -229,7 +215,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_SysCpuUsage(VOID)
     UINT64  cpuCycleAll = 0;
     UINT32  cpupRet = 0;
     UINT16  loopNum;
-    UINTPTR intSave;
+    UINT32 intSave;
 
     if (g_cpupInitFlg == 0) {
         return LOS_ERRNO_CPUP_NO_INIT;
@@ -268,7 +254,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_HistorySysCpuUsage(UINT16 mode)
     UINT16  loopNum;
     UINT16  curPos;
     UINT16  prePos = 0;
-    UINTPTR intSave;
+    UINT32 intSave;
 
     if (g_cpupInitFlg == 0) {
         return LOS_ERRNO_CPUP_NO_INIT;
@@ -315,7 +301,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskCpuUsage(UINT32 taskID)
 {
     UINT64  cpuCycleAll = 0;
     UINT16  loopNum;
-    UINTPTR intSave;
+    UINT32 intSave;
     UINT32  cpupRet = 0;
 
     if (g_cpupInitFlg == 0) {
@@ -364,7 +350,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_HistoryTaskCpuUsage(UINT32 taskID, UINT16 mode
     UINT64  cpuCycleCurTsk = 0;
     UINT16  loopNum, curPos;
     UINT16  prePos = 0;
-    UINTPTR intSave;
+    UINT32 intSave;
     UINT32  cpupRet = 0;
 
     if (g_cpupInitFlg == 0) {
@@ -417,7 +403,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_AllTaskCpuUsage(CPUP_INFO_S *cpupInfo, UINT16
     UINT16  loopNum;
     UINT16  curPos;
     UINT16  prePos = 0;
-    UINTPTR intSave;
+    UINT32 intSave;
     UINT64  cpuCycleAll = 0;
     UINT64  cpuCycleCurTsk = 0;
 
@@ -528,10 +514,3 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E
 }
 
 #endif /* LOSCFG_BASE_CORE_CPUP */
-
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/components/cpup/los_cpup.h b/kernel/liteos_m/components/cpup/los_cpup.h
index b73d67d..ab41884 100644
--- a/kernel/liteos_m/components/cpup/los_cpup.h
+++ b/kernel/liteos_m/components/cpup/los_cpup.h
@@ -179,7 +179,183 @@ extern UINT32 OsCpupInit(VOID);
  */
 extern VOID OsTskCycleEndStart(VOID);
 
+/**
+ * @ingroup los_cpup
+ * Count the CPU usage structures of all tasks.
+ */
+typedef struct tagCpupInfo {
+    UINT16 usStatus;            /**< save the cur task status     */
+    UINT32 uwUsage;             /**< Usage. The value range is [0,1000].   */
+} CPUP_INFO_S;
+
+/**
+ * @ingroup los_monitor
+ * Type of the CPU usage query.
+ */
+typedef enum {
+    SYS_CPU_USAGE = 0,   /* system cpu occupancy rate */
+    TASK_CPU_USAGE,      /* task cpu occupancy rate */
+} CPUP_TYPE_E;
 
+/**
+ * @ingroup los_monitor
+ * Mode of the CPU usage query.
+ */
+typedef enum {
+    CPUP_IN_10S = 0,     /* cpu occupancy rate in 10s */
+    CPUP_IN_1S,          /* cpu occupancy rate in 1s */
+    CPUP_LESS_THAN_1S,   /* cpu occupancy rate less than 1s, if the input mode is none of them, it will be this. */
+} CPUP_MODE_E;
+
+/**
+ * @ingroup los_cpup
+ * @brief Obtain the current CPU usage.
+ *
+ * @par Description:
+ * This API is used to obtain the current CPU usage.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise, error codes will be returned.</li>
+ * <li> The precision of the CPU usage can be adjusted by changing the value of the CPUP_PRECISION macro.</li>
+ * </ul>
+ *
+ * @param None.
+ *
+ * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
+ * @retval #cpup                            [0,1000], current CPU usage, of which the precision is adjustable.
+ * @par Dependency:
+ * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_SysCpuUsage
+ */
+extern UINT32 LOS_SysCpuUsage(VOID);
+
+/**
+ * @ingroup los_cpup
+ * @brief Obtain the historical CPU usage.
+ *
+ * @par Description:
+ * This API is used to obtain the historical CPU usage.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
+ * </ul>
+ *
+ * @param  mode     [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s will be
+ * obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained. Other values
+ * indicate that the CPU usage in the period that is less than 1s will be obtained.
+ *
+ * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
+ * @retval #cpup                            [0,1000], historical CPU usage, of which the precision is adjustable.
+ * @par Dependency:
+ * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_HistoryTaskCpuUsage
+ */
+extern UINT32 LOS_HistorySysCpuUsage(UINT16 mode);
+
+/**
+ * @ingroup los_cpup
+ * @brief Obtain the CPU usage of a specified task.
+ *
+ * @par Description:
+ * This API is used to obtain the CPU usage of a task specified by a passed-in task ID.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
+ * <li>The passed-in task ID must be valid and the task specified by the task ID must be created. Otherwise,
+ * the CPU usage fails to be obtained.</li>
+ * </ul>
+ *
+ * @param taskID   [IN] UINT32. Task ID.
+ *
+ * @retval #OS_ERRNO_CPUP_NO_INIT             0x02001e02: The CPU usage is not initialized.
+ * @retval #OS_ERRNO_CPUP_TSK_ID_INVALID      0x02001e05: The target task ID is invalid.
+ * @retval #OS_ERRNO_CPUP_THREAD_NO_CREATED   0x02001e04: The target thread is not created.
+ * @retval #cpup                              [0,1000], CPU usage of the specified task.
+ * @par Dependency:
+ * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_HistoryTaskCpuUsage
+ */
+extern UINT32 LOS_TaskCpuUsage(UINT32 taskID);
+
+/**
+ * @ingroup los_cpup
+ * @brief  Obtain the historical CPU usage of a specified task.
+ *
+ * @par Description:
+ * This API is used to obtain the historical CPU usage of a task specified by a passed-in task ID.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise,
+ * the CPU usage fails to be obtained.</li>
+ * <li>The passed-in task ID must be valid and the task specified by the task ID must be created. Otherwise,
+ * the CPU usage fails to be obtained.</li>
+ * </ul>
+ *
+ * @param taskID   [IN] UINT32. Task ID.
+ * @param mode     [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s
+ * will be obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained.
+ * Other values indicate that the CPU usage in the period that is less than 1s will be obtained.
+ *
+ * @retval #OS_ERRNO_CPUP_NO_INIT             0x02001e02: The CPU usage is not initialized.
+ * @retval #OS_ERRNO_CPUP_TSK_ID_INVALID      0x02001e05: The target task ID is invalid.
+ * @retval #OS_ERRNO_CPUP_THREAD_NO_CREATED   0x02001e04: The target thread is not created.
+ * @retval #cpup                              [0,1000], CPU usage of the specified task.
+ * @par Dependency:
+ * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_HistorySysCpuUsage
+ */
+extern UINT32 LOS_HistoryTaskCpuUsage(UINT32 taskID, UINT16 mode);
+
+/**
+ * @ingroup los_cpup
+ * @brief Obtain the CPU usage of all tasks.
+ *
+ * @par Description:
+ * This API is used to obtain the CPU usage of all tasks according to maximum number of threads.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
+ * <li>The input parameter pointer must not be NULL, Otherwise, the CPU usage fails to be obtained.</li>
+ * </ul>
+ *
+ * @param cpupInfo    [OUT]Type.   CPUP_INFO_S* Pointer to the task CPUP information structure to be obtained.
+ * @param mode        [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s
+ * will be obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained.
+ * Other values indicate that the CPU usage in the period that is less than 1s will be obtained.
+ *
+ * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
+ * @retval #OS_ERRNO_CPUP_TASK_PTR_NULL     0x02001e01: The input parameter pointer is NULL.
+ * @retval #LOS_OK                          0x00000000: The CPU usage of all tasks is successfully obtained.
+ * @par Dependency:
+ * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_SysCpuUsage
+ */
+extern UINT32 LOS_AllTaskCpuUsage(CPUP_INFO_S *cpupInfo, UINT16 mode);
+
+/**
+ * @ingroup los_monitor
+ * @brief Obtain CPU usage history of certain task.
+ *
+ * @par Description:
+ * This API is used to obtain CPU usage history of certain task.
+ * @attention
+ * <ul>
+ * <li>This API can be called only after the CPU usage is initialized. Otherwise, -1 will be returned.</li>
+ * <li> Only in SYS_CPU_USAGE type, uwTaskID is invalid.</li>
+ * </ul>
+ *
+ * @param type        [IN] cpup type, SYS_CPU_USAGE and TASK_CPU_USAGE
+ * @param mode        [IN] mode,CPUP_IN_10S = usage in 10s,CPUP_IN_1S = usage in last 1s,
+ * CPUP_LESS_THAN_1S = less than 1s, if the input mode is none of them, it will be as CPUP_LESS_THAN_1S.
+ * @param taskID      [IN] task ID, Only in SYS_CPU_USAGE type, taskID is invalid
+ *
+ * @retval #OS_ERROR           -1:CPU usage info obtain failed.
+ * @retval #LOS_OK              0:CPU usage info is successfully obtained.
+ * @par Dependency:
+ * <ul><li>los_monitor.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_CpupUsageMonitor
+ */
+extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 taskID);
 
 #ifdef __cplusplus
 #if __cplusplus
diff --git a/kernel/liteos_m/components/exchook/BUILD.gn b/kernel/liteos_m/components/exchook/BUILD.gn
index 3550c55..15be0ee 100644
--- a/kernel/liteos_m/components/exchook/BUILD.gn
+++ b/kernel/liteos_m/components/exchook/BUILD.gn
@@ -1,42 +1,41 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-static_library("exchook") {
-  sources = [
-    "los_exc_info.c",
-    "los_exchook.c",
-  ]
-  include_dirs = [
-    "../../kernel/arch/include",
-    "../../kernel/include",
-    "../../utils",
-    "./",
-    "//third_party/bounds_checking_function/include",
-  ]
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("exchook") {
+  sources = [
+    "los_exc_info.c",
+    "los_exchook.c",
+  ]
+  include_dirs = [
+    "../../kernel/arch/include",
+    "../../kernel/include",
+    "../../utils",
+    "//third_party/bounds_checking_function/include",
+  ]
+}
diff --git a/kernel/liteos_m/components/exchook/los_exc_info.c b/kernel/liteos_m/components/exchook/los_exc_info.c
index dd412e1..1816b7c 100644
--- a/kernel/liteos_m/components/exchook/los_exc_info.c
+++ b/kernel/liteos_m/components/exchook/los_exc_info.c
@@ -38,12 +38,6 @@
 #include "los_membox.h"
 #include "los_memory.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
-
 #if (LOSCFG_PLATFORM_EXC == 1)
 #define EXC_MSG_ARRAY_INIT_VALUE   0xff
 #define EXC_INT_STATUS_LEN        (OS_NVIC_INT_ENABLE_SIZE + OS_NVIC_INT_PEND_SIZE + \
@@ -300,9 +294,4 @@ VOID OsExcMsgDumpInit(VOID)
 }
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
diff --git a/kernel/liteos_m/components/exchook/los_exchook.c b/kernel/liteos_m/components/exchook/los_exchook.c
old mode 100755
new mode 100644
index 067d6c9..c5171b5
--- a/kernel/liteos_m/components/exchook/los_exchook.c
+++ b/kernel/liteos_m/components/exchook/los_exchook.c
@@ -54,7 +54,7 @@ STATIC VOID DoExcHookInRegOrder(EXC_TYPE excType, struct Node *node)
 
 STATIC VOID DoExcHook(EXC_TYPE excType)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     if (excType >= EXC_TYPE_END) {
         return;
     }
@@ -88,7 +88,7 @@ STATIC struct Node *GetFreeNode(VOID)
 
 UINT32 LOS_RegExcHook(EXC_TYPE excType, ExcHookFn excHookFn)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     struct Node *node = NULL;
     if (excType >= EXC_TYPE_END || excHookFn == NULL) {
         return LOS_ERRNO_SYS_PTR_NULL;
@@ -110,7 +110,7 @@ UINT32 LOS_RegExcHook(EXC_TYPE excType, ExcHookFn excHookFn)
 
 UINT32 LOS_UnRegExcHook(EXC_TYPE excType, ExcHookFn excHookFn)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     struct Node *node = NULL;
     struct Node *preNode = NULL;
     if (excType >= EXC_TYPE_END || excHookFn == NULL) {
diff --git a/kernel/liteos_m/components/exchook/los_exchook.h b/kernel/liteos_m/components/exchook/los_exchook.h
old mode 100755
new mode 100644
diff --git a/kernel/liteos_m/components/fs/BUILD.gn b/kernel/liteos_m/components/fs/BUILD.gn
index 094d2ed..c83773b 100644
--- a/kernel/liteos_m/components/fs/BUILD.gn
+++ b/kernel/liteos_m/components/fs/BUILD.gn
@@ -1,39 +1,60 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-declare_args() {
-  enable_ohos_kernel_liteos_m_fatfs = true
-}
-
-group("fs") {
-  deps = []
-  if (enable_ohos_kernel_liteos_m_fatfs == true) {
-    deps += [ "fatfs:fatfs" ]
-  }
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("fs_operations") {
+  sources = [
+    "./fs.c",
+  ]
+
+  include_dirs = [
+    "../../../kernel/arch/include",
+    "../../../kernel/include",
+    "../../../utils",
+    "../../../kal/posix/include",
+    "./",
+  ]
+
+  deps = [ "//kernel/liteos_m/kal/posix" ]
+}
+
+declare_args() {
+  enable_ohos_kernel_liteos_m_fatfs = true
+  enable_ohos_kernel_liteos_m_littlefs = true
+}
+
+group("fs") {
+  deps = []
+  deps += [ ".:fs_operations" ]
+  if (enable_ohos_kernel_liteos_m_fatfs == true) {
+    deps += [ "fatfs:fatfs" ]
+  }
+  if (enable_ohos_kernel_liteos_m_littlefs == true) {
+    deps += [ "littlefs:littlefs" ]
+  }
+}
diff --git a/kernel/liteos_m/components/fs/fatfs/BUILD.gn b/kernel/liteos_m/components/fs/fatfs/BUILD.gn
index ee0075c..8b516f0 100644
--- a/kernel/liteos_m/components/fs/fatfs/BUILD.gn
+++ b/kernel/liteos_m/components/fs/fatfs/BUILD.gn
@@ -1,47 +1,51 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-static_library("fatfs") {
-  sources = [
-    "fatfs.c",
-    "fs.c",
-  ]
-
-  include_dirs = [
-    "../../../kernel/arch/include",
-    "../../../kernel/include",
-    "../../../utils",
-    "../../../kal/cmsis",
-    "../../../kal",
-    "../../../kal/posix/include",
-    "./",
-    "//third_party/bounds_checking_function/include",
-    "//third_party/FatFs/source/",
-  ]
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("fatfs") {
+  sources = [
+    "//third_party/FatFs/source/diskio.c",
+    "//third_party/FatFs/source/ff.c",
+    "//third_party/FatFs/source/ffsystem.c",
+    "//third_party/FatFs/source/ffunicode.c",
+    "fatfs.c",
+  ]
+
+  include_dirs = [
+    "../",
+    "../../../kernel/arch/include",
+    "../../../kernel/include",
+    "../../../utils",
+    "../../../kal/cmsis",
+    "../../../kal/posix/include",
+    "//third_party/bounds_checking_function/include",
+    "//third_party/FatFs/source/",
+  ]
+
+  deps = [ "//kernel/liteos_m/kal/posix" ]
+}
diff --git a/kernel/liteos_m/components/fs/fatfs/fatfs.c b/kernel/liteos_m/components/fs/fatfs/fatfs.c
old mode 100755
new mode 100644
index 363bc8a..58fad51
--- a/kernel/liteos_m/components/fs/fatfs/fatfs.c
+++ b/kernel/liteos_m/components/fs/fatfs/fatfs.c
@@ -29,22 +29,20 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#define _GNU_SOURCE 1
 #include "ff.h"
-#if FF_USE_EXPAND
-#define _GNU_SOURCE
-#endif
 #include "fatfs.h"
 #include "errno.h"
+#include "stdbool.h"
 #include "limits.h"
 #include "pthread.h"
 #include "time.h"
 #include "securec.h"
 #include "los_compiler.h"
 #include "los_debug.h"
-#include "cmsis_os.h"
+#include "cmsis_os2.h"
+#include "fs_operations.h"
 
-#define FS_SUCCESS            0
-#define FS_FAILURE            (-1)
 /* the max name length of different parts should not bigger than 32 */
 #define FS_DRIVE_NAME_MAX_LEN 32
 
@@ -52,9 +50,9 @@
 #define FAT_MAX_OPEN_DIRS     8
 #endif /* FAT_MAX_OPEN_DIRS */
 
-#ifndef FS_LOCK_TIMEMOUT_SEC
-#define FS_LOCK_TIMEMOUT_SEC  15
-#endif /* FS_LOCK_TIMEMOUT_SEC */
+#ifndef FS_LOCK_TIMEOUT_SEC
+#define FS_LOCK_TIMEOUT_SEC  15
+#endif /* FS_LOCK_TIMEOUT_SEC */
 
 #define PART_NAME   0x0
 #define VOLUME_NAME 0x1
@@ -90,7 +88,7 @@ static int FsLock(void)
         PRINTK("clock gettime err 0x%x!\r\n", errno);
         return errno;
     }
-    absTimeout.tv_sec += FS_LOCK_TIMEMOUT_SEC;
+    absTimeout.tv_sec += FS_LOCK_TIMEOUT_SEC;
     ret = pthread_mutex_timedlock(&g_fsMutex, &absTimeout);
     return ret;
 }
@@ -624,14 +622,21 @@ int fatfs_close(int fd)
     FRESULT res;
     INT32 ret;
 
+    ret = FsLock();
+    if (ret != 0) {
+        errno = ret;
+        return FS_FAILURE;
+    }
+
     if (!IsValidFd(fd)) {
+        FsUnlock();
         errno = EBADF;
         return FS_FAILURE;
     }
 
-    ret = FsLock();
-    if (ret != 0) {
-        errno = ret;
+    if (g_handle[fd].fil.obj.fs == NULL) {
+        FsUnlock();
+        errno = ENOENT;
         return FS_FAILURE;
     }
 
@@ -670,14 +675,22 @@ ssize_t fatfs_read(int fd, void *buf, size_t nbyte)
         errno = EFAULT;
         return FS_FAILURE;
     }
+
+    ret = FsLock();
+    if (ret != 0) {
+        errno = ret;
+        return FS_FAILURE;
+    }
+
     if (!IsValidFd(fd)) {
+        FsUnlock();
         errno = EBADF;
         return FS_FAILURE;
     }
 
-    ret = FsLock();
-    if (ret != 0) {
-        errno = ret;
+    if (g_handle[fd].fil.obj.fs == NULL) {
+        FsUnlock();
+        errno = ENOENT;
         return FS_FAILURE;
     }
 
@@ -703,10 +716,6 @@ ssize_t fatfs_write(int fd, const void *buf, size_t nbyte)
         errno = EFAULT;
         return FS_FAILURE;
     }
-    if (!IsValidFd(fd)) {
-        errno = EBADF;
-        return FS_FAILURE;
-    }
 
     ret = FsLock();
     if (ret != 0) {
@@ -714,15 +723,27 @@ ssize_t fatfs_write(int fd, const void *buf, size_t nbyte)
         return FS_FAILURE;
     }
 
+    if (!IsValidFd(fd)) {
+        errno = EBADF;
+        goto ERROUT;
+    }
+
+    if (g_handle[fd].fil.obj.fs == NULL) {
+        errno = ENOENT;
+        goto ERROUT;
+    }
+
     if (!FsCheckByID(g_handle[fd].fil.obj.fs->id)) {
         errno = EACCES;
         goto ERROUT;
     }
+
     res = f_write(&g_handle[fd].fil, buf, nbyte, &lenWrite);
     if ((res == FR_OK) && (lenWrite == 0) && (nbyte != 0) && (overFlow == FALSE)) {
         overFlow = TRUE;
         PRINTK("FAT write err 0x%x!\r\n", fd);
     }
+
     if ((res != FR_OK) || (nbyte != lenWrite)) {
         errno = FatfsErrno(res);
         goto ERROUT;
@@ -742,17 +763,22 @@ off_t fatfs_lseek(int fd, off_t offset, int whence)
     INT32 ret;
     off_t pos;
 
-    if (!IsValidFd(fd)) {
-        errno = EBADF;
-        return FS_FAILURE;
-    }
-
     ret = FsLock();
     if (ret != 0) {
         errno = ret;
         return FS_FAILURE;
     }
 
+    if (!IsValidFd(fd)) {
+        errno = EBADF;
+        goto ERROUT;
+    }
+
+    if (g_handle[fd].fil.obj.fs == NULL) {
+        errno = ENOENT;
+        goto ERROUT;
+    }
+
     if (whence == SEEK_SET) {
         pos = 0;
     } else if (whence == SEEK_CUR) {
@@ -834,14 +860,22 @@ int fatfs_fstat(int fd, struct stat *buf)
         errno = EFAULT;
         return FS_FAILURE;
     }
+
+    ret = FsLock();
+    if (ret != 0) {
+        errno = ret;
+        return FS_FAILURE;
+    }
+
     if (!IsValidFd(fd)) {
+        FsUnlock();
         errno = EBADF;
         return FS_FAILURE;
     }
 
-    ret = FsLock();
-    if (ret != 0) {
-        errno = ret;
+    if (g_handle[fd].fil.obj.fs == NULL) {
+        FsUnlock();
+        errno = ENOENT;
         return FS_FAILURE;
     }
 
@@ -881,6 +915,7 @@ int fatfs_stat(const char *path, struct stat *buf)
         ret = FS_FAILURE;
         goto OUT;
     }
+
     res = f_stat(path, &fileInfo);
     if (res != FR_OK) {
         PRINTK("FAT stat err 0x%x!\r\n", res);
@@ -916,22 +951,30 @@ int fatfs_fsync(int fd)
     FRESULT res;
     INT32 ret;
 
-    if (!IsValidFd(fd)) {
-        errno = EBADF;
-        return FS_FAILURE;
-    }
-
     ret = FsLock();
     if (ret != 0) {
         errno = ret;
         return FS_FAILURE;
     }
 
+    if (!IsValidFd(fd)) {
+        errno = EBADF;
+        ret = FS_FAILURE;
+        goto OUT;
+    }
+
+    if (g_handle[fd].fil.obj.fs == NULL) {
+        errno = ENOENT;
+        ret = FS_FAILURE;
+        goto OUT;
+    }
+
     if (!FsCheckByID(g_handle[fd].fil.obj.fs->id)) {
         errno = EACCES;
         ret = FS_FAILURE;
         goto OUT;
     }
+
     res = f_sync(&g_handle[fd].fil);
     if (res != FR_OK) {
         errno = FatfsErrno(res);
@@ -1259,8 +1302,8 @@ OUT:
 
 static int do_truncate(int fd, off_t length, UINT count)
 {
-    FRESULT res;
-    INT32 ret = FR_OK;
+    FRESULT res = FR_OK;
+    INT32 ret = FS_SUCCESS;
     DWORD csz;
 
     csz = (DWORD)(g_handle[fd].fil.obj.fs)->csize * SS(g_handle[fd].fil.obj.fs); /* Cluster size */
@@ -1295,11 +1338,6 @@ int fatfs_ftruncate(int fd, off_t length)
     UINT count;
     DWORD fclust;
 
-    if (!IsValidFd(fd)) {
-        errno = EBADF;
-        return FS_FAILURE;
-    }
-
     if ((length < 0) || (length > UINT_MAX)) {
         errno = EINVAL;
         return FS_FAILURE;
@@ -1311,6 +1349,18 @@ int fatfs_ftruncate(int fd, off_t length)
         return FS_FAILURE;
     }
 
+    if (!IsValidFd(fd)) {
+        errno = EBADF;
+        ret = FS_FAILURE;
+        goto OUT;
+    }
+
+    if (g_handle[fd].fil.obj.fs == NULL) {
+        errno = ENOENT;
+        ret = FS_FAILURE;
+        goto OUT;
+    }
+
     if (!FsCheckByID(g_handle[fd].fil.obj.fs->id)) {
         errno = EACCES;
         ret = FS_FAILURE;
@@ -1421,3 +1471,28 @@ OUT:
     FsUnlock();
     return ret;
 }
+
+struct MountOps g_fatfsMnt = {
+    .Mount = fatfs_mount,
+    .Umount = fatfs_umount,
+    .Umount2 = fatfs_umount2,
+    .Statfs = fatfs_statfs,
+};
+
+struct FileOps g_fatfsFops = {
+    .Mkdir = fatfs_mkdir,
+    .Unlink = fatfs_unlink,
+    .Rmdir = fatfs_rmdir,
+    .Opendir = fatfs_opendir,
+    .Readdir = fatfs_readdir,
+    .Closedir = fatfs_closedir,
+    .Open = fatfs_open,
+    .Close = fatfs_close,
+    .Write = fatfs_write,
+    .Read = fatfs_read,
+    .Seek = fatfs_lseek,
+    .Rename = fatfs_rename,
+    .Getattr = fatfs_stat,
+    .Fsync = fatfs_fsync,
+    .Fstat = fatfs_fstat,
+};
\ No newline at end of file
diff --git a/kernel/liteos_m/components/fs/fatfs/fatfs.h b/kernel/liteos_m/components/fs/fatfs/fatfs.h
old mode 100755
new mode 100644
diff --git a/kernel/liteos_m/components/fs/fatfs/fs.c b/kernel/liteos_m/components/fs/fs.c
old mode 100755
new mode 100644
similarity index 53%
rename from kernel/liteos_m/components/fs/fatfs/fs.c
rename to kernel/liteos_m/components/fs/fs.c
index 7435e82..813d5cf
--- a/kernel/liteos_m/components/fs/fatfs/fs.c
+++ b/kernel/liteos_m/components/fs/fs.c
@@ -1,343 +1,552 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "fatfs.h"
-#include "dirent.h"
-#include "errno.h"
-#include "fcntl.h"
-#include "securec.h"
-#include "stdio.h"
-#include "stdlib.h"
-#include "string.h"
-#include "sys/mount.h"
-#include "sys/statfs.h"
-#include "sys/stat.h"
-#include "unistd.h"
-
-#ifdef LOSCFG_NET_LWIP_SACK
-#include "lwip/lwipopts.h"
-#define CONFIG_NSOCKET_DESCRIPTORS  LWIP_CONFIG_NUM_SOCKETS
-#else
-#define CONFIG_NSOCKET_DESCRIPTORS  0
-#endif
-
-#define CONFIG_NFILE_DESCRIPTORS    FAT_MAX_OPEN_FILES /* only for random currently */
-
-#ifdef LOSCFG_RANDOM_DEV
-#include "hks_client.h"
-#define RANDOM_DEV_FD  CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS
-#define RANDOM_DEV_PATH  "/dev/random"
-#endif
-
-#define FREE_AND_SET_NULL(ptr) do { \
-    free(ptr);                      \
-    ptr = NULL;                     \
-} while (0)
-
-#ifdef LOSCFG_RANDOM_DEV
-/**
- * @brief Get canonical form of a given path based on cwd(Current working directory).
- *
- * @param cwd Indicates the current working directory.
- * @param path Indicates the path to be canonicalization.
- * @param buf Indicates the pointer to the buffer where the result will be return.
- * @param bufSize Indicates the size of the buffer.
- * @return Returns the length of the canonical path.
- *
- * @attention if path is an absolute path, cwd is ignored. if cwd if not specified, it is assumed to be root('/').
- *            if the buffer is not big enough the result will be truncated, but the return value will always be the
- *            length of the canonical path.
- */
-static size_t GetCanonicalPath(const char *cwd, const char *path, char *buf, size_t bufSize)
-{
-    size_t offset;
-    if (!path) {
-        path = "";
-    }
-
-    if (!cwd || path[0] == '/') {
-        cwd = "";
-    }
-
-    offset = strlen("///") + 1; // three '/' and one '\0'
-    size_t tmpLen = strlen(cwd) + strlen(path) + offset;
-    char *tmpBuf = (char *)malloc(tmpLen);
-    if (tmpBuf == NULL) {
-        return 0;
-    }
-
-    if (-1 == sprintf_s(tmpBuf, tmpLen, "/%s/%s/", cwd, path)) {
-        free(tmpBuf);
-        return 0;
-    }
-
-    char *p;
-    /* replace /./ to / */
-    offset = strlen("/./") - 1;
-    while ((p = strstr(tmpBuf, "/./")) != NULL) {
-        if (EOK != memmove_s(p, tmpLen - (p - tmpBuf), p + offset, tmpLen - (p - tmpBuf) - offset)) {
-            free(tmpBuf);
-            return 0;
-        }
-    }
-
-    /* replace // to / */
-    while ((p = strstr(tmpBuf, "//")) != NULL) {
-        if (EOK != memmove_s(p, tmpLen - (p - tmpBuf), p + 1, tmpLen - (p - tmpBuf) - 1)) {
-            free(tmpBuf);
-            return 0;
-        }
-    }
-
-    /* handle /../ (e.g., replace /aa/bb/../ to /aa/) */
-    offset = strlen("/../") - 1;
-    while ((p = strstr(tmpBuf, "/../")) != NULL) {
-        char *start = p;
-        while (start > tmpBuf && *(start - 1) != '/') {
-            --start;
-        }
-        if (EOK != memmove_s(start, tmpLen - (start - tmpBuf), p + offset, tmpLen - (p - tmpBuf) - offset)) {
-            free(tmpBuf);
-            return 0;
-        }
-    }
-
-    size_t totalLen = strlen(tmpBuf);
-    /* strip the last / */
-    if (totalLen > 1 && tmpBuf[totalLen - 1] == '/') {
-        tmpBuf[--totalLen] = 0;
-    }
-
-    if (!buf || bufSize == 0) {
-        free(tmpBuf);
-        return totalLen;
-    }
-
-    if (EOK != memcpy_s(buf, bufSize, tmpBuf, (((totalLen + 1) > bufSize) ? bufSize : (totalLen + 1)))) {
-        free(tmpBuf);
-        return 0;
-    }
-
-    buf[bufSize - 1] = 0;
-    free(tmpBuf);
-    return totalLen;
-}
-#endif
-
-int mount(const char *source, const char *target,
-          const char *filesystemtype, unsigned long mountflags,
-          const void *data)
-{
-    return fatfs_mount(source, target, filesystemtype, mountflags, data);
-}
-
-int umount(const char *target)
-{
-    return fatfs_umount(target);
-}
-
-int umount2(const char *target, int flag)
-{
-    return fatfs_umount2(target, flag);
-}
-
-int open(const char *path, int oflag, ...)
-{
-#ifdef LOSCFG_RANDOM_DEV
-    unsigned flags = O_RDONLY | O_WRONLY | O_RDWR | O_APPEND | O_CREAT | O_LARGEFILE | O_TRUNC | O_EXCL | O_DIRECTORY;
-    if ((unsigned)oflag & ~flags) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    size_t pathLen = strlen(path) + 1;
-    char *canonicalPath = (char *)malloc(pathLen);
-    if (!canonicalPath) {
-        errno = ENOMEM;
-        return -1;
-    }
-    if (GetCanonicalPath(NULL, path, canonicalPath, pathLen) == 0) {
-        FREE_AND_SET_NULL(canonicalPath);
-        errno = ENOMEM;
-        return -1;
-    }
-
-    if (strcmp(canonicalPath, RANDOM_DEV_PATH) == 0) {
-        FREE_AND_SET_NULL(canonicalPath);
-        if ((O_ACCMODE & (unsigned)oflag) != O_RDONLY) {
-            errno = EPERM;
-            return -1;
-        }
-        if ((unsigned)oflag & O_DIRECTORY) {
-            errno = ENOTDIR;
-            return -1;
-        }
-        return RANDOM_DEV_FD;
-    }
-    if (strcmp(canonicalPath, "/") == 0 || strcmp(canonicalPath, "/dev") == 0) {
-        FREE_AND_SET_NULL(canonicalPath);
-        if ((unsigned)oflag & O_DIRECTORY) {
-            errno = EPERM;
-            return -1;
-        }
-        errno = EISDIR;
-        return -1;
-    }
-    FREE_AND_SET_NULL(canonicalPath);
-#endif
-    return fatfs_open(path, oflag);
-}
-
-int close(int fd)
-{
-#ifdef LOSCFG_RANDOM_DEV
-    if (fd == RANDOM_DEV_FD) {
-        return 0;
-    }
-#endif
-#ifdef LOSCFG_NET_LWIP_SACK
-    if (fd >= CONFIG_NFILE_DESCRIPTORS && fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
-        return closesocket(fd);
-    }
-#endif
-    return fatfs_close(fd);
-}
-
-ssize_t read(int fd, void *buf, size_t nbyte)
-{
-#ifdef LOSCFG_RANDOM_DEV
-    if (fd == RANDOM_DEV_FD) {
-        if (nbyte == 0) {
-            return 0;
-        }
-        if (buf == NULL) {
-            errno = EINVAL;
-            return -1;
-        }
-        if (nbyte > 1024) {
-            nbyte = 1024; /* hks_generate_random: random_size must <= 1024 */
-        }
-        struct hks_blob key = {HKS_BLOB_TYPE_RAW, (uint8_t *)buf, nbyte};
-        if (hks_generate_random(&key) != 0) {
-            errno = EIO;
-            return -1;
-        }
-        return (ssize_t)nbyte;
-    }
-#endif
-#ifdef LOSCFG_NET_LWIP_SACK
-    if (fd >= CONFIG_NFILE_DESCRIPTORS && fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
-        return recv(fd, buf, nbyte, 0);
-    }
-#endif
-    return fatfs_read(fd, buf, nbyte);
-}
-
-ssize_t write(int fd, const void *buf, size_t nbyte)
-{
-#ifdef LOSCFG_RANDOM_DEV
-    if (fd == RANDOM_DEV_FD) {
-        errno = EBADF; /* "/dev/random" is readonly */
-        return -1;
-    }
-#endif
-#ifdef LOSCFG_NET_LWIP_SACK
-    if (fd >= CONFIG_NFILE_DESCRIPTORS && fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
-        return send(fd, buf, nbyte, 0);
-    }
-#endif
-    return fatfs_write(fd, buf, nbyte);
-}
-
-off_t lseek(int fd, off_t offset, int whence)
-{
-    return fatfs_lseek(fd, offset, whence);
-}
-
-int unlink(const char *path)
-{
-    return fatfs_unlink(path);
-}
-
-int fstat(int fd, struct stat *buf)
-{
-    return fatfs_fstat(fd, buf);
-}
-
-int stat(const char *path, struct stat *buf)
-{
-    return fatfs_stat(path, buf);
-}
-
-int fsync(int fd)
-{
-    return fatfs_fsync(fd);
-}
-
-int mkdir(const char *path, mode_t mode)
-{
-    return fatfs_mkdir(path, mode);
-}
-
-DIR *opendir(const char *dirName)
-{
-    return fatfs_opendir(dirName);
-}
-
-struct dirent *readdir(DIR *dir)
-{
-    return fatfs_readdir(dir);
-}
-
-int closedir(DIR *dir)
-{
-    return fatfs_closedir(dir);
-}
-
-int rmdir(const char *path)
-{
-    return fatfs_rmdir(path);
-}
-
-int rename(const char *oldName, const char *newName)
-{
-    return fatfs_rename(oldName, newName);
-}
-
-int statfs(const char *path, struct statfs *buf)
-{
-    return fatfs_statfs(path, buf);
-}
-
-int ftruncate(int fd, off_t length)
-{
-    return fatfs_ftruncate(fd, length);
-}
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "fs_operations.h"
+#include "los_config.h"
+#ifdef LOSCFG_SUPPORT_FATFS
+#include "fatfs.h"
+#endif
+#include "dirent.h"
+#include "errno.h"
+#include "fcntl.h"
+#include "securec.h"
+#include "stdio.h"
+#include "stdlib.h"
+#include "string.h"
+#include "sys/mount.h"
+#include "sys/statfs.h"
+#include "sys/stat.h"
+#include "unistd.h"
+
+struct FsMap g_fsmap[MAX_FILESYSTEM_LEN] = {0};
+struct FsMap *g_fs = NULL;
+
+#ifdef LOSCFG_NET_LWIP_SACK
+#include "lwip/lwipopts.h"
+#include "lwip/sockets.h"
+#define CONFIG_NSOCKET_DESCRIPTORS  LWIP_CONFIG_NUM_SOCKETS
+#else
+#define CONFIG_NSOCKET_DESCRIPTORS  0
+#endif
+
+#define CONFIG_NFILE_DESCRIPTORS    FAT_MAX_OPEN_FILES /* only for random currently */
+
+#ifdef LOSCFG_RANDOM_DEV
+#include "hks_client.h"
+#define RANDOM_DEV_FD  CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS
+#define RANDOM_DEV_PATH  "/dev/random"
+#endif
+
+#define FREE_AND_SET_NULL(ptr) do { \
+    free(ptr);                      \
+    ptr = NULL;                     \
+} while (0)
+
+#ifdef LOSCFG_RANDOM_DEV
+/**
+ * @brief Get canonical form of a given path based on cwd(Current working directory).
+ *
+ * @param cwd Indicates the current working directory.
+ * @param path Indicates the path to be canonicalization.
+ * @param buf Indicates the pointer to the buffer where the result will be return.
+ * @param bufSize Indicates the size of the buffer.
+ * @return Returns the length of the canonical path.
+ *
+ * @attention if path is an absolute path, cwd is ignored. if cwd if not specified, it is assumed to be root('/').
+ *            if the buffer is not big enough the result will be truncated, but the return value will always be the
+ *            length of the canonical path.
+ */
+static size_t GetCanonicalPath(const char *cwd, const char *path, char *buf, size_t bufSize)
+{
+    size_t offset;
+    if (!path) {
+        path = "";
+    }
+
+    if (!cwd || path[0] == '/') {
+        cwd = "";
+    }
+
+    offset = strlen("///") + 1; // three '/' and one '\0'
+    size_t tmpLen = strlen(cwd) + strlen(path) + offset;
+    char *tmpBuf = (char *)malloc(tmpLen);
+    if (tmpBuf == NULL) {
+        return FS_SUCCESS;
+    }
+
+    if (-1 == sprintf_s(tmpBuf, tmpLen, "/%s/%s/", cwd, path)) {
+        free(tmpBuf);
+        return FS_SUCCESS;
+    }
+
+    char *p;
+    /* replace /./ to / */
+    offset = strlen("/./") - 1;
+    while ((p = strstr(tmpBuf, "/./")) != NULL) {
+        if (EOK != memmove_s(p, tmpLen - (p - tmpBuf), p + offset, tmpLen - (p - tmpBuf) - offset)) {
+            free(tmpBuf);
+            return FS_SUCCESS;
+        }
+    }
+
+    /* replace // to / */
+    while ((p = strstr(tmpBuf, "//")) != NULL) {
+        if (EOK != memmove_s(p, tmpLen - (p - tmpBuf), p + 1, tmpLen - (p - tmpBuf) - 1)) {
+            free(tmpBuf);
+            return FS_SUCCESS;
+        }
+    }
+
+    /* handle /../ (e.g., replace /aa/bb/../ to /aa/) */
+    offset = strlen("/../") - 1;
+    while ((p = strstr(tmpBuf, "/../")) != NULL) {
+        char *start = p;
+        while (start > tmpBuf && *(start - 1) != '/') {
+            --start;
+        }
+        if (EOK != memmove_s(start, tmpLen - (start - tmpBuf), p + offset, tmpLen - (p - tmpBuf) - offset)) {
+            free(tmpBuf);
+            return FS_SUCCESS;
+        }
+    }
+
+    size_t totalLen = strlen(tmpBuf);
+    /* strip the last / */
+    if (totalLen > 1 && tmpBuf[totalLen - 1] == '/') {
+        tmpBuf[--totalLen] = 0;
+    }
+
+    if (!buf || bufSize == 0) {
+        free(tmpBuf);
+        return totalLen;
+    }
+
+    if (EOK != memcpy_s(buf, bufSize, tmpBuf, (((totalLen + 1) > bufSize) ? bufSize : (totalLen + 1)))) {
+        free(tmpBuf);
+        return FS_SUCCESS;
+    }
+
+    buf[bufSize - 1] = 0;
+    free(tmpBuf);
+    return totalLen;
+}
+#endif
+
+static void InitMountInfo(void)
+{
+#if (LOSCFG_SUPPORT_FATFS == 1)
+    extern struct MountOps g_fatfsMnt;
+    extern struct FileOps g_fatfsFops;
+    g_fsmap[0].fileSystemtype = strdup("fat");
+    g_fsmap[0].fsMops = &g_fatfsMnt;
+    g_fsmap[0].fsFops = &g_fatfsFops;
+#endif
+#if (LOSCFG_SUPPORT_LITTLEFS == 1)
+    extern struct MountOps g_lfsMnt;
+    extern struct FileOps g_lfsFops;
+    g_fsmap[1].fileSystemtype = strdup("littlefs");
+    g_fsmap[1].fsMops = &g_lfsMnt;
+    g_fsmap[1].fsFops = &g_lfsFops;
+#endif
+}
+
+static struct FsMap *MountFindfs(const char *fileSystemtype)
+{
+    struct FsMap *m = NULL;
+
+    for (int i = 0; i < MAX_FILESYSTEM_LEN; i++) {
+        m = &(g_fsmap[i]);
+        if (m->fileSystemtype && strcmp(fileSystemtype, m->fileSystemtype) == 0) {
+            return m;
+        }
+    }
+
+    return NULL;
+}
+
+int mount(const char *source, const char *target,
+          const char *filesystemtype, unsigned long mountflags,
+          const void *data)
+{
+    static int initFlag = 0;
+
+    if (initFlag == 0) {
+        InitMountInfo();
+        initFlag = 1;
+    }
+
+    g_fs = MountFindfs(filesystemtype);
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+
+    if (g_fs->fsMops == NULL || g_fs->fsMops->Mount == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+
+    return g_fs->fsMops->Mount(source, target, filesystemtype, mountflags, data);
+}
+
+int umount(const char *target)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsMops == NULL || g_fs->fsMops->Umount == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsMops->Umount(target);
+}
+
+int umount2(const char *target, int flag)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsMops == NULL || g_fs->fsMops->Umount2 == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsMops->Umount2(target, flag);
+}
+
+int open(const char *path, int oflag, ...)
+{
+#ifdef LOSCFG_RANDOM_DEV
+    unsigned flags = O_RDONLY | O_WRONLY | O_RDWR | O_APPEND | O_CREAT | O_LARGEFILE | O_TRUNC | O_EXCL | O_DIRECTORY;
+    if ((unsigned)oflag & ~flags) {
+        errno = EINVAL;
+        return FS_FAILURE;
+    }
+
+    size_t pathLen = strlen(path) + 1;
+    char *canonicalPath = (char *)malloc(pathLen);
+    if (!canonicalPath) {
+        errno = ENOMEM;
+        return FS_FAILURE;
+    }
+    if (GetCanonicalPath(NULL, path, canonicalPath, pathLen) == 0) {
+        FREE_AND_SET_NULL(canonicalPath);
+        errno = ENOMEM;
+        return FS_FAILURE;
+    }
+
+    if (strcmp(canonicalPath, RANDOM_DEV_PATH) == 0) {
+        FREE_AND_SET_NULL(canonicalPath);
+        if ((O_ACCMODE & (unsigned)oflag) != O_RDONLY) {
+            errno = EPERM;
+            return FS_FAILURE;
+        }
+        if ((unsigned)oflag & O_DIRECTORY) {
+            errno = ENOTDIR;
+            return FS_FAILURE;
+        }
+        return RANDOM_DEV_FD;
+    }
+    if (strcmp(canonicalPath, "/") == 0 || strcmp(canonicalPath, "/dev") == 0) {
+        FREE_AND_SET_NULL(canonicalPath);
+        if ((unsigned)oflag & O_DIRECTORY) {
+            errno = EPERM;
+            return FS_FAILURE;
+        }
+        errno = EISDIR;
+        return FS_FAILURE;
+    }
+    FREE_AND_SET_NULL(canonicalPath);
+#endif
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Open == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Open(path, oflag);
+}
+
+int close(int fd)
+{
+#ifdef LOSCFG_RANDOM_DEV
+    if (fd == RANDOM_DEV_FD) {
+        return FS_SUCCESS;
+    }
+#endif
+#ifdef LOSCFG_NET_LWIP_SACK
+    if (fd >= CONFIG_NFILE_DESCRIPTORS && fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
+        return closesocket(fd);
+    }
+#endif
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Close == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Close(fd);
+}
+
+ssize_t read(int fd, void *buf, size_t nbyte)
+{
+#ifdef LOSCFG_RANDOM_DEV
+    if (fd == RANDOM_DEV_FD) {
+        if (nbyte == 0) {
+            return FS_SUCCESS;
+        }
+        if (buf == NULL) {
+            errno = EINVAL;
+            return FS_FAILURE;
+        }
+        if (nbyte > 1024) {
+            nbyte = 1024; /* hks_generate_random: random_size must <= 1024 */
+        }
+        struct hks_blob key = {HKS_BLOB_TYPE_RAW, (uint8_t *)buf, nbyte};
+        if (hks_generate_random(&key) != 0) {
+            errno = EIO;
+            return FS_FAILURE;
+        }
+        return (ssize_t)nbyte;
+    }
+#endif
+#ifdef LOSCFG_NET_LWIP_SACK
+    if (fd >= CONFIG_NFILE_DESCRIPTORS && fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
+        return recv(fd, buf, nbyte, 0);
+    }
+#endif
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Read == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Read(fd, buf, nbyte);
+}
+
+ssize_t write(int fd, const void *buf, size_t nbyte)
+{
+#ifdef LOSCFG_RANDOM_DEV
+    if (fd == RANDOM_DEV_FD) {
+        errno = EBADF; /* "/dev/random" is readonly */
+        return FS_FAILURE;
+    }
+#endif
+#ifdef LOSCFG_NET_LWIP_SACK
+    if (fd >= CONFIG_NFILE_DESCRIPTORS && fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
+        return send(fd, buf, nbyte, 0);
+    }
+#endif
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Write == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Write(fd, buf, nbyte);
+}
+
+off_t lseek(int fd, off_t offset, int whence)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Seek == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Seek(fd, offset, whence);
+}
+
+int unlink(const char *path)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Unlink == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Unlink(path);
+}
+
+int fstat(int fd, struct stat *buf)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Fstat == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Fstat(fd, buf);
+}
+
+int stat(const char *path, struct stat *buf)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Getattr == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Getattr(path, buf);
+}
+
+int fsync(int fd)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Fsync == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Fsync(fd);
+}
+
+int mkdir(const char *path, mode_t mode)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Mkdir == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Mkdir(path, mode);
+}
+
+DIR *opendir(const char *dirName)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return NULL;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Opendir == NULL) {
+        errno = ENOSYS;
+        return NULL;
+    }
+    return g_fs->fsFops->Opendir(dirName);
+}
+
+struct dirent *readdir(DIR *dir)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return NULL;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Readdir == NULL) {
+        errno = ENOSYS;
+        return NULL;
+    }
+    return g_fs->fsFops->Readdir(dir);
+}
+
+int closedir(DIR *dir)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Closedir == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Closedir(dir);
+}
+
+int rmdir(const char *path)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Rmdir == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Rmdir(path);
+}
+
+int rename(const char *oldName, const char *newName)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Rename == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Rename(oldName, newName);
+}
+
+int statfs(const char *path, struct statfs *buf)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsMops == NULL || g_fs->fsMops->Statfs == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsMops->Statfs(path, buf);
+}
+
+int ftruncate(int fd, off_t length)
+{
+    if (g_fs == NULL) {
+        errno = ENODEV;
+        return FS_FAILURE;
+    }
+    if (g_fs->fsFops == NULL || g_fs->fsFops->Ftruncate == NULL) {
+        errno = ENOSYS;
+        return FS_FAILURE;
+    }
+    return g_fs->fsFops->Ftruncate(fd, length);
+}
diff --git a/kernel/liteos_m/components/fs/fs_operations.h b/kernel/liteos_m/components/fs/fs_operations.h
new file mode 100644
index 0000000..e22be28
--- /dev/null
+++ b/kernel/liteos_m/components/fs/fs_operations.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _FS_OPERATIONS_H_
+#define _FS_OPERATIONS_H_
+
+#include "fcntl.h"
+#include "dirent.h"
+#include "unistd.h"
+#include "sys/mount.h"
+#include "sys/stat.h"
+#include "sys/statfs.h"
+
+#define FS_SUCCESS            0
+#define FS_FAILURE            (-1)
+#define MAX_FILESYSTEM_LEN 2
+
+struct MountOps {
+    int (*Mount)(const char *source, const char *target, const char *filesystemtype, unsigned long mountflags,
+        const void *data);
+    int (*Umount)(const char* target);
+    int (*Umount2)(const char* target, int flag);
+    int (*Statfs)(const char *path, struct statfs *buf);
+};
+
+struct FsMap {
+    const char *fileSystemtype;
+    const struct MountOps *fsMops;
+    const struct FileOps *fsFops;
+};
+
+struct FileOps {
+    int (*Open)(const char *path, int openFlag, ...);
+    int (*Close)(int fd);
+    int (*Unlink)(const char *fileName);
+    int (*Rmdir)(const char *dirName);
+    int (*Mkdir)(const char *dirName, mode_t mode);
+    struct dirent *(*Readdir)(DIR *dir);
+    DIR *(*Opendir)(const char *dirName);
+    int (*Closedir)(DIR *dir);
+    int (*Read)(int fd, void *buf, size_t len);
+    int (*Write)(int fd, const void *buf, size_t len);
+    off_t (*Seek)(int fd, off_t offset, int whence);
+    int (*Getattr)(const char *path, struct stat *buf);
+    int (*Rename)(const char *oldName, const char *newName);
+    int (*Fsync)(int fd);
+    int (*Fstat)(int fd, struct stat *buf);
+    int (*Stat)(const char *path, struct stat *buf);
+    int (*Ftruncate)(int fd, off_t length);
+};
+
+#endif /* _FS_OPERATIONS_H_ */
diff --git a/kernel/liteos_m/components/fs/littlefs/BUILD.gn b/kernel/liteos_m/components/fs/littlefs/BUILD.gn
new file mode 100644
index 0000000..9338d23
--- /dev/null
+++ b/kernel/liteos_m/components/fs/littlefs/BUILD.gn
@@ -0,0 +1,49 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("littlefs") {
+  sources = [
+    "lfs_api.c",
+    "//third_party/littlefs/lfs.c",
+    "//third_party/littlefs/lfs_util.c",
+  ]
+
+  include_dirs = [
+    "../../../kernel/arch/include",
+    "../../../kernel/include",
+    "../../../utils",
+    "../../../kal/cmsis",
+    "../../../kal/posix/include",
+    "./",
+    "../",
+    "//third_party/littlefs",
+  ]
+
+  deps = [ "//kernel/liteos_m/kal/posix" ]
+}
diff --git a/kernel/liteos_m/components/fs/littlefs/lfs_api.c b/kernel/liteos_m/components/fs/littlefs/lfs_api.c
new file mode 100644
index 0000000..9250ade
--- /dev/null
+++ b/kernel/liteos_m/components/fs/littlefs/lfs_api.c
@@ -0,0 +1,774 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define _GNU_SOURCE 1
+#include "lfs_api.h"
+#include "los_config.h"
+#include "securec.h"
+
+lfs_t g_lfs;
+FileDirInfo g_lfsDir[LFS_MAX_OPEN_DIRS] = {0};
+
+struct FileOpInfo g_fsOp[LOSCFG_LFS_MAX_MOUNT_SIZE] = {0};
+static LittleFsHandleStruct g_handle[LITTLE_FS_MAX_OPEN_FILES] = {0};
+struct dirent g_nameValue;
+static pthread_mutex_t g_FslocalMutex = PTHREAD_MUTEX_INITIALIZER;
+static const char *g_littlefsMntName[LOSCFG_LFS_MAX_MOUNT_SIZE] = {"/a","/b","/c"};
+
+LittleFsHandleStruct *LfsAllocFd(const char *fileName, int *fd)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LITTLE_FS_MAX_OPEN_FILES; i++) {
+        if (g_handle[i].useFlag == 0) {
+            *fd = i;
+            g_handle[i].useFlag = 1;
+            g_handle[i].pathName = strdup(fileName);
+            pthread_mutex_unlock(&g_FslocalMutex);
+            return &(g_handle[i]);
+        }
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+    *fd = INVALID_FD;
+    return NULL;
+}
+
+static void LfsFreeFd(int fd)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    g_handle[fd].useFlag = 0;
+    if (g_handle[fd].pathName != NULL) {
+        free((void *)g_handle[fd].pathName);
+        g_handle[fd].pathName = NULL;
+    }
+
+    if (g_handle[fd].lfsHandle != NULL) {
+        g_handle[fd].lfsHandle = NULL;
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+}
+
+BOOL CheckFileIsOpen(const char *fileName)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LITTLE_FS_MAX_OPEN_FILES; i++) {
+        if (g_handle[i].useFlag == 1) {
+            if (strcmp(g_handle[i].pathName, fileName) == 0) {
+                pthread_mutex_unlock(&g_FslocalMutex);
+                return TRUE;
+            }
+        }
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return FALSE;
+}
+
+static BOOL LfsFdIsValid(int fd)
+{
+    if (fd >= LITTLE_FS_MAX_OPEN_FILES || fd < 0) {
+        return FALSE;
+    }
+    if (g_handle[fd].lfsHandle == NULL) {
+        return FALSE;
+    }
+    return TRUE;
+}
+
+FileDirInfo *GetFreeDir(const char *dirName)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LFS_MAX_OPEN_DIRS; i++) {
+        if (g_lfsDir[i].useFlag == 0) {
+            g_lfsDir[i].useFlag = 1;
+            g_lfsDir[i].dirName = strdup(dirName);
+            pthread_mutex_unlock(&g_FslocalMutex);
+            return &(g_lfsDir[i]);
+        }
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return NULL;
+}
+
+void FreeDirInfo(const char *dirName)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LFS_MAX_OPEN_DIRS; i++) {
+        if (g_lfsDir[i].useFlag == 1 && strcmp(g_lfsDir[i].dirName, dirName) == 0) {
+            g_lfsDir[i].useFlag = 0;
+            if (g_lfsDir[i].dirName) {
+                free(g_lfsDir[i].dirName);
+                g_lfsDir[i].dirName = NULL;
+            }
+            pthread_mutex_unlock(&g_FslocalMutex);
+        }
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+}
+
+BOOL CheckDirIsOpen(const char *dirName)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LFS_MAX_OPEN_DIRS; i++) {
+        if (g_lfsDir[i].useFlag == 1) {
+            if (strcmp(g_lfsDir[i].dirName, dirName) == 0) {
+                pthread_mutex_unlock(&g_FslocalMutex);
+                return TRUE;
+            }
+        }
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return FALSE;
+}
+
+int GetFirstLevelPathLen(const char *pathName)
+{
+    int len = 1;
+    for (int i = 1; i < strlen(pathName) + 1; i++) {
+        if (pathName[i] == '/') {
+            break;
+        }
+        len++;
+    }
+
+    return len;
+}
+
+BOOL CheckPathIsMounted(const char *pathName, struct FileOpInfo **fileOpInfo)
+{
+    char tmpName[LITTLEFS_MAX_LFN_LEN] = {0};
+    int len = GetFirstLevelPathLen(pathName);
+
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LOSCFG_LFS_MAX_MOUNT_SIZE; i++) {
+        if (g_fsOp[i].useFlag == 1) {
+            (void)strncpy_s(tmpName, LITTLEFS_MAX_LFN_LEN, pathName, len);
+            if (strcmp(tmpName, g_fsOp[i].dirName) == 0) {
+                *fileOpInfo = &(g_fsOp[i]);
+                pthread_mutex_unlock(&g_FslocalMutex);
+                return TRUE;
+            }
+        }
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return FALSE;
+}
+
+struct FileOpInfo *AllocMountRes(const char* target, const struct FileOps *fileOps)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LOSCFG_LFS_MAX_MOUNT_SIZE; i++) {
+        if (g_fsOp[i].useFlag == 0 && strcmp(target, g_littlefsMntName[i]) == 0) {
+            g_fsOp[i].useFlag = 1;
+            g_fsOp[i].fsVops = fileOps;
+            g_fsOp[i].dirName = strdup(target);
+            pthread_mutex_unlock(&g_FslocalMutex);
+            return &(g_fsOp[i]);
+        }
+    }
+
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return NULL;
+}
+
+int SetDefaultMountPath(int pathNameIndex, const char* target)
+{
+    if (pathNameIndex >= LOSCFG_LFS_MAX_MOUNT_SIZE) {
+        return VFS_ERROR;
+    }
+
+    pthread_mutex_lock(&g_FslocalMutex);
+    g_littlefsMntName[pathNameIndex] = strdup(target);
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return VFS_OK;
+}
+
+struct FileOpInfo *GetMountRes(const char *target, int *mountIndex)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LOSCFG_LFS_MAX_MOUNT_SIZE; i++) {
+        if (g_fsOp[i].useFlag == 1) {
+            if (g_fsOp[i].dirName && strcmp(target, g_fsOp[i].dirName) == 0) {
+                *mountIndex = i;
+                pthread_mutex_unlock(&g_FslocalMutex);
+                return &(g_fsOp[i]);
+            }
+        }
+    }
+
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return NULL;
+}
+
+int FreeMountResByIndex(int mountIndex)
+{
+    if (mountIndex < 0 || mountIndex >= LOSCFG_LFS_MAX_MOUNT_SIZE) {
+        return VFS_ERROR;
+    }
+
+    pthread_mutex_lock(&g_FslocalMutex);
+    if (g_fsOp[mountIndex].useFlag == 1 && g_fsOp[mountIndex].dirName != NULL) {
+        g_fsOp[mountIndex].useFlag = 0;
+        free(g_fsOp[mountIndex].dirName);
+        g_fsOp[mountIndex].dirName = NULL;
+    }
+    pthread_mutex_unlock(&g_FslocalMutex);
+
+    return VFS_OK;
+}
+
+int FreeMountRes(const char *target)
+{
+    pthread_mutex_lock(&g_FslocalMutex);
+    for (int i = 0; i < LOSCFG_LFS_MAX_MOUNT_SIZE; i++) {
+        if (g_fsOp[i].useFlag == 1) {
+            if (g_fsOp[i].dirName && strcmp(target, g_fsOp[i].dirName) == 0) {
+                g_fsOp[i].useFlag = 0;
+                free(g_fsOp[i].dirName);
+                g_fsOp[i].dirName = NULL;
+                pthread_mutex_unlock(&g_FslocalMutex);
+                return VFS_OK;
+            }
+        }
+    }
+
+    pthread_mutex_unlock(&g_FslocalMutex);
+    return VFS_ERROR;
+}
+
+static int ConvertFlagToLfsOpenFlag (int oflags)
+{
+    int lfsOpenFlag = 0;
+
+    if (oflags & O_CREAT) {
+        lfsOpenFlag |= LFS_O_CREAT;
+    }
+
+    if (oflags & O_EXCL) {
+        lfsOpenFlag |= LFS_O_EXCL;
+    }
+
+    if (oflags & O_TRUNC) {
+        lfsOpenFlag |= LFS_O_TRUNC;
+    }
+
+    if (oflags & O_APPEND) {
+        lfsOpenFlag |= LFS_O_APPEND;
+    }
+
+    if (oflags & O_RDWR) {
+        lfsOpenFlag |= LFS_O_RDWR;
+    }
+
+    if (oflags & O_WRONLY) {
+        lfsOpenFlag |= LFS_O_WRONLY;
+    }
+
+    if (oflags & O_RDONLY) {
+        lfsOpenFlag |= LFS_O_RDONLY;
+    }
+
+    return lfsOpenFlag;
+}
+
+static int LittlefsErrno(int result)
+{
+    return (result < 0) ? -result : result;
+}
+
+const struct MountOps g_lfsMnt = {
+    .Mount = LfsMount,
+    .Umount = LfsUmount,
+};
+
+const struct FileOps g_lfsFops = {
+    .Mkdir = LfsMkdir,
+    .Unlink = LfsUnlink,
+    .Rmdir = LfsRmdir,
+    .Opendir = LfsOpendir,
+    .Readdir = LfsReaddir,
+    .Closedir = LfsClosedir,
+    .Open = LfsOpen,
+    .Close = LfsClose,
+    .Write = LfsWrite,
+    .Read = LfsRead,
+    .Seek = LfsSeek,
+    .Rename = LfsRename,
+    .Getattr = LfsStat,
+    .Fsync = LfsFsync,
+};
+
+int LfsMount(const char *source, const char *target, const char *fileSystemType, unsigned long mountflags,
+    const void *data)
+{
+    int ret;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (target == NULL || fileSystemType == NULL || data == NULL) {
+        errno = EFAULT;
+        ret = VFS_ERROR;
+        goto errout;
+    }
+
+    if (strcmp(fileSystemType, "littlefs") != 0) {
+        errno = ENODEV;
+        ret = VFS_ERROR;
+        goto errout;
+    }
+
+    if (CheckPathIsMounted(target, &fileOpInfo)) {
+        errno = EBUSY;
+        ret = VFS_ERROR;
+        goto errout;
+    }
+
+    // select free mount resource
+    fileOpInfo = AllocMountRes(target, &g_lfsFops);
+    if (fileOpInfo == NULL) {
+        errno = ENODEV;
+        ret = VFS_ERROR;
+        goto errout;
+    }
+
+    ret = lfs_mount(&(fileOpInfo->lfsInfo), (struct lfs_config*)data);
+    if (ret != 0) {
+        ret = lfs_format(&(fileOpInfo->lfsInfo), (struct lfs_config*)data);
+        if (ret == 0) {
+            ret = lfs_mount(&(fileOpInfo->lfsInfo), (struct lfs_config*)data);
+        }
+    }
+
+    if (ret != 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+
+errout:
+    return ret;
+}
+
+int LfsUmount(const char *target)
+{
+    int ret;
+    int mountIndex = -1;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (target == NULL) {
+        errno = EFAULT;
+        return VFS_ERROR;
+    }
+
+    fileOpInfo = GetMountRes(target, &mountIndex);
+    if (fileOpInfo == NULL) {
+        errno = ENOENT;
+        return VFS_ERROR;
+    }
+
+    ret = lfs_unmount(&(fileOpInfo->lfsInfo));
+    if (ret != 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+
+    (void)FreeMountResByIndex(mountIndex);
+    return ret;
+}
+
+int LfsUnlink(const char *fileName)
+{
+    int ret;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (fileName == NULL) {
+        errno = EFAULT;
+        return VFS_ERROR;
+    }
+
+    if (CheckPathIsMounted(fileName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        errno = ENOENT;
+        return VFS_ERROR;
+    }
+
+    ret = lfs_remove(&(fileOpInfo->lfsInfo), fileName);
+    if (ret != 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+
+    return ret;
+}
+
+int LfsMkdir(const char *dirName, mode_t mode)
+{
+    int ret;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (dirName == NULL) {
+        errno = EFAULT;
+        return VFS_ERROR;
+    }
+
+    if (CheckPathIsMounted(dirName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        errno = ENOENT;
+        return VFS_ERROR;
+    }
+
+    ret = lfs_mkdir(&(fileOpInfo->lfsInfo), dirName);
+    if (ret != 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+
+    return ret;
+}
+
+int LfsRmdir(const char *dirName)
+{
+    int ret;
+
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (dirName == NULL) {
+        errno = EFAULT;
+        return VFS_ERROR;
+    }
+
+    if (CheckPathIsMounted(dirName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        errno = ENOENT;
+        return VFS_ERROR;
+    }
+
+    ret = lfs_remove(&(fileOpInfo->lfsInfo), dirName);
+    if (ret != 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+
+    return ret;
+}
+
+DIR *LfsOpendir(const char *dirName)
+{
+    int ret;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (dirName == NULL) {
+        errno = EFAULT;
+        goto errout;
+    }
+
+    if (CheckPathIsMounted(dirName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        errno = ENOENT;
+        goto errout;
+    }
+
+    if (CheckDirIsOpen(dirName)) {
+        errno = EBUSY;
+        goto errout;
+    }
+
+    FileDirInfo *dirInfo = GetFreeDir(dirName);
+    if (dirInfo == NULL) {
+        errno = ENFILE;
+        goto errout;
+    }
+
+    ret = lfs_dir_open(&(fileOpInfo->lfsInfo), (lfs_dir_t *)(&(dirInfo->dir)), dirName);
+
+    if (ret != 0) {
+        FreeDirInfo(dirName);
+        errno = LittlefsErrno(ret);
+        goto errout;
+    }
+
+    dirInfo->lfsHandle = &(fileOpInfo->lfsInfo);
+
+    return (DIR *)dirInfo;
+
+errout:
+    return NULL;
+}
+
+struct dirent *LfsReaddir(DIR *dir)
+{
+    int ret;
+    struct lfs_info lfsInfo;
+
+    FileDirInfo *dirInfo = (FileDirInfo *)dir;
+
+    if (dirInfo == NULL || dirInfo->lfsHandle == NULL) {
+        errno = EBADF;
+        return NULL;
+    }
+
+    ret = lfs_dir_read(dirInfo->lfsHandle, (lfs_dir_t *)(&(dirInfo->dir)), &lfsInfo);
+    if (ret == TRUE) {
+        pthread_mutex_lock(&g_FslocalMutex);
+        (void)strncpy_s(g_nameValue.d_name, sizeof(g_nameValue.d_name), lfsInfo.name, strlen(lfsInfo.name) + 1);
+        if (lfsInfo.type == LFS_TYPE_DIR) {
+            g_nameValue.d_type = DT_DIR;
+        } else if (lfsInfo.type == LFS_TYPE_REG) {
+            g_nameValue.d_type = DT_REG;
+        }
+
+        g_nameValue.d_reclen = lfsInfo.size;
+        pthread_mutex_unlock(&g_FslocalMutex);
+
+        return &g_nameValue;
+    }
+
+    if (ret != 0) {
+        errno = LittlefsErrno(ret);
+    }
+
+    return NULL;
+}
+
+int LfsClosedir(DIR *dir)
+{
+    int ret;
+    FileDirInfo *dirInfo = (FileDirInfo *)dir;
+
+    if (dirInfo == NULL || dirInfo->lfsHandle == NULL) {
+        errno = EBADF;
+        return VFS_ERROR;
+    }
+
+    ret = lfs_dir_close(dirInfo->lfsHandle, (lfs_dir_t *)(&(dirInfo->dir)));
+
+    FreeDirInfo(dirInfo->dirName);
+
+    if (ret != 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+
+    return ret;
+}
+
+int LfsOpen(const char *pathName, int openFlag, int mode)
+{
+    int fd = INVALID_FD;
+    int err = INVALID_FD;
+
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (pathName == NULL) {
+        errno = EFAULT;
+        goto errout;
+    }
+
+    if (CheckPathIsMounted(pathName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        errno = ENOENT;
+        goto errout;
+    }
+    // if file is already open, return invalid fd
+    if (CheckFileIsOpen(pathName)) {
+        errno = EBUSY;
+        goto errout;
+    }
+
+    LittleFsHandleStruct *fsHandle = LfsAllocFd(pathName, &fd);
+    if (fd == INVALID_FD) {
+        errno = ENFILE;
+        goto errout;
+    }
+
+    int lfsOpenFlag = ConvertFlagToLfsOpenFlag(openFlag);
+    err = lfs_file_open(&(fileOpInfo->lfsInfo), &(fsHandle->file), pathName, lfsOpenFlag);
+    if (err != 0) {
+        LfsFreeFd(fd);
+        errno = LittlefsErrno(err);
+        goto errout;
+    }
+
+    g_handle[fd].lfsHandle = &(fileOpInfo->lfsInfo);
+    return fd;
+
+errout:
+    return INVALID_FD;
+}
+
+int LfsRead(int fd, void *buf, unsigned int len)
+{
+    int ret;
+
+    if (buf == NULL) {
+        errno = EFAULT;
+        return VFS_ERROR;
+    }
+
+    if (LfsFdIsValid(fd) == FALSE) {
+        errno = EBADF;
+        return VFS_ERROR;
+    }
+
+    ret = lfs_file_read(g_handle[fd].lfsHandle, &(g_handle[fd].file), buf, len);
+    if (ret < 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+    return ret;
+}
+
+int LfsWrite(int fd, const void *buf, unsigned int len)
+{
+    int ret;
+
+    if (buf == NULL) {
+        errno = EFAULT;
+        return VFS_ERROR;
+    }
+
+    if (LfsFdIsValid(fd) == FALSE) {
+        errno = EBADF;
+        return VFS_ERROR;
+    }
+
+    ret = lfs_file_write(g_handle[fd].lfsHandle, &(g_handle[fd].file), buf, len);
+    if (ret < 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+    return ret;
+}
+
+off_t LfsSeek(int fd, off_t offset, int whence)
+{
+    off_t ret;
+
+    if (LfsFdIsValid(fd) == FALSE) {
+        errno = EBADF;
+        return VFS_ERROR;
+    }
+
+    ret = (off_t)lfs_file_seek(g_handle[fd].lfsHandle, &(g_handle[fd].file), offset, whence);
+    if (ret < 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+
+    return ret;
+}
+
+int LfsClose(int fd)
+{
+    int ret;
+
+    if (LfsFdIsValid(fd) == FALSE) {
+        errno = EBADF;
+        return VFS_ERROR;
+    }
+
+    pthread_mutex_lock(&g_FslocalMutex);
+    ret = lfs_file_close(g_handle[fd].lfsHandle, &(g_handle[fd].file));
+    pthread_mutex_unlock(&g_FslocalMutex);
+
+    LfsFreeFd(fd);
+
+    if (ret != 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+
+    return ret;
+}
+
+int LfsRename(const char *oldName, const char *newName)
+{
+    int ret;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (oldName == NULL || newName == NULL) {
+        errno = EFAULT;
+        return VFS_ERROR;
+    }
+
+    if (CheckPathIsMounted(oldName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        errno = ENOENT;
+        return VFS_ERROR;
+    }
+
+    ret = lfs_rename(&(fileOpInfo->lfsInfo), oldName, newName);
+    if (ret != 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+
+    return ret;
+}
+
+int LfsStat(const char *path, struct stat *buf)
+{
+    int ret;
+    struct lfs_info info;
+    struct FileOpInfo *fileOpInfo = NULL;
+
+    if (path == NULL || buf == NULL) {
+        errno = EFAULT;
+        return VFS_ERROR;
+    }
+
+    if (CheckPathIsMounted(path, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+        errno = ENOENT;
+        return VFS_ERROR;
+    }
+
+    ret = lfs_stat(&(fileOpInfo->lfsInfo), path, &info);
+    if (ret == 0) {
+        buf->st_size = info.size;
+        if (info.type == LFS_TYPE_REG) {
+            buf->st_mode = S_IFREG;
+        } else {
+            buf->st_mode = S_IFDIR;
+        }
+    } else {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+
+    return ret;
+}
+
+int LfsFsync(int fd)
+{
+    int ret;
+
+    if (LfsFdIsValid(fd) == FALSE) {
+        errno = EBADF;
+        return VFS_ERROR;
+    }
+
+    ret = lfs_file_sync(g_handle[fd].lfsHandle, &(g_handle[fd].file));
+    if (ret != 0) {
+        errno = LittlefsErrno(ret);
+        ret = VFS_ERROR;
+    }
+    return ret;
+}
diff --git a/kernel/liteos_m/components/fs/littlefs/lfs_api.h b/kernel/liteos_m/components/fs/littlefs/lfs_api.h
new file mode 100644
index 0000000..36c82d1
--- /dev/null
+++ b/kernel/liteos_m/components/fs/littlefs/lfs_api.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LFS_API_H_
+#define _LFS_API_H_
+
+#include "bits/alltypes.h"
+#include "fcntl.h"
+#include "sys/stat.h"
+
+#include "dirent.h"
+#include "errno.h"
+#include "fs_operations.h"
+#include "lfs.h"
+#include "lfs_util.h"
+#include "memory.h"
+#include "pthread.h"
+
+#define INVALID_FD (-1)
+
+typedef unsigned mode_t;
+
+#ifndef VFS_ERROR
+#define VFS_ERROR (-1)
+#endif
+
+#ifndef VFS_OK
+#define VFS_OK  0
+#endif
+
+typedef struct {
+    uint8_t useFlag;
+    const char *pathName;
+    lfs_t *lfsHandle;
+    lfs_file_t file;
+} LittleFsHandleStruct;
+
+struct FileOpInfo {
+    uint8_t useFlag;
+    const struct FileOps *fsVops;
+    char *dirName;
+    lfs_t lfsInfo;
+};
+
+typedef struct {
+    uint8_t useFlag;
+    char *dirName;
+    lfs_t *lfsHandle;
+    lfs_dir_t dir;
+} FileDirInfo;
+
+#define LITTLE_FS_MAX_OPEN_FILES 100
+#define LITTLE_FS_STANDARD_NAME_LENGTH 50
+#define LITTLE_FS_MAX_NAME_LEN 255
+
+#define MAX_DEF_BUF_NUM 21
+#define MAX_BUFFER_LEN 100
+#define MAX_WRITE_FILE_LEN 500
+#define MAX_READ_FILE_LEN 500
+#define LITTLEFS_MAX_LFN_LEN 255
+
+#ifndef LFS_MAX_OPEN_DIRS
+#define LFS_MAX_OPEN_DIRS 10
+#endif
+
+LittleFsHandleStruct *GetFreeFd(int *fd);
+
+int InitMountInfo(const char *fileSystemType, const struct MountOps *fsMops);
+int LfsMount(const char *source, const char *target, const char *fileSystemType, unsigned long mountflags,
+    const void *data);
+
+int LfsUmount(const char *target);
+int LfsUnlink(const char *fileName);
+int LfsMkdir(const char *dirName, mode_t mode);
+int LfsRmdir(const char *dirName);
+DIR *LfsOpendir(const char *dirName);
+struct dirent *LfsReaddir(DIR *dir);
+int LfsClosedir(DIR *dir);
+int LfsOpen(const char *pathName, int openFlag, int mode);
+int LfsRead(int fd, void *buf, unsigned int len);
+int LfsWrite(int fd, const void *buf, unsigned int len);
+off_t LfsSeek(int fd, off_t offset, int whence);
+int LfsClose(int fd);
+int LfsRename(const char *oldName, const char *newName);
+int LfsStat(const char *path, struct stat *buf);
+int LfsFsync(int fd);
+int SetDefaultMountPath(int pathNameIndex, const char* target);
+
+const struct FsMap *MountFindfs(const char *filesystemtype);
+
+#endif /* _LFS_API_H_ */
+
diff --git a/kernel/liteos_m/components/net/lwip-2.1/BUILD.gn b/kernel/liteos_m/components/net/lwip-2.1/BUILD.gn
new file mode 100644
index 0000000..ddd7ac7
--- /dev/null
+++ b/kernel/liteos_m/components/net/lwip-2.1/BUILD.gn
@@ -0,0 +1,50 @@
+# Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+import("lwip_porting.gni")
+import("//third_party/lwip/lwip.gni")
+
+config("lwip_depends") {
+  defines = [ "_BSD_SOURCE = 1" ]
+}
+
+static_library("lwip") {
+  include_dirs = [
+    "//kernel/liteos_m/kal/posix/include",
+    "//kernel/liteos_m/kernel/arch/include",
+  ]
+
+  include_dirs += LWIP_PORTING_INCLUDE_DIRS
+  include_dirs += LWIP_INCLUDE_DIRS
+
+  sources = LWIP_PORTING_FILES + LWIPNOAPPSFILES
+
+  configs += [ ":lwip_depends" ]
+
+  deps = [ "//kernel/liteos_m/kal/posix" ]
+}
\ No newline at end of file
diff --git a/kernel/liteos_m/components/net/lwip-2.1/enhancement/src/fixme.c b/kernel/liteos_m/components/net/lwip-2.1/enhancement/src/fixme.c
index 5985736..e688d3e 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/enhancement/src/fixme.c
+++ b/kernel/liteos_m/components/net/lwip-2.1/enhancement/src/fixme.c
@@ -1,178 +1,178 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <lwip/sys.h>
-#include <lwip/etharp.h>
-#include <lwip/netifapi.h>
-#include <lwip/priv/api_msg.h>
-
-#define NETIFAPI_VAR_REF(name)      API_VAR_REF(name)
-#define NETIFAPI_VAR_DECLARE(name)  API_VAR_DECLARE(struct netifapi_msg, name)
-#define NETIFAPI_VAR_ALLOC(name)    API_VAR_ALLOC(struct netifapi_msg, MEMP_NETIFAPI_MSG, name, ERR_MEM)
-#define NETIFAPI_VAR_FREE(name)     API_VAR_FREE(MEMP_NETIFAPI_MSG, name)
-
-static struct netif *netif_find_by_name(const char *name)
-{
-    struct netif *netif = NULL;
-    LWIP_ASSERT_CORE_LOCKED();
-    if (name == NULL) {
-        return NULL;
-    }
-    NETIF_FOREACH(netif) {
-        if (strcmp("lo", name) == 0 && (netif->name[0] == 'l' && netif->name[1] == 'o')) {
-            LWIP_DEBUGF(NETIF_DEBUG, ("netif_find_by_name: found lo\n"));
-            return netif;
-        }
-
-        if (strcmp(netif->full_name, name) == 0) {
-            LWIP_DEBUGF(NETIF_DEBUG, ("netif_find_by_name: found %s\n", name));
-            return netif;
-        }
-    }
-
-    LWIP_DEBUGF(NETIF_DEBUG, ("netif_find_by_name: didn't find %s\n", name));
-    return NULL;
-}
-
-static err_t netifapi_do_find_by_name(struct tcpip_api_call_data *m)
-{
-    /* cast through void* to silence alignment warnings.
-     * We know it works because the structs have been instantiated as struct netifapi_msg */
-    struct netifapi_msg *msg = (struct netifapi_msg *)(void *)m;
-    msg->netif = netif_find_by_name(msg->msg.ifs.name);
-    return ERR_OK;
-}
-
-struct netif *netifapi_netif_find_by_name(const char *name)
-{
-    struct netif *netif = NULL;
-    NETIFAPI_VAR_DECLARE(msg);
-    NETIFAPI_VAR_ALLOC(msg);
-    NETIFAPI_VAR_REF(msg).netif = NULL;
-#if LWIP_MPU_COMPATIBLE
-    if (strncpy_s(NETIFAPI_VAR_REF(msg).msg.ifs.name, NETIF_NAMESIZE, name, NETIF_NAMESIZE - 1)) {
-        NETIFAPI_VAR_FREE(msg);
-        return netif;
-    }
-    NETIFAPI_VAR_REF(msg).msg.ifs.name[NETIF_NAMESIZE - 1] = '\0';
-#else
-    NETIFAPI_VAR_REF(msg).msg.ifs.name = (char *)name;
-#endif /* LWIP_MPU_COMPATIBLE */
-
-    (void)tcpip_api_call(netifapi_do_find_by_name, &API_VAR_REF(msg).call);
-    netif = msg.netif;
-    NETIFAPI_VAR_FREE(msg);
-    return netif;
-}
-
-#if LWIP_IPV6
-int ip6addr_aton(const char *cp, ip6_addr_t *addr)
-{
-    const int ipv6_blocks = 8;
-    u16_t current_block_index = 0;
-    u16_t current_block_value = 0;
-    u16_t addr16[ipv6_blocks];
-    u16_t *a16 = (u16_t *)addr->addr;
-    int squash_pos = ipv6_blocks;
-    int i;
-    const char *sc = cp;
-    const char *ss = cp-1;
-
-    for (; ; sc++) {
-        if (current_block_index >= ipv6_blocks) {
-            return 0; // address too long
-        }
-        if (*sc == 0) {
-            if (sc - ss == 1) {
-                if (squash_pos != current_block_index) {
-                    return 0; // empty address or address ends with a single ':'
-                } // else address ends with one valid "::"
-            } else {
-                addr16[current_block_index++] = current_block_value;
-            }
-            break;
-        } else if (*sc == ':') {
-            if (sc - ss == 1) {
-                if (sc != cp || sc[1] != ':') {
-                    return 0; // address begins with a single ':' or contains ":::"
-                } // else address begins with one valid "::"
-            } else {
-                addr16[current_block_index++] = current_block_value;
-            }
-            if (sc[1] == ':') {
-                if (squash_pos != ipv6_blocks) {
-                    return 0; // more than one "::"
-                }
-                squash_pos = current_block_index;
-                sc++;
-            }
-            ss = sc; // ss points to the recent ':' position
-            current_block_value = 0;
-        } else if (lwip_isxdigit(*sc) && (sc - ss) < 5) { // 4 hex-digits at most
-            current_block_value = (current_block_value << 4) +
-                (*sc | ('a' - 'A')) - '0' - ('a' - '9' - 1) * (*sc >= 'A');
-#if LWIP_IPV4
-        } else if (*sc == '.' && current_block_index < ipv6_blocks - 1) {
-            ip4_addr_t ip4;
-            int ret = ip4addr_aton(ss+1, &ip4);
-            if (!ret) {
-                return 0;
-            }
-            ip4.addr = lwip_ntohl(ip4.addr);
-            addr16[current_block_index++] = (u16_t)(ip4.addr >> 16);
-            addr16[current_block_index++] = (u16_t)(ip4.addr);
-            break;
-#endif /* LWIP_IPV4 */
-        } else {
-            return 0; // unexpected char or too many digits
-        }
-    }
-
-    if (squash_pos == ipv6_blocks && current_block_index != ipv6_blocks) {
-        return 0; // address too short
-    }
-    if (squash_pos != ipv6_blocks && current_block_index == ipv6_blocks) {
-        return 0; // unexpected "::" in address
-    }
-
-    for (i = 0; i < squash_pos; ++i) {
-        a16[i] = lwip_htons(addr16[i]);
-    }
-    for (; i < ipv6_blocks - current_block_index + squash_pos; ++i) {
-        a16[i] = 0;
-    }
-    for (; i < ipv6_blocks; ++i) {
-        a16[i] = lwip_htons(addr16[i - ipv6_blocks + current_block_index]);
-    }
-
-    return 1;
-}
-#endif /* LWIP_IPV6 */
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <lwip/sys.h>
+#include <lwip/etharp.h>
+#include <lwip/netifapi.h>
+#include <lwip/priv/api_msg.h>
+
+#define NETIFAPI_VAR_REF(name)      API_VAR_REF(name)
+#define NETIFAPI_VAR_DECLARE(name)  API_VAR_DECLARE(struct netifapi_msg, name)
+#define NETIFAPI_VAR_ALLOC(name)    API_VAR_ALLOC(struct netifapi_msg, MEMP_NETIFAPI_MSG, name, ERR_MEM)
+#define NETIFAPI_VAR_FREE(name)     API_VAR_FREE(MEMP_NETIFAPI_MSG, name)
+
+static struct netif *netif_find_by_name(const char *name)
+{
+    struct netif *netif = NULL;
+    LWIP_ASSERT_CORE_LOCKED();
+    if (name == NULL) {
+        return NULL;
+    }
+    NETIF_FOREACH(netif) {
+        if (strcmp("lo", name) == 0 && (netif->name[0] == 'l' && netif->name[1] == 'o')) {
+            LWIP_DEBUGF(NETIF_DEBUG, ("netif_find_by_name: found lo\n"));
+            return netif;
+        }
+
+        if (strcmp(netif->full_name, name) == 0) {
+            LWIP_DEBUGF(NETIF_DEBUG, ("netif_find_by_name: found %s\n", name));
+            return netif;
+        }
+    }
+
+    LWIP_DEBUGF(NETIF_DEBUG, ("netif_find_by_name: didn't find %s\n", name));
+    return NULL;
+}
+
+static err_t netifapi_do_find_by_name(struct tcpip_api_call_data *m)
+{
+    /* cast through void* to silence alignment warnings.
+     * We know it works because the structs have been instantiated as struct netifapi_msg */
+    struct netifapi_msg *msg = (struct netifapi_msg *)(void *)m;
+    msg->netif = netif_find_by_name(msg->msg.ifs.name);
+    return ERR_OK;
+}
+
+struct netif *netifapi_netif_find_by_name(const char *name)
+{
+    struct netif *netif = NULL;
+    NETIFAPI_VAR_DECLARE(msg);
+    NETIFAPI_VAR_ALLOC(msg);
+    NETIFAPI_VAR_REF(msg).netif = NULL;
+#if LWIP_MPU_COMPATIBLE
+    if (strncpy_s(NETIFAPI_VAR_REF(msg).msg.ifs.name, NETIF_NAMESIZE, name, NETIF_NAMESIZE - 1)) {
+        NETIFAPI_VAR_FREE(msg);
+        return netif;
+    }
+    NETIFAPI_VAR_REF(msg).msg.ifs.name[NETIF_NAMESIZE - 1] = '\0';
+#else
+    NETIFAPI_VAR_REF(msg).msg.ifs.name = (char *)name;
+#endif /* LWIP_MPU_COMPATIBLE */
+
+    (void)tcpip_api_call(netifapi_do_find_by_name, &API_VAR_REF(msg).call);
+    netif = msg.netif;
+    NETIFAPI_VAR_FREE(msg);
+    return netif;
+}
+
+#if LWIP_IPV6
+int ip6addr_aton(const char *cp, ip6_addr_t *addr)
+{
+    const int ipv6_blocks = 8;
+    u16_t current_block_index = 0;
+    u16_t current_block_value = 0;
+    u16_t addr16[ipv6_blocks];
+    u16_t *a16 = (u16_t *)addr->addr;
+    int squash_pos = ipv6_blocks;
+    int i;
+    const char *sc = cp;
+    const char *ss = cp-1;
+
+    for (; ; sc++) {
+        if (current_block_index >= ipv6_blocks) {
+            return 0; // address too long
+        }
+        if (*sc == 0) {
+            if (sc - ss == 1) {
+                if (squash_pos != current_block_index) {
+                    return 0; // empty address or address ends with a single ':'
+                } // else address ends with one valid "::"
+            } else {
+                addr16[current_block_index++] = current_block_value;
+            }
+            break;
+        } else if (*sc == ':') {
+            if (sc - ss == 1) {
+                if (sc != cp || sc[1] != ':') {
+                    return 0; // address begins with a single ':' or contains ":::"
+                } // else address begins with one valid "::"
+            } else {
+                addr16[current_block_index++] = current_block_value;
+            }
+            if (sc[1] == ':') {
+                if (squash_pos != ipv6_blocks) {
+                    return 0; // more than one "::"
+                }
+                squash_pos = current_block_index;
+                sc++;
+            }
+            ss = sc; // ss points to the recent ':' position
+            current_block_value = 0;
+        } else if (lwip_isxdigit(*sc) && (sc - ss) < 5) { // 4 hex-digits at most
+            current_block_value = (current_block_value << 4) +
+                (*sc | ('a' - 'A')) - '0' - ('a' - '9' - 1) * (*sc >= 'A');
+#if LWIP_IPV4
+        } else if (*sc == '.' && current_block_index < ipv6_blocks - 1) {
+            ip4_addr_t ip4;
+            int ret = ip4addr_aton(ss+1, &ip4);
+            if (!ret) {
+                return 0;
+            }
+            ip4.addr = lwip_ntohl(ip4.addr);
+            addr16[current_block_index++] = (u16_t)(ip4.addr >> 16);
+            addr16[current_block_index++] = (u16_t)(ip4.addr);
+            break;
+#endif /* LWIP_IPV4 */
+        } else {
+            return 0; // unexpected char or too many digits
+        }
+    }
+
+    if (squash_pos == ipv6_blocks && current_block_index != ipv6_blocks) {
+        return 0; // address too short
+    }
+    if (squash_pos != ipv6_blocks && current_block_index == ipv6_blocks) {
+        return 0; // unexpected "::" in address
+    }
+
+    for (i = 0; i < squash_pos; ++i) {
+        a16[i] = lwip_htons(addr16[i]);
+    }
+    for (; i < ipv6_blocks - current_block_index + squash_pos; ++i) {
+        a16[i] = 0;
+    }
+    for (; i < ipv6_blocks; ++i) {
+        a16[i] = lwip_htons(addr16[i - ipv6_blocks + current_block_index]);
+    }
+
+    return 1;
+}
+#endif /* LWIP_IPV6 */
diff --git a/kernel/liteos_m/components/net/lwip-2.1/enhancement/src/lwip_ifaddrs.c b/kernel/liteos_m/components/net/lwip-2.1/enhancement/src/lwip_ifaddrs.c
new file mode 100644
index 0000000..83c408d
--- /dev/null
+++ b/kernel/liteos_m/components/net/lwip-2.1/enhancement/src/lwip_ifaddrs.c
@@ -0,0 +1,334 @@
+/*
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "lwip/opt.h"
+
+#if LWIP_IFADDRS
+#if (LWIP_IPV4 || LWIP_IPV6) && LWIP_SOCKET
+#include "ifaddrs.h"
+
+#include <stdlib.h>
+
+#include "lwip/sys.h"
+#include "lwip/tcpip.h"
+#include "lwip/priv/sockets_priv.h"
+#include "lwip/mem.h"
+#include "lwip/netif.h"
+#include "lwip/dhcp.h"
+
+struct ifaddrs_storage {
+    struct ifaddrs ifa;
+    union {
+        struct sockaddr sa;
+        struct sockaddr_in s4;
+#if LWIP_IPV6
+        struct sockaddr_in6 s6;
+#endif
+    } addr, netmask, dstaddr;
+    char name[IFNAMSIZ];
+};
+
+struct getifaddrs_arg {
+    struct ifaddrs **ifap;
+    sys_sem_t cb_completed;
+    int ret;
+};
+
+static int tcpip_init_finish = 1;
+void lwip_freeifaddrs(struct ifaddrs *ifa);
+static void ifaddrs_add_tail(struct ifaddrs **ifap, struct ifaddrs *ifaddr)
+{
+    struct ifaddrs *temp = NULL;
+
+    ifaddr->ifa_next = NULL;
+    if (*ifap == NULL) {
+        *ifap = ifaddr;
+        return;
+    }
+
+    for (temp = *ifap; temp->ifa_next != NULL; temp = temp->ifa_next) {
+        /* nothing */
+    }
+
+    temp->ifa_next = ifaddr;
+}
+
+static struct ifaddrs_storage *new_ifaddrs_storage(void)
+{
+    struct ifaddrs *ifaddr = NULL;
+    struct ifaddrs_storage *if_storage = NULL;
+
+    if_storage = (struct ifaddrs_storage *)mem_malloc(sizeof(struct ifaddrs_storage));
+    if (if_storage != NULL) {
+        (void)memset_s((void*)if_storage, sizeof(struct ifaddrs_storage), 0, sizeof(struct ifaddrs_storage));
+        ifaddr = &if_storage->ifa;
+        ifaddr->ifa_name = if_storage->name;
+        ifaddr->ifa_addr = &if_storage->addr.sa;
+        ifaddr->ifa_netmask = &if_storage->netmask.sa;
+        ifaddr->ifa_dstaddr = &if_storage->dstaddr.sa;
+    }
+
+    return if_storage;
+}
+
+static int get_ifa_name(struct netif *netif, struct ifaddrs *ifaddr)
+{
+    int ret;
+
+    if (netif->link_layer_type == LOOPBACK_IF) {
+        ifaddr->ifa_flags |= IFF_LOOPBACK;
+        ret = snprintf_s(ifaddr->ifa_name, NETIF_NAMESIZE, (NETIF_NAMESIZE - 1), "%.2s", netif->name);
+    } else {
+        ret = snprintf_s(ifaddr->ifa_name, NETIF_NAMESIZE, (NETIF_NAMESIZE - 1), "%s", netif_get_name(netif));
+    }
+
+    return ret;
+}
+
+#if LWIP_IPV4
+static int get_ipv4_ifaddr(struct netif *netif, struct ifaddrs *ifaddr)
+{
+    struct sockaddr_in *addr_in = NULL;
+
+    if (netif->flags & NETIF_FLAG_UP) {
+        ifaddr->ifa_flags |= IFF_UP;
+    }
+
+    if (netif->flags & NETIF_FLAG_ETHARP) {
+        ifaddr->ifa_flags = ifaddr->ifa_flags & ((unsigned int)(~IFF_NOARP));
+    } else {
+        ifaddr->ifa_flags |= IFF_NOARP;
+    }
+
+    if (netif->flags & NETIF_FLAG_BROADCAST) {
+        ifaddr->ifa_flags |= IFF_BROADCAST;
+    }
+
+#if LWIP_DHCP
+    if (dhcp_supplied_address(netif)) {
+        ifaddr->ifa_flags |= IFF_DYNAMIC;
+    }
+#endif
+
+#if LWIP_IGMP
+    if (netif->flags & NETIF_FLAG_IGMP) {
+        ifaddr->ifa_flags |= IFF_MULTICAST;
+    }
+#endif
+
+    if (netif->flags & NETIF_FLAG_LINK_UP) {
+        ifaddr->ifa_flags |= IFF_RUNNING;
+    }
+
+#if LWIP_HAVE_LOOPIF
+    if (netif->link_layer_type == LOOPBACK_IF) {
+        addr_in = (struct sockaddr_in *)ifaddr->ifa_addr;
+        addr_in->sin_family = AF_INET;
+        addr_in->sin_addr.s_addr = ((ip4_addr_t *)&netif->ip_addr)->addr;
+    } else
+#endif
+    {
+        addr_in = (struct sockaddr_in *)ifaddr->ifa_addr;
+        addr_in->sin_family = AF_INET;
+        addr_in->sin_addr.s_addr = ((ip4_addr_t *)&netif->ip_addr)->addr;
+
+        addr_in = (struct sockaddr_in *)ifaddr->ifa_netmask;
+        addr_in->sin_family = AF_INET;
+        addr_in->sin_addr.s_addr = ((ip4_addr_t *)&netif->netmask)->addr;
+
+        addr_in = (struct sockaddr_in *)ifaddr->ifa_broadaddr;
+        addr_in->sin_family = AF_INET;
+        addr_in->sin_addr.s_addr = (((ip4_addr_t *)&netif->ip_addr)->addr & ((ip4_addr_t *)&netif->netmask)->addr) |
+                                  ~((ip4_addr_t *)&netif->netmask)->addr;
+    }
+
+    return get_ifa_name(netif, ifaddr);
+}
+#endif /* LWIP_IPV4 */
+
+#if LWIP_IPV6
+/* Stack support to retrieve the below flags for ipv6
+IFF_UP
+IFF_MULTICAST
+IFF_RUNNING
+IFF_LOOPBACK
+*/
+static int get_ipv6_ifaddr(struct netif *netif, struct ifaddrs *ifaddr, int tmp_index)
+{
+    struct sockaddr_in6 *addr_in6 = NULL;
+
+    /* As of now supports the below falgs only */
+    if (netif->flags & NETIF_FLAG_UP) {
+        ifaddr->ifa_flags |= IFF_UP;
+    }
+
+#if LWIP_IPV6_MLD
+    if (netif->flags & NETIF_FLAG_MLD6) {
+        ifaddr->ifa_flags |= IFF_MULTICAST;
+    }
+#endif
+
+    if (netif->flags & NETIF_FLAG_LINK_UP) {
+        ifaddr->ifa_flags |= IFF_RUNNING;
+    }
+
+    addr_in6 = (struct sockaddr_in6 *)ifaddr->ifa_addr;
+    addr_in6->sin6_family = AF_INET6;
+    inet6_addr_from_ip6addr(&addr_in6->sin6_addr, (ip6_addr_t *)&netif->ip6_addr[tmp_index]);
+
+    return get_ifa_name(netif, ifaddr);
+}
+#endif
+
+static void getifaddrs_internal(struct getifaddrs_arg *arg)
+{
+    struct netif *netif = NULL;
+    struct ifaddrs *ifaddr = NULL;
+    struct ifaddrs_storage *if_storage = NULL;
+
+#if LWIP_IPV6
+    int n;
+#endif
+
+    arg->ret = ENOMEM;
+    for (netif = netif_list; netif != NULL; netif = netif->next) {
+#if LWIP_IPV4
+        if_storage = new_ifaddrs_storage();
+        if (if_storage == NULL) {
+            lwip_freeifaddrs(
+                *(arg->ifap)); /* ifap is assigned to NULL in getifaddrs, so garbage value will not be there */
+            arg->ret = ENOMEM;
+            goto RETURN;
+        }
+
+        /* if get one or more netif info, then getifaddrs return 0(OK) */
+        arg->ret = 0;
+        ifaddr = &if_storage->ifa;
+        (void)get_ipv4_ifaddr(netif, ifaddr);
+        ifaddrs_add_tail(arg->ifap, ifaddr);
+#endif /* LWIP_IPV4 */
+#if LWIP_IPV6
+        for (n = 0; n < LWIP_IPV6_NUM_ADDRESSES; n++) {
+            if ((netif->ip6_addr_state[n] & IP6_ADDR_VALID) == 0) {
+                continue;
+            }
+            if_storage = new_ifaddrs_storage();
+            if (if_storage == NULL) {
+                lwip_freeifaddrs(
+                *(arg->ifap)); /* ifap is assigned to NULL in getifaddrs, so garbage value will not be there */
+                arg->ret = ENOMEM;
+                goto RETURN;
+            }
+
+            /* if get one or more netif info, then getifaddrs return 0(OK) */
+            arg->ret = 0;
+            ifaddr = &if_storage->ifa;
+            (void)get_ipv6_ifaddr(netif, ifaddr, n);
+            ifaddrs_add_tail(arg->ifap, ifaddr);
+        }
+#endif
+    }
+
+RETURN:
+#if !LWIP_TCPIP_CORE_LOCKING
+    sys_sem_signal(&arg->cb_completed);
+#endif
+    return;
+}
+
+int lwip_getifaddrs(struct ifaddrs **ifap)
+{
+    struct getifaddrs_arg arg;
+
+    LWIP_ERROR("lwip_getifaddrs : ifap is NULL", (ifap != NULL), return ERR_ARG);
+    *ifap = NULL;
+
+    if (!tcpip_init_finish) {
+        set_errno(EACCES);
+        return -1;
+    }
+    arg.ret = 0;
+    arg.ifap = ifap;
+
+#if LWIP_TCPIP_CORE_LOCKING
+    LOCK_TCPIP_CORE();
+    getifaddrs_internal(&arg);
+    UNLOCK_TCPIP_CORE();
+#else
+
+    if (sys_sem_new(&arg.cb_completed, 0) != ERR_OK) {
+        set_errno(ENOMEM);
+        return -1;
+    }
+
+    tcpip_callback((tcpip_callback_fn)getifaddrs_internal, &arg);
+    (void)sys_arch_sem_wait(&arg.cb_completed, 0);
+    sys_sem_free(&arg.cb_completed);
+#endif
+
+    if (arg.ret != 0) {
+        set_errno(arg.ret);
+        *ifap = NULL;
+        return -1;
+    }
+
+    return 0;
+}
+
+static void freeifaddrs_iteration(struct ifaddrs *ifa)
+{
+    if (ifa == NULL) {
+        return;
+    }
+
+    if (ifa->ifa_next != NULL) {
+        freeifaddrs_iteration(ifa->ifa_next);
+    }
+
+    mem_free(ifa);
+}
+
+void lwip_freeifaddrs(struct ifaddrs *ifa)
+{
+    freeifaddrs_iteration(ifa);
+}
+
+int getifaddrs(struct ifaddrs **ifap)
+{
+    return lwip_getifaddrs(ifap);
+}
+
+void freeifaddrs(struct ifaddrs *ifa)
+{
+    lwip_freeifaddrs(ifa);
+}
+
+#endif /* (LWIP_IPV4 || LWIP_IPV6) && LWIP_SOCKET */
+#endif /* LWIP_IFADDRS */
\ No newline at end of file
diff --git a/kernel/liteos_m/components/net/lwip-2.1/lwip_porting.gni b/kernel/liteos_m/components/net/lwip-2.1/lwip_porting.gni
new file mode 100644
index 0000000..d00f8f0
--- /dev/null
+++ b/kernel/liteos_m/components/net/lwip-2.1/lwip_porting.gni
@@ -0,0 +1,44 @@
+# Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+import("//kernel/liteos_m/config.gni")
+LWIP_PORTING_DIR = "//kernel/liteos_m/components/net/lwip-2.1"
+
+LWIP_PORTING_INCLUDE_DIRS = [ "$LWIP_PORTING_DIR/porting/include" ]
+
+LWIP_PORTING_FILES = [
+  "$LWIP_PORTING_DIR/porting/src/driverif.c",
+  "$LWIP_PORTING_DIR/porting/src/lwip_init.c",
+  "$LWIP_PORTING_DIR/porting/src/netdb_porting.c",
+  "$LWIP_PORTING_DIR/porting/src/sockets_porting.c",
+  "$LWIP_PORTING_DIR/porting/src/sys_arch.c",
+  if (enable_ohos_kernel_liteos_m_shell== true) {
+    "$LWIP_PORTING_DIR/porting/src/api_shell.c",
+  }
+  "$LWIP_PORTING_DIR/enhancement/src/fixme.c",
+  "$LWIP_PORTING_DIR/enhancement/src/lwip_ifaddrs.c",
+]
\ No newline at end of file
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/cc.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/cc.h
index 746bf9e..64e364f 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/cc.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/cc.h
@@ -32,19 +32,42 @@
 #ifndef _LWIP_PORTING_CC_H_
 #define _LWIP_PORTING_CC_H_
 
+#ifdef LITTLE_ENDIAN
+#undef LITTLE_ENDIAN
+#endif
+
+#ifdef BIG_ENDIAN
+#undef BIG_ENDIAN
+#endif
+
+#include <endian.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include "securec.h"
-#include "log.h"
+#include "memory_pool.h"
 
 #ifdef htons
 #define LWIP_DONT_PROVIDE_BYTEORDER_FUNCTIONS
 #endif
 
-#define LWIP_PROVIDE_ERRNO 1
-#define __SIZEOF_POINTER__ 4   // 32位系统
+#define SOCKLEN_T_DEFINED
+#define SA_FAMILY_T_DEFINED
+#define IN_PORT_T_DEFINED
+
+#define LWIP_TIMEVAL_PRIVATE    0
+#define LWIP_ERRNO_STDINCLUDE
+#define LWIP_SOCKET_STDINCLUDE
+
+#define LWIP_DNS_API_DEFINE_ERRORS    0
+#define LWIP_DNS_API_DEFINE_FLAGS     0
+#define LWIP_DNS_API_DECLARE_STRUCTS  0
+#define LWIP_DNS_API_DECLARE_H_ERRNO  0
+
+#ifndef __SIZEOF_POINTER__
+#define __SIZEOF_POINTER__ 4   // 32 bit system
+#endif
 
-#define LOS_TASK_STATUS_DETACHED   0x0100  // 预留字段
+#define LOS_TASK_STATUS_DETACHED   0x0100  // reserved
 
 #if defined(__arm__) && defined(__ARMCC_VERSION)
     /* Keil uVision4 tools */
@@ -96,7 +119,6 @@ extern void HilogPrintf(const char *fmt, ...);
 #define init_waitqueue_head(...)
 #define poll_check_waiters(...)
 #define IOCTL_CMD_CASE_HANDLER()
-#define DF_NADDR(addr)
 
 #define DNS_SERVER_ADDRESS(ipaddr)        (ip4_addr_set_u32(ipaddr, ipaddr_addr("114.114.114.114")))
 #define DNS_SERVER_ADDRESS_SECONDARY(ipaddr)        (ip4_addr_set_u32(ipaddr, ipaddr_addr("114.114.115.115")))
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/perf.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/perf.h
index 43147ef..4f8136b 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/perf.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/perf.h
@@ -1,42 +1,42 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _LWIP_PORTING_PERF_H_
-#define _LWIP_PORTING_PERF_H_
-
-#if LWIP_PERF
-
-#define PERF_START    do { /* something to do */ } while (0)
-#define PERF_STOP(x)  do { /* something to do */ } while (0)
-
-#endif
-
-#endif /* _LWIP_PORTING_PERF_H_ */
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LWIP_PORTING_PERF_H_
+#define _LWIP_PORTING_PERF_H_
+
+#if LWIP_PERF
+
+#define PERF_START    do { /* something to do */ } while (0)
+#define PERF_STOP(x)  do { /* something to do */ } while (0)
+
+#endif
+
+#endif /* _LWIP_PORTING_PERF_H_ */
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/sys_arch.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/sys_arch.h
index 95f7f80..16b89d7 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/sys_arch.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/arch/sys_arch.h
@@ -33,8 +33,6 @@
 #define _LWIP_PORTING_SYS_ARCH_H_
 
 #include <stdint.h>
-#include "memory_pool.h"
-#include "los_mux.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/api_shell.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/api_shell.h
new file mode 100644
index 0000000..8b964b7
--- /dev/null
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/api_shell.h
@@ -0,0 +1,55 @@
+/**********************************************************************************
+
+* Copyright (c) <2013-2015>, <Huawei Technologies Co., Ltd>
+* All rights reserved.
+* Redistribution and use in source and binary forms, with or without modification,
+* are permitted provided that the following conditions are met:
+* Redistributions of source code must retain the above copyright notice, this
+* list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice,
+* this list of conditions and the following disclaimer in the documentation and/or
+* other materials provided with the distribution.
+* Neither the name of the copyright holder nor the names of its contributors
+* may be used to endorse or promote products derived from this software without
+* specific prior written permission.
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+***********************************************************************************/
+/**********************************************************************************
+
+* Notice of Export Control Law
+===============================================
+* Huawei LiteOS may be subject to applicable export control laws and regulations, which
+* might include those applicable to Huawei LiteOS of U.S. and the country in which you
+* are located.
+* Import, export and usage of Huawei LiteOS in any manner by you shall be in compliance
+* with such applicable export control laws and regulations.
+***********************************************************************************/
+
+
+#ifndef LWIP_API_SHELL_H
+#define LWIP_API_SHELL_H
+
+#include "arch/cc.h"
+#include "lwip/opt.h"
+
+#if defined (__cplusplus) && __cplusplus
+extern "C" {
+#endif
+
+u32_t lwip_ifconfig(int argc, const char **argv);
+u32_t OsShellPing(int argc, const char **argv);
+LWIP_STATIC int OsPingFunc(u32_t *parg);
+
+#if defined (__cplusplus) && __cplusplus
+}
+#endif
+#endif /* LWIP_HDR_API_SHELL_H */
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/inet.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/inet.h
new file mode 100644
index 0000000..3a54a1c
--- /dev/null
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/inet.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LWIP_PORTING_INET_H_
+#define _LWIP_PORTING_INET_H_
+
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include_next <lwip/inet.h>
+
+#if LWIP_IPV4
+#define inet_addr_from_ip4addr(target_inaddr, source_ipaddr) \
+            ((target_inaddr)->s_addr = ip4_addr_get_u32(source_ipaddr))
+#define inet_addr_to_ip4addr(target_ipaddr, source_inaddr) \
+            (ip4_addr_set_u32(target_ipaddr, (source_inaddr)->s_addr))
+
+/* directly map this to the lwip internal functions */
+#define inet_addr(cp)                   ipaddr_addr(cp)
+#define inet_aton(cp, addr)             ip4addr_aton(cp, (ip4_addr_t*)addr)
+#define inet_ntoa(addr)                 ip4addr_ntoa((const ip4_addr_t*)&(addr))
+#define inet_ntoa_r(addr, buf, buflen)  ip4addr_ntoa_r((const ip4_addr_t*)&(addr), buf, buflen)
+#endif /* LWIP_IPV4 */
+#if LWIP_IPV6
+#define inet6_addr_from_ip6addr(target_in6addr, source_ip6addr) \
+            {(target_in6addr)->s6_addr32[0] = (source_ip6addr)->addr[0]; \
+            (target_in6addr)->s6_addr32[1] = (source_ip6addr)->addr[1]; \
+            (target_in6addr)->s6_addr32[2] = (source_ip6addr)->addr[2]; \
+            (target_in6addr)->s6_addr32[3] = (source_ip6addr)->addr[3];}
+#define inet6_addr_to_ip6addr(target_ip6addr, source_in6addr) \
+            {(target_ip6addr)->addr[0] = (source_in6addr)->s6_addr32[0]; \
+            (target_ip6addr)->addr[1] = (source_in6addr)->s6_addr32[1]; \
+            (target_ip6addr)->addr[2] = (source_in6addr)->s6_addr32[2]; \
+            (target_ip6addr)->addr[3] = (source_in6addr)->s6_addr32[3]; \
+            ip6_addr_clear_zone(target_ip6addr);}
+#endif /* LWIP_IPV6 */
+
+#endif /* _LWIP_PORTING_INET_H_ */
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/lwipopts.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/lwipopts.h
index 7d07775..ab54f69 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/lwipopts.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/lwipopts.h
@@ -134,8 +134,7 @@
 #define LWIP_NETIF_LOOPBACK             1
 #define LWIP_POSIX_SOCKETS_IO_NAMES     0
 #define LWIP_RAW                        1
-#define CONFIG_NFILE_DESCRIPTORS        1
-#define LWIP_SOCKET_OFFSET              CONFIG_NFILE_DESCRIPTORS
+#define LWIP_SOCKET_OFFSET              FAT_MAX_OPEN_FILES
 #define LWIP_SO_RCVBUF                  1
 #define LWIP_SO_RCVTIMEO                1
 #define LWIP_SO_SNDTIMEO                1
diff --git a/kernel/liteos_m/kal/cmsis/cmsis_liteos.c b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netdb.h
similarity index 89%
rename from kernel/liteos_m/kal/cmsis/cmsis_liteos.c
rename to kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netdb.h
index 0b745fc..5836924 100644
--- a/kernel/liteos_m/kal/cmsis/cmsis_liteos.c
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netdb.h
@@ -29,10 +29,10 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "los_config.h"
+#ifndef _LWIP_PORTING_NETDB_H_
+#define _LWIP_PORTING_NETDB_H_
 
-#if (CMSIS_OS_VER == 1)
-#error "cmsis version 1.0 is not supported now!"
-#elif (CMSIS_OS_VER == 2)
-#include "cmsis_liteos2.c"
-#endif
+#include <netdb.h>
+#include_next <lwip/netdb.h>
+
+#endif /* _LWIP_PORTING_NETDB_H_ */
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netif.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netif.h
index 421a5fb..f920fbd 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netif.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netif.h
@@ -32,6 +32,9 @@
 #ifndef _LWIP_PORTING_NETIF_H_
 #define _LWIP_PORTING_NETIF_H_
 
+#include <net/if.h>
+#include <netinet/ip.h>
+
 #define netif_find netifapi_netif_find_by_name
 
 #if LWIP_DHCPS
@@ -39,12 +42,11 @@
                                             LWIP_NETIF_CLIENT_DATA_INDEX_DHCPS
 #endif
 
-#define LWIP_NETIF_FULLNAME 16
 #define linkoutput      linkoutput; \
                         void (*drv_send)(struct netif *netif, struct pbuf *p); \
                         u8_t (*drv_set_hwaddr)(struct netif *netif, u8_t *addr, u8_t len); \
                         void (*drv_config)(struct netif *netif, u32_t config_flags, u8_t setBit); \
-                        char full_name[LWIP_NETIF_FULLNAME]; \
+                        char full_name[IFNAMSIZ]; \
                         u16_t link_layer_type
 #include_next <lwip/netif.h>
 #undef linkoutput
@@ -52,7 +54,7 @@
 #undef LWIP_NETIF_CLIENT_DATA_INDEX_DHCP
 #endif
 
-#include <lwip/etharp.h> // For ETHARP_HWADDR_LEN, by `hieth-sf src/interface.c' and `wal/wal_net.c'
+#include <lwip/etharp.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -60,9 +62,9 @@ extern "C" {
 
 // redefine NETIF_NAMESIZE which was defined in netif.h
 #undef NETIF_NAMESIZE
-#define NETIF_NAMESIZE LWIP_NETIF_FULLNAME
+#define NETIF_NAMESIZE IFNAMSIZ
 
-#define LOOPBACK_IF         0 // 772
+#define LOOPBACK_IF         0
 #define ETHERNET_DRIVER_IF  1
 #define WIFI_DRIVER_IF      801
 #define BT_PROXY_IF         802
@@ -70,6 +72,8 @@ extern "C" {
 err_t driverif_init(struct netif *netif);
 void driverif_input(struct netif *netif, struct pbuf *p);
 
+#define netif_get_name(netif) ((netif)->full_name)
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netifapi.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netifapi.h
index 44858b7..9cdf440 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netifapi.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/netifapi.h
@@ -1,54 +1,54 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _LWIP_PORTING_NETIFAPI_H_
-#define _LWIP_PORTING_NETIFAPI_H_
-
-#include_next <lwip/netifapi.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-err_t netifapi_dhcps_start(struct netif *netif, char *start_ip, u16_t ip_num);
-err_t netifapi_dhcps_stop(struct netif *netif);
-
-#define netifapi_dhcp_cleanup(n)          netifapi_netif_common(n, dhcp_cleanup, NULL)
-#define netifapi_dhcp_is_bound(n)         netifapi_netif_common(n, NULL, dhcp_is_bound)
-
-void netifapi_netif_rmv_ip6_address(struct netif *netif, ip_addr_t *ipaddr);
-struct netif *netifapi_netif_find_by_name(const char *name);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _LWIP_PORTING_NETIFAPI_H_ */
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LWIP_PORTING_NETIFAPI_H_
+#define _LWIP_PORTING_NETIFAPI_H_
+
+#include_next <lwip/netifapi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+err_t netifapi_dhcps_start(struct netif *netif, char *start_ip, u16_t ip_num);
+err_t netifapi_dhcps_stop(struct netif *netif);
+
+#define netifapi_dhcp_cleanup(n)          netifapi_netif_common(n, dhcp_cleanup, NULL)
+#define netifapi_dhcp_is_bound(n)         netifapi_netif_common(n, NULL, dhcp_is_bound)
+
+void netifapi_netif_rmv_ip6_address(struct netif *netif, ip_addr_t *ipaddr);
+struct netif *netifapi_netif_find_by_name(const char *name);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _LWIP_PORTING_NETIFAPI_H_ */
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/sys/socket.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/sockets.h
similarity index 56%
rename from kernel/liteos_m/components/net/lwip-2.1/porting/include/sys/socket.h
rename to kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/sockets.h
index c5f27a6..58d23c8 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/sys/socket.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwip/sockets.h
@@ -29,51 +29,55 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef	_SYS_SOCKET_PORTING_H
-#define	_SYS_SOCKET_PORTING_H
+#ifndef _LWIP_PORTING_SOCKETS_H_
+#define _LWIP_PORTING_SOCKETS_H_
 
-#include "lwip/sockets.h"
+#include <sys/socket.h>
+#include <poll.h>
+#include <netinet/tcp.h>
+#include <netinet/in.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <limits.h>
+#include <fcntl.h>
+#include_next <lwip/sockets.h>
+#include <fatfs.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-int socket (int, int, int);
-
-int bind (int, const struct sockaddr *, socklen_t);
-int connect (int, const struct sockaddr *, socklen_t);
-int listen (int, int);
-int accept (int, struct sockaddr *__restrict, socklen_t *__restrict);
+#if FD_SETSIZE < (LWIP_SOCKET_OFFSET + MEMP_NUM_NETCONN)
+#error "external FD_SETSIZE too small for number of sockets"
+#else
+#define LWIP_SELECT_MAXNFDS FD_SETSIZE
+#endif
 
-int getsockname (int, struct sockaddr *__restrict, socklen_t *__restrict);
-int getpeername (int, struct sockaddr *__restrict, socklen_t *__restrict);
+#if IOV_MAX > 0xFFFF
+#error "IOV_MAX larger than supported by LwIP"
+#endif
 
-ssize_t send (int, const void *, size_t, int);
-ssize_t recv (int, void *, size_t, int);
-ssize_t sendto (int, const void *, size_t, int, const struct sockaddr *, socklen_t);
-ssize_t recvfrom (int, void *__restrict, size_t, int, struct sockaddr *__restrict, socklen_t *__restrict);
-ssize_t sendmsg (int, const struct msghdr *, int);
-ssize_t recvmsg (int, struct msghdr *, int);
+#if LWIP_UDP && LWIP_UDPLITE
+#define UDPLITE_SEND_CSCOV 0x01 /* sender checksum coverage */
+#define UDPLITE_RECV_CSCOV 0x02 /* minimal receiver checksum coverage */
+#endif
 
-int getsockopt (int, int, int, void *__restrict, socklen_t *__restrict);
-int setsockopt (int, int, int, const void *, socklen_t);
+// For BSD 4.4 socket sa_len compatibility
+#define DF_NADDR(addr)
+#define SA_LEN(addr, _)  (IP_IS_V4_VAL(addr) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6))
+#define sa_len sa_data[0] * 0 + SA_LEN(naddr, _)
+#define sin_len sin_zero[0]
+#define sin6_len sin6_addr.s6_addr[0]
 
-const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
-int inet_pton(int af, const char *src, void *dst);
+// for sockets.c, TCP_KEEPALIVE is not supported currently
+#define TCP_KEEPALIVE   0xFF
+#define SIN_ZERO_LEN    8
 
-int shutdown (int, int);
 int closesocket(int sockfd);
-
 int ioctlsocket(int s, long cmd, void *argp);
 
-#if LWIP_SOCKET_SELECT
-int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout);
-#endif
-#if LWIP_SOCKET_POLL
-int poll(struct pollfd *fds, nfds_t nfds, int timeout);
-#endif
-
 #ifdef __cplusplus
 }
 #endif
-#endif
+
+#endif /* _LWIP_PORTING_SOCKETS_H_ */
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwipopts.h b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwipopts.h
index 4f1ab72..22f65e7 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwipopts.h
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/include/lwipopts.h
@@ -1,38 +1,38 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __LITEOS_M_LWIPOPTS_H__
-#define __LITEOS_M_LWIPOPTS_H__
-
-// Just redirect
-#include "lwip/lwipopts.h"
-
-#endif // __LITEOS_M_LWIPOPTS_H__
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __LITEOS_M_LWIPOPTS_H__
+#define __LITEOS_M_LWIPOPTS_H__
+
+// Just redirect
+#include "lwip/lwipopts.h"
+
+#endif // __LITEOS_M_LWIPOPTS_H__
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/src/api_shell.c b/kernel/liteos_m/components/net/lwip-2.1/porting/src/api_shell.c
new file mode 100644
index 0000000..0e385d4
--- /dev/null
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/src/api_shell.c
@@ -0,0 +1,618 @@
+/**********************************************************************************
+
+* Copyright (c) <2013-2015>, <Huawei Technologies Co., Ltd>
+* All rights reserved.
+* Redistribution and use in source and binary forms, with or without modification,
+* are permitted provided that the following conditions are met:
+* Redistributions of source code must retain the above copyright notice, this
+* list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice,
+* this list of conditions and the following disclaimer in the documentation and/or
+* other materials provided with the distribution.
+* Neither the name of the copyright holder nor the names of its contributors
+* may be used to endorse or promote products derived from this software without
+* specific prior written permission.
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+***********************************************************************************/
+/**********************************************************************************
+
+* Notice of Export Control Law
+===============================================
+* Huawei LiteOS may be subject to applicable export control laws and regulations, which
+* might include those applicable to Huawei LiteOS of U.S. and the country in which you
+* are located.
+* Import, export and usage of Huawei LiteOS in any manner by you shall be in compliance
+* with such applicable export control laws and regulations.
+***********************************************************************************/
+
+
+#define LWIP_STATIC static
+#define DHCP_STATE_OFF 0
+#define LWIP_EXT_POLL_SUPPORT 1
+
+#include "lwip/api.h"
+#include "lwip/netdb.h"
+#include "lwip/stats.h"
+#include "lwip/err.h"
+#include "lwip/ip_addr.h"
+#include "lwip/icmp.h"
+#include "los_config.h"
+#include <string.h>
+
+#include "shcmd.h"
+#include "shell.h"
+#include "los_debug.h"
+#include "los_task.h"
+
+/* Forward Declarations [START] */
+#ifndef LWIP_TESTBED
+LWIP_STATIC
+#endif
+int print_netif(struct netif *netif, char *print_buf, unsigned int buf_len);
+
+#ifndef LWIP_TESTBED
+LWIP_STATIC
+#endif
+void lwip_ifconfig_show_internal(void *arg);
+
+#if LWIP_DNS
+LWIP_STATIC unsigned int get_hostip(const char *hname);
+
+#ifndef LWIP_TESTBED
+LWIP_STATIC
+#endif
+struct hostent *gethostnameinfo(const char *host, char *tmphstbuf, size_t hstbuflen);
+#endif /* LWIP_DNS */
+
+#define PRINT_BUF_LEN 1024
+
+struct ifconfig_option {
+    char iface[IFNAMSIZ];
+    unsigned int option;
+    ip_addr_t ip_addr;
+    ip_addr_t netmask;
+    ip_addr_t gw;
+    unsigned char ethaddr[6];
+    u16_t mtu;
+    /* when using telnet, print to the telnet socket will result in system  */
+    /* deadlock. So we cahe the prinf data to a buf, and when the tcpip      */
+    /* callback returns, then print the data out to the telnet socket       */
+    sys_sem_t cb_completed;
+    char cb_print_buf[PRINT_BUF_LEN];
+    unsigned int print_len;
+};
+
+#ifndef LWIP_TESTBED
+LWIP_STATIC
+#endif
+int print_netif(struct netif *netif, char *print_buf, unsigned int buf_len)
+{
+    int i, ret;
+    char *tmp = print_buf;
+
+    if (buf_len < 1) {
+        goto out;
+    }
+    if(netif->link_layer_type == LOOPBACK_IF){
+      ret = snprintf_s(tmp, buf_len, (buf_len-1), "%s\t", netif->name);
+    } else {
+      ret = snprintf_s(tmp, buf_len, (buf_len-1), "%s%u\t", netif->name, netif->num);
+    }
+
+    if ((ret <= 0) || ((unsigned int)ret >= buf_len))
+        goto out;
+    tmp += ret;
+    buf_len -= (unsigned int)ret;
+#if LWIP_IPV4
+    ret = snprintf_s(tmp, buf_len, (buf_len - 1), "ip:%s ", ipaddr_ntoa(&netif->ip_addr));
+    if ((ret <= 0) || ((unsigned int)ret >= buf_len))
+        goto out;
+    tmp += ret;
+    buf_len -= (unsigned int)ret;
+
+    ret = snprintf_s(tmp, buf_len, (buf_len - 1), "netmask:%s ", ipaddr_ntoa(&netif->netmask));
+    if ((ret <= 0) || ((unsigned int)ret >= buf_len))
+        goto out;
+    tmp += ret;
+    buf_len -= (unsigned int)ret;
+
+    ret = snprintf_s(tmp, buf_len, (buf_len - 1), "gateway:%s\n", ipaddr_ntoa(&netif->gw));
+    if ((ret <= 0) || ((unsigned int)ret >= buf_len))
+        goto out;
+    tmp += ret;
+    buf_len -= (unsigned int)ret;
+#endif
+    ret = snprintf_s(tmp, buf_len, (buf_len - 1), "\tHWaddr ");
+    if ((ret <= 0) || ((unsigned int)ret >= buf_len))
+        goto out;
+    tmp += ret;
+    buf_len -= (unsigned int)ret;
+
+    for (i = 0; i < netif->hwaddr_len - 1; i++) {
+        ret = snprintf_s(tmp, buf_len, (buf_len - 1), "%02x:", netif->hwaddr[i]);
+        if ((ret <= 0) || ((unsigned int)ret >= buf_len))
+            goto out;
+        tmp += ret;
+        buf_len -= (unsigned int)ret;
+    }
+
+    ret = snprintf_s(tmp, buf_len, (buf_len - 1), "%02x", netif->hwaddr[i]);
+    if ((ret <= 0) || ((unsigned int)ret >= buf_len))
+        goto out;
+    tmp += ret;
+    buf_len -= (unsigned int)ret;
+
+    ret = snprintf_s(tmp, buf_len, (buf_len - 1), " MTU:%d %s", netif->mtu,
+                     netif->flags & NETIF_FLAG_UP ? "Running" : "Stop");
+    if ((ret <= 0) || ((unsigned int)ret >= buf_len))
+        goto out;
+    tmp += ret;
+    buf_len -= (unsigned int)ret;
+
+    if (netif_default == netif && netif_is_up(netif)) {
+        ret = snprintf_s(tmp, buf_len, (buf_len - 1), " %s", "Default");
+        if ((ret <= 0) || ((unsigned int)ret >= buf_len))
+            goto out;
+        tmp += ret;
+        buf_len -= (unsigned int)ret;
+    }
+
+    ret = snprintf_s(tmp, buf_len, (buf_len - 1), " %s\n", netif->flags & NETIF_FLAG_LINK_UP ? "Link UP" : "Link Down");
+    if ((ret <= 0) || ((unsigned int)ret >= buf_len))
+        goto out;
+    tmp += ret;
+
+out:
+    return (int)(tmp - print_buf);
+}
+
+#ifndef LWIP_TESTBED
+LWIP_STATIC
+#endif
+void lwip_ifconfig_show_internal(void *arg)
+{
+    struct netif *netif = NULL;
+    struct ifconfig_option *ifconfig_cmd = (struct ifconfig_option *)arg;
+    int ret;
+
+    if (netif_list == NULL) {
+        ret = snprintf_s(ifconfig_cmd->cb_print_buf, PRINT_BUF_LEN - ifconfig_cmd->print_len,
+                         ((PRINT_BUF_LEN - ifconfig_cmd->print_len) - 1), "Device not init\n");
+        if ((ret > 0) && ((unsigned int)ret < (PRINT_BUF_LEN - ifconfig_cmd->print_len))) {
+            ifconfig_cmd->print_len += (unsigned int)ret;
+        }
+        sys_sem_signal(&ifconfig_cmd->cb_completed);
+        return;
+    }
+
+    if (ifconfig_cmd->iface[0] == '\0') {
+        /* display all netif */
+        for (netif = netif_list; netif != NULL; netif = netif->next) {
+            ret = print_netif(netif, ifconfig_cmd->cb_print_buf + ifconfig_cmd->print_len,
+                              PRINT_BUF_LEN - ifconfig_cmd->print_len);
+            ifconfig_cmd->print_len += (unsigned int)ret;
+        }
+    } else {
+        netif = netif_find(ifconfig_cmd->iface);
+        if (netif == NULL) {
+            ret = snprintf_s(ifconfig_cmd->cb_print_buf + ifconfig_cmd->print_len,
+                             (PRINT_BUF_LEN - ifconfig_cmd->print_len),
+                             ((PRINT_BUF_LEN - ifconfig_cmd->print_len) - 1), "Device not found\n");
+            if ((ret > 0) && ((unsigned int)ret < (PRINT_BUF_LEN - ifconfig_cmd->print_len))) {
+                ifconfig_cmd->print_len += (unsigned int)ret;
+            }
+
+            sys_sem_signal(&ifconfig_cmd->cb_completed);
+            return;
+        }
+
+        ret = print_netif(netif, ifconfig_cmd->cb_print_buf + ifconfig_cmd->print_len,
+                          PRINT_BUF_LEN - ifconfig_cmd->print_len);
+        ifconfig_cmd->print_len += (unsigned int)ret;
+    }
+    sys_sem_signal(&ifconfig_cmd->cb_completed);
+}
+
+/*lint -e838 -e438*/
+u32_t lwip_ifconfig(int argc, const char **argv)
+{
+    static struct ifconfig_option ifconfig_cmd;
+    err_t ret;
+
+#if LWIP_STATS
+    u32_t stat_err_cnt;
+    u32_t stat_drop_cnt;
+    u32_t stat_rx_or_tx_cnt;
+    u32_t stat_rx_or_tx_bytes;
+#endif
+
+    (void)memset_s(&ifconfig_cmd, sizeof(ifconfig_cmd), 0, sizeof(ifconfig_cmd));
+    if (sys_sem_new(&ifconfig_cmd.cb_completed, 0) != ERR_OK) {
+        PRINTK("%s: sys_sem_new fail\n", __FUNCTION__);
+        return 1;
+    }
+
+    /* Get the interface */
+
+    /* no more arguments, show all the interface state. */
+    ret = tcpip_callback(lwip_ifconfig_show_internal, &ifconfig_cmd);
+    if (ret != ERR_OK) {
+        sys_sem_free(&ifconfig_cmd.cb_completed);
+        PRINTK("ifconfig : internal error, l:%d err:%d\n", __LINE__, ret);
+        return 1;
+    }
+    (void)sys_arch_sem_wait(&ifconfig_cmd.cb_completed, 0);
+    sys_sem_free(&ifconfig_cmd.cb_completed);
+    ifconfig_cmd.cb_print_buf[PRINT_BUF_LEN - 1] = '\0';
+    PRINTK("%s", ifconfig_cmd.cb_print_buf);
+
+    return 0;
+}
+/*lint +e838 +e438*/
+
+#if LWIP_DNS
+#ifndef LWIP_TESTBED
+LWIP_STATIC
+#endif
+struct hostent *gethostnameinfo(const char *host, char *tmphstbuf, size_t hstbuflen)
+{
+    static struct hostent hostbuf;
+    struct hostent *hp = NULL;
+    int res;
+    int herr;
+
+    if (tmphstbuf == NULL)
+        return NULL;
+    res = lwip_gethostbyname_r(host, &hostbuf, tmphstbuf, hstbuflen, &hp, &herr);
+    /*  Check for errors.  */
+    if (res || hp == NULL) {
+        return NULL;
+    }
+    return hp;
+}
+
+LWIP_STATIC unsigned int get_hostip(const char *hname)
+{
+    unsigned int ip = 0;
+    int ret;
+    const size_t hstbuflen = 1024;
+    char *tmphstbuf = NULL;
+
+    tmphstbuf = (char *)zalloc(sizeof(char) * hstbuflen);
+    if (tmphstbuf == NULL)
+        return 0;
+
+    struct hostent *pent = gethostnameinfo(hname, tmphstbuf, hstbuflen);
+    if (pent == NULL || pent->h_addr == NULL) {
+        free(tmphstbuf);
+        return 0;
+    }
+    ret = memcpy_s(&ip, sizeof(ip), pent->h_addr, 4);
+    if (ret != 0) {
+        free(tmphstbuf);
+        return 0;
+    }
+    free(tmphstbuf);
+    return ip;
+}
+
+#endif
+
+static int ping_taskid = -1;
+static int ping_kill = 0;
+#define LWIP_SHELL_CMD_PING_TIMEOUT 2000
+#define LWIP_SHELL_CMD_PING_RETRY_TIMES 4
+#define PING_ZERO_DATA_LEN 8
+
+static void lwip_ping_usage(void)
+{
+    PRINTK("Usage:\n  ping [ip]\n");
+}
+
+LWIP_STATIC int OsPingFunc(u32_t *parg)
+{
+    int sfd;
+    struct sockaddr_in to;
+    struct pbuf *pbuf_resp = NULL;
+    struct icmp_echo_hdr *iecho = NULL;
+    struct icmp_echo_hdr *iecho_resp = NULL;
+    struct ip_hdr *iphdr_resp = NULL;
+    u32_t iecho_len;
+    s16_t ip_hlen;
+    u32_t forever;
+    u32_t i = 0;
+    u32_t succ_cnt = 0;
+    u32_t failed_cnt = 0;
+    struct timespec start, end;
+    long timout_ms = 0;
+    struct pollfd pfd;
+    long rtt;
+    int ret = 0;
+    u32_t intrvl;
+    char *data_buf = NULL;
+    BOOL timeout_flag = false;
+    char buf[50];
+
+    u32_t destip = parg[0];
+    u32_t cnt = parg[1];
+    u32_t interval = parg[2];
+    u32_t data_len = parg[3];
+
+    iecho_len = sizeof(struct icmp_echo_hdr) + data_len;
+    sfd = lwip_socket(PF_INET, SOCK_RAW, IPPROTO_ICMP);
+    if (sfd < 0) {
+        perror("Ping socket");
+        return -1;
+    }
+    pbuf_resp = pbuf_alloc(PBUF_RAW, IP_HLEN + sizeof(struct icmp_echo_hdr), PBUF_RAM);
+    if (pbuf_resp == NULL) {
+        PRINTK("Ping: pbuf_resp malloc failed\n");
+        ret = -1;
+        goto FAILURE;
+    }
+    iecho = (struct icmp_echo_hdr *)mem_malloc(iecho_len);
+    if (iecho == NULL) {
+        PRINTK("Ping: echo request malloc failed\n");
+        ret = -1;
+        goto FAILURE;
+    }
+
+    to.sin_family = AF_INET;
+    to.sin_addr.s_addr = destip; /* already in network order */
+    to.sin_port = 0;
+
+    if (data_len > PING_ZERO_DATA_LEN) {
+        (void)memset_s(iecho, sizeof(struct icmp_echo_hdr) + PING_ZERO_DATA_LEN,
+                       0, sizeof(struct icmp_echo_hdr) + PING_ZERO_DATA_LEN);
+        data_buf = (char *)iecho + sizeof(struct icmp_echo_hdr) + PING_ZERO_DATA_LEN;
+        for (i = 0; i < data_len - PING_ZERO_DATA_LEN; i++) {
+            *(data_buf + i) = i + 0x10;
+        }
+    } else {
+        (void)memset_s(iecho, sizeof(struct icmp_echo_hdr) + data_len, 0, sizeof(struct icmp_echo_hdr) + data_len);
+    }
+    iecho->id = htons((u16_t)LOS_CurTaskIDGet());
+    ICMPH_TYPE_SET(iecho, (u8_t)ICMP_ECHO);
+    forever = (cnt ? 0 : 1);
+    i = 0;
+    while (!ping_kill && (forever || (i < cnt))) {
+        iecho->seqno = htons((u16_t)i);
+        iecho->chksum = 0;
+        iecho->chksum = inet_chksum((void *)iecho, iecho_len);
+
+        ret = sendto(sfd, iecho, iecho_len, 0, (struct sockaddr *)&to, (socklen_t)sizeof(to));
+        if (ret < 0) {
+            perror("Ping: sending ICMP echo request failed\n");
+            goto FAILURE;
+        }
+
+        /* capture the start time to calculate RTT */
+        (void)clock_gettime(CLOCK_MONOTONIC_RAW, &start);
+
+        /* poll for ICMP echo response msg */
+        pfd.fd = sfd;
+
+        do {
+            pfd.events = POLLIN;
+            pfd.revents = 0;
+            timeout_flag = false;
+            ret = poll(&pfd, 1, LWIP_SHELL_CMD_PING_TIMEOUT);
+            if (ret < 0) {
+                perror("Ping: poll\n");
+                goto FAILURE;
+            } else if (ret == 0) {
+                /* first type timeout event */
+                timeout_flag = true;
+                break;
+            }
+
+            ret = recv(sfd, pbuf_resp->payload, pbuf_resp->len, MSG_DONTWAIT);
+            if (ret < 0) {
+                perror("Ping: recv echo reply failed\n");
+                goto FAILURE;
+            }
+
+            /* Accessing ip header and icmp header */
+            iphdr_resp = pbuf_resp->payload;
+
+            ip_hlen = (IPH_HL(iphdr_resp) << 2);
+            if (pbuf_header(pbuf_resp, -ip_hlen)) {
+                /* this failure will never happen, but failure handle is written just to be in safe side */
+                PRINTK("Ping : memory management failure\n");
+                goto FAILURE;
+            }
+            iecho_resp = (struct icmp_echo_hdr *)pbuf_resp->payload;
+            /* Reverting back pbuf to its original state */
+            if (pbuf_header(pbuf_resp, ip_hlen)) {
+                /* this failure will never happen, but failure handle is written just to be in safe side */
+                PRINTK("ping : memory management failure\n");
+                goto FAILURE;
+            }
+
+            if ((iphdr_resp->src.addr != to.sin_addr.s_addr) ||
+                ((ICMPH_TYPE(iecho_resp) == ICMP_ECHO) && (iphdr_resp->src.addr == to.sin_addr.s_addr))) {
+                /* second type timeout event */
+                (void)clock_gettime(CLOCK_MONOTONIC_RAW, &end);
+                timout_ms = ((end.tv_sec - start.tv_sec) * 1000 + (end.tv_nsec - start.tv_nsec) / 1000000);
+                timout_ms = LWIP_SHELL_CMD_PING_TIMEOUT - timout_ms;
+            } else {
+                timout_ms = 0;
+                break;
+            }
+        } while (timout_ms >= 0);
+
+        /* all timeout events are true timeout */
+        if ((timout_ms < 0) || (timeout_flag == true)) {
+            failed_cnt++;
+            i++;
+            PRINTK("\nPing: destination unreachable ...");
+            continue;
+        }
+        /* capture the end time to calculate round trip time */
+        (void)clock_gettime(CLOCK_MONOTONIC_RAW, &end);
+        rtt = ((end.tv_sec - start.tv_sec) * 1000 + (end.tv_nsec - start.tv_nsec) / 1000000);
+
+        if (iphdr_resp->src.addr == to.sin_addr.s_addr) {
+            switch (ICMPH_TYPE(iecho_resp)) {
+                case ICMP_ER:
+                    PRINTK("\n[%u]Reply from %s: ", i, inet_ntop(AF_INET, &to.sin_addr, buf, sizeof(buf)));
+                    if (rtt > 0) {
+                        PRINTK("time=%ims ", rtt);
+                    } else {
+                        PRINTK("time<1ms ");
+                    }
+                    PRINTK("TTL=%u", iphdr_resp->_ttl);
+
+                    /* delay 1s for every successful ping */
+                    intrvl = interval;
+                    do {
+                        if (intrvl < 1000) {
+                            sys_msleep(intrvl);
+                            break;
+                        }
+                        intrvl -= 1000;
+                        sys_msleep(1000);
+                        if (ping_kill == 1)
+                            break;
+                    } while (intrvl > 0);
+                    succ_cnt++;
+                    break;
+                case ICMP_DUR:
+                    PRINTK("\nPing: destination host unreachable ...");
+                    break;
+                case ICMP_SQ:
+                    PRINTK("\nPing: source quench ...");
+                    break;
+                case ICMP_RD:
+                    PRINTK("\nPing: redirect ...");
+                    break;
+                case ICMP_TE:
+                    PRINTK("\nPing: time exceeded ...");
+                    break;
+                case ICMP_PP:
+                    PRINTK("\nPing: parameter problem ...");
+                    break;
+                default:
+                    PRINTK("\nPing: unknow error ...");
+                    break;
+            }
+            i++;
+        }
+    }
+
+    PRINTK("\n--- %s ping statistics ---\n", inet_ntop(AF_INET, &to.sin_addr, buf, sizeof(buf)));
+    PRINTK("%u packets transmitted, %u received, %u loss\n", i, succ_cnt, failed_cnt);
+
+FAILURE:
+    ping_kill = 0;
+    (void)lwip_close(sfd);
+    if (pbuf_resp != NULL) {
+        (void)pbuf_free(pbuf_resp);
+    }
+    if (iecho != NULL) {
+        mem_free(iecho);
+    }
+    return ret;
+}
+
+static void ping_cmd(u32_t *parg)
+{
+    int ret;
+
+    ret = OsPingFunc(parg);
+    if (ret < 0) {
+        PRINTK("Ping cmd failed due to some errors\n");
+    }
+
+    ping_taskid = -1;
+}
+
+u32_t OsShellPing(int argc, const char **argv)
+{
+    int ret;
+    u32_t i = 0;
+    u32_t count = 0;
+    int count_set = 0;
+    u32_t interval = 1000; /* default ping interval */
+    u32_t data_len = 48; /* default data length */
+    ip4_addr_t dst_ipaddr;
+    TSK_INIT_PARAM_S stPingTask;
+    u32_t *parg = NULL;
+
+    if ((argc < 1) || (argv == NULL)) {
+        PRINTK("Ping: require dest ipaddr at least\n");
+        goto ping_error;
+    }
+
+    if (!count_set) {
+        count = LWIP_SHELL_CMD_PING_RETRY_TIMES;
+    }
+
+    /* initialize dst IP address */
+    if (argc <= 0) {
+        goto ping_error;
+    }
+#if LWIP_DNS
+    dst_ipaddr.addr = get_hostip(argv[i]);
+#endif /* LWIP_DNS */
+
+    if (dst_ipaddr.addr == IPADDR_NONE || dst_ipaddr.addr == IPADDR_ANY) {
+        PRINTK("Invalid dest ipaddr: NONE or ANY\n");
+        return LOS_NOK;
+    }
+
+    parg = (u32_t *)malloc(4 * sizeof(int));
+    if (parg == NULL) {
+        return LOS_NOK;
+    }
+    parg[0] = dst_ipaddr.addr;
+    parg[1] = count;
+    parg[2] = interval;
+    parg[3] = data_len;
+
+    /* start one task if ping forever or ping count greater than 60 */
+    if (count == 0 || count > LWIP_SHELL_CMD_PING_RETRY_TIMES) {
+        if (ping_taskid > 0) {
+            free(parg);
+            PRINTK("Ping task already running and only support one now\n");
+            return LOS_NOK;
+        }
+        stPingTask.pfnTaskEntry = (TSK_ENTRY_FUNC)ping_cmd;
+        stPingTask.uwStackSize = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
+        stPingTask.pcName = "ping_task";
+        stPingTask.usTaskPrio = 8; /* higher than shell */
+        stPingTask.uwResved = LOS_TASK_STATUS_DETACHED;
+        stPingTask.uwArg = (UINTPTR)parg;
+        ret = LOS_TaskCreate((UINT32 *)(&ping_taskid), &stPingTask);
+        if (ret != LOS_OK) {
+            free(parg);
+            PRINTK("ping_task create failed 0x%08x.\n", ret);
+            count = LWIP_SHELL_CMD_PING_RETRY_TIMES;
+        } else {
+            return LOS_OK;
+        }
+    }
+
+    /* two cases:
+     1, ping cout less than LWIP_SHELL_CMD_PING_RETRY_TIMES;
+     2, ping task create failed;
+    */
+    if (OsPingFunc(parg) < 0) {
+        PRINTK("Ping cmd failed due some errors\n");
+    }
+
+    return LOS_OK;
+ping_error:
+    lwip_ping_usage();
+    return LOS_NOK;
+}
+
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/src/netdb_porting.c b/kernel/liteos_m/components/net/lwip-2.1/porting/src/netdb_porting.c
index df905f7..292e051 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/src/netdb_porting.c
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/src/netdb_porting.c
@@ -29,7 +29,9 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "netdb.h"
+#include "lwip/netdb.h"
+
+#if LWIP_DNS && LWIP_SOCKET
 
 struct hostent *gethostbyname(const char *name)
 {
@@ -37,4 +39,23 @@ struct hostent *gethostbyname(const char *name)
         return NULL;
     }
     return lwip_gethostbyname(name);
-}
\ No newline at end of file
+}
+
+int gethostbyname_r(const char *name, struct hostent *ret, char *buf, size_t buflen, struct hostent **result,
+    int *h_errnop)
+{
+    return lwip_gethostbyname_r(name, ret, buf, buflen, result, h_errnop);
+}
+
+void freeaddrinfo(struct addrinfo *res)
+{
+    lwip_freeaddrinfo(res);
+}
+
+int getaddrinfo(const char *restrict nodename, const char *restrict servname, const struct addrinfo *restrict hints,
+    struct addrinfo **restrict res)
+{
+    return lwip_getaddrinfo(nodename, servname, hints, res);
+}
+
+#endif
\ No newline at end of file
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/src/sockets_porting.c b/kernel/liteos_m/components/net/lwip-2.1/porting/src/sockets_porting.c
index 32deb8f..bcecdf9 100644
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/src/sockets_porting.c
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/src/sockets_porting.c
@@ -33,6 +33,7 @@
 #include <lwip/sockets.h>
 
 #if !LWIP_COMPAT_SOCKETS
+#if LWIP_SOCKET
 
 #define CHECK_NULL_PTR(ptr) do { if ((ptr) == NULL) { set_errno(EFAULT); return -1; } } while (0)
 
@@ -178,4 +179,10 @@ int poll(struct pollfd *fds, nfds_t nfds, int timeout)
 }
 #endif
 
+unsigned int if_nametoindex(const char *ifname)
+{
+    return lwip_if_nametoindex(ifname);
+}
+
+#endif
 #endif /* !LWIP_COMPAT_SOCKETS */
\ No newline at end of file
diff --git a/kernel/liteos_m/components/net/lwip-2.1/porting/src/sys_arch.c b/kernel/liteos_m/components/net/lwip-2.1/porting/src/sys_arch.c
old mode 100755
new mode 100644
index f0c332d..832e430
--- a/kernel/liteos_m/components/net/lwip-2.1/porting/src/sys_arch.c
+++ b/kernel/liteos_m/components/net/lwip-2.1/porting/src/sys_arch.c
@@ -38,7 +38,7 @@
 #include <los_sem.h>
 #include <los_mux.h>
 #include "cmsis_os2.h"
-#include <los_timer.h>
+#include <los_tick.h>
 #include <los_config.h>
 
 #ifndef LOSCFG_KERNEL_SMP
@@ -82,8 +82,7 @@ sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg,
 void sys_init(void)
 {
     /* set rand seed to make random sequence diff on every startup */
-    UINT32 seedhsb, seedlsb;
-    HalGetCpuCycle(&seedhsb, &seedlsb);
+    UINT32 seedlsb = (UINT32)LOS_SysCycleGet();
     srand(seedlsb);
 }
 
@@ -181,7 +180,10 @@ err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
     return ERR_ARG;
 }
 
-err_t sys_mbox_trypost_fromisr(sys_mbox_t *mbox, void *msg);
+err_t sys_mbox_trypost_fromisr(sys_mbox_t *mbox, void *msg)
+{
+    return ERR_ARG;
+}
 
 u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeoutMs)
 {
diff --git a/kernel/liteos_m/components/power/BUILD.gn b/kernel/liteos_m/components/power/BUILD.gn
new file mode 100644
index 0000000..70b88ae
--- /dev/null
+++ b/kernel/liteos_m/components/power/BUILD.gn
@@ -0,0 +1,39 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("pm") {
+  sources = [ "los_pm.c" ]
+
+  include_dirs = [
+    "../../kernel/include",
+    "../../kernel/arch/include",
+    "../../utils",
+    "//third_party/bounds_checking_function/include",
+  ]
+}
diff --git a/kernel/liteos_m/components/power/los_pm.c b/kernel/liteos_m/components/power/los_pm.c
new file mode 100644
index 0000000..a94b813
--- /dev/null
+++ b/kernel/liteos_m/components/power/los_pm.c
@@ -0,0 +1,665 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_pm.h"
+#include "securec.h"
+#include "los_sched.h"
+#include "los_timer.h"
+#include "los_memory.h"
+
+#if (LOSCFG_KERNEL_PM == 1)
+#define OS_PM_NODE_FREE 0x80000000U
+#define OS_PM_LOCK_MAX  0xFFFFU
+
+typedef VOID (*Suspend)(LOS_SysSleepEnum sleep);
+
+#if (LOSCFG_KERNEL_PM_DEBUG == 1)
+typedef struct {
+    CHAR         *name;
+    UINT32       count;
+    LOS_DL_LIST  list;
+} OsPmLockCB;
+#endif
+
+typedef struct {
+    LOS_SysSleepEnum  pmMode;
+    LOS_SysSleepEnum  sysMode;
+    UINT16            lock;
+    BOOL              isWake;
+    LosPmDevice       *device;
+    LosPmSysctrl      *sysctrl;
+    LosPmTickTimer    *tickTimer;
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)
+    UINT64            enterSleepTime;
+#endif
+#if (LOSCFG_KERNEL_PM_DEBUG == 1)
+    LOS_DL_LIST       lockList;
+#endif
+} LosPmCB;
+
+STATIC LosPmCB g_pmCB;
+STATIC LosPmSysctrl *g_sysctrl = NULL;
+STATIC UINT64 g_pmSleepTime;
+
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)
+STATIC VOID OsPmTickTimerStart(LosPmCB *pm)
+{
+    UINT32 intSave;
+    UINT64 currTime, sleepTime, realSleepTime;
+    LosPmTickTimer *tickTimer = pm->tickTimer;
+
+    intSave = LOS_IntLock();
+    /* Restore the main CPU frequency */
+    sleepTime = tickTimer->timerCycleGet();
+    tickTimer->timerStop();
+
+    realSleepTime = OS_SYS_CYCLE_TO_NS(sleepTime, tickTimer->freq);
+    realSleepTime = OS_SYS_NS_TO_CYCLE(realSleepTime, OS_SYS_CLOCK);
+    currTime = pm->enterSleepTime + realSleepTime;
+    pm->enterSleepTime = 0;
+
+    OsSchedTimerBaseReset(currTime);
+    OsSchedUpdateExpireTime(currTime, FALSE);
+    tickTimer->tickUnlock();
+    LOS_IntRestore(intSave);
+    return;
+}
+
+STATIC VOID OsPmTickTimerStop(LosPmCB *pm)
+{
+    UINT64 sleepCycle;
+    UINT64 realSleepTime = g_pmSleepTime;
+    LosPmTickTimer *tickTimer = pm->tickTimer;
+
+    if (realSleepTime == 0) {
+        return;
+    }
+
+    sleepCycle = OS_SYS_CYCLE_TO_NS(realSleepTime, OS_SYS_CLOCK);
+    sleepCycle = OS_SYS_NS_TO_CYCLE(sleepCycle, tickTimer->freq);
+
+    /* The main CPU reduces the frequency */
+    pm->enterSleepTime = OsGetCurrSchedTimeCycle();
+    tickTimer->tickLock();
+    tickTimer->timerStart(sleepCycle);
+    return;
+}
+#endif
+
+STATIC VOID OsPmTickTimerResume(LosPmCB *pm)
+{
+    if ((pm->sysMode == LOS_SYS_DEEP_SLEEP) && (pm->tickTimer->tickUnlock != NULL)) {
+        pm->tickTimer->tickUnlock();
+    } else {
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)
+        /* Sys tick timer is restored from low power mode */
+        if (pm->enterSleepTime != 0) {
+            OsPmTickTimerStart(pm);
+        }
+#endif
+    }
+}
+
+STATIC VOID OsPmCpuResume(LosPmCB *pm)
+{
+    if ((pm->sysMode == LOS_SYS_NORMAL_SLEEP) && (pm->sysctrl->normalResume != NULL)) {
+        pm->sysctrl->normalResume();
+    } else if ((pm->sysMode == LOS_SYS_LIGHT_SLEEP) && (pm->sysctrl->lightResume != NULL)) {
+        pm->sysctrl->lightResume();
+    } else if ((pm->sysMode == LOS_SYS_DEEP_SLEEP) && (pm->sysctrl->deepResume != NULL)) {
+        pm->sysctrl->deepResume();
+    }
+}
+
+STATIC Suspend OsPmCpuSuspend(LosPmCB *pm)
+{
+    Suspend sysSuspend = NULL;
+
+    /* cpu enter low power mode */
+    LOS_ASSERT(pm->sysctrl != NULL);
+
+    if (pm->sysMode == LOS_SYS_NORMAL_SLEEP) {
+        sysSuspend = pm->sysctrl->normalSuspend;
+    } else if (pm->sysMode == LOS_SYS_LIGHT_SLEEP) {
+        sysSuspend = pm->sysctrl->lightSuspend;
+    } else if (pm->sysMode == LOS_SYS_DEEP_SLEEP) {
+        sysSuspend = pm->sysctrl->deepSuspend;
+    } else {
+        sysSuspend = pm->sysctrl->shutdownSuspend;
+    }
+
+    LOS_ASSERT(sysSuspend != NULL);
+
+    return sysSuspend;
+}
+
+STATIC VOID OsPmTickTimerSuspend(LosPmCB *pm)
+{
+    if (((pm->sysMode == LOS_SYS_DEEP_SLEEP) || (pm->sysMode == LOS_SYS_SHUTDOWN)) &&
+        (pm->tickTimer->tickLock != NULL)) {
+        pm->tickTimer->tickLock();
+    } else {
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)
+        /* Sys tick timer enter low power mode */
+        if (pm->tickTimer == NULL) {
+            return;
+        }
+
+        if ((pm->tickTimer->timerStart != NULL) &&
+            (pm->tickTimer->timerStop != NULL) &&
+            (pm->tickTimer->timerCycleGet == NULL) &&
+            (pm->tickTimer->freq != 0)) {
+            OsPmTickTimerStop(pm);
+        }
+#endif
+    }
+}
+
+STATIC VOID OsPmEnter(BOOL isIdle)
+{
+    UINT32 ret;
+    UINT32 intSave;
+    Suspend sysSuspend = NULL;
+    LosPmCB *pm = &g_pmCB;
+    BOOL isTaskLock = FALSE;
+
+	bk_printf("[wzl]OsPmEnter:%d\r\n", isIdle);
+
+    intSave = LOS_IntLock();
+    pm->sysMode = pm->pmMode;
+    if (isIdle) {
+        if ((pm->sysMode != LOS_SYS_NORMAL_SLEEP) && (pm->sysMode != LOS_SYS_LIGHT_SLEEP)) {
+            pm->sysMode = LOS_SYS_NORMAL_SLEEP;
+        }
+    } else {
+        if ((pm->sysMode != LOS_SYS_DEEP_SLEEP) && (pm->sysMode != LOS_SYS_SHUTDOWN)) {
+            LOS_IntRestore(intSave);
+            return;
+        }
+    }
+
+    if ((pm->sysMode == LOS_SYS_NORMAL_SLEEP) || (pm->sysMode == LOS_SYS_LIGHT_SLEEP)) {
+        if (pm->lock > 0) {
+            pm->sysMode = LOS_SYS_NORMAL_SLEEP;
+        }
+    } else if (pm->lock > 0) {
+        LOS_IntRestore(intSave);
+        return;
+    }
+
+    if (pm->sysMode != LOS_SYS_NORMAL_SLEEP) {
+        pm->isWake = FALSE;
+        LOS_TaskLock();
+        isTaskLock = TRUE;
+
+        ret = pm->device->suspend((UINT32)pm->sysMode);
+        if (ret != LOS_OK) {
+            goto EXIT;
+        }
+    }
+
+    OsPmTickTimerSuspend(pm);
+
+    sysSuspend = OsPmCpuSuspend(pm);
+    LOS_IntRestore(intSave);
+
+    if (!isTaskLock || (isTaskLock && !pm->isWake)) {
+        (VOID)sysSuspend(0);
+    }
+
+    intSave = LOS_IntLock();
+
+    OsPmCpuResume(pm);
+
+    OsPmTickTimerResume(pm);
+
+    if (pm->sysMode != LOS_SYS_NORMAL_SLEEP) {
+        pm->device->resume((UINT32)pm->sysMode);
+    }
+
+    if (pm->pmMode == LOS_SYS_DEEP_SLEEP) {
+        pm->pmMode = LOS_SYS_NORMAL_SLEEP;
+    }
+
+EXIT:
+    LOS_IntRestore(intSave);
+
+    if (isTaskLock) {
+        LOS_TaskUnlock();
+    }
+    return;
+}
+
+STATIC VOID OsPmTask(VOID)
+{
+    OsPmEnter(FALSE);
+}
+
+STATIC UINT32 OsPmDeviceRegister(LosPmCB *pm, LosPmDevice *device)
+{
+    UINT32 intSave;
+
+    if ((device->suspend == NULL) || (device->resume == NULL)) {
+        return LOS_ERRNO_PM_INVALID_PARAM;
+    }
+
+    intSave = LOS_IntLock();
+    pm->device = device;
+    LOS_IntRestore(intSave);
+
+    return LOS_OK;
+}
+
+STATIC UINT32 OsPmTickTimerRegister(LosPmCB *pm, LosPmTickTimer *tickTimer)
+{
+    UINT32 intSave;
+
+    intSave = LOS_IntLock();
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)
+    pm->enterSleepTime = 0;
+#endif
+    pm->tickTimer = tickTimer;
+    LOS_IntRestore(intSave);
+    return LOS_OK;
+}
+
+STATIC UINT32 OsPmSysctrlRegister(LosPmCB *pm, LosPmSysctrl *sysctrl)
+{
+    UINT32 intSave;
+
+    if (sysctrl->normalSuspend == NULL) {
+        return LOS_ERRNO_PM_INVALID_PARAM;
+    }
+
+    intSave = LOS_IntLock();
+    pm->sysctrl = sysctrl;
+    LOS_IntRestore(intSave);
+
+    return LOS_OK;
+}
+
+UINT32 LOS_PmRegister(LOS_PmNodeType type, VOID *node)
+{
+    LosPmCB *pm = &g_pmCB;
+
+    if (node == NULL) {
+        return LOS_ERRNO_PM_INVALID_PARAM;
+    }
+
+    switch (type) {
+        case LOS_PM_TYPE_DEVICE:
+            return OsPmDeviceRegister(pm, (LosPmDevice *)node);
+        case LOS_PM_TYPE_TICK_TIMER:
+            return OsPmTickTimerRegister(pm, (LosPmTickTimer *)node);
+        case LOS_PM_TYPE_SYSCTRL:
+            return OsPmSysctrlRegister(pm, (LosPmSysctrl *)node);
+        default:
+            break;
+    }
+
+    return LOS_ERRNO_PM_INVALID_TYPE;
+}
+
+STATIC UINT32 OsPmDeviceUnregister(LosPmCB *pm, LosPmDevice *device)
+{
+    UINT32 intSave;
+
+    intSave = LOS_IntLock();
+    if (pm->device == device) {
+        pm->device = NULL;
+        pm->pmMode = LOS_SYS_NORMAL_SLEEP;
+        LOS_IntRestore(intSave);
+        return LOS_OK;
+    }
+
+    LOS_IntRestore(intSave);
+    return LOS_ERRNO_PM_INVALID_NODE;
+}
+
+STATIC UINT32 OsPmTickTimerUnregister(LosPmCB *pm, LosPmTickTimer *tickTimer)
+{
+    UINT32 intSave;
+
+    intSave = LOS_IntLock();
+    if (pm->tickTimer == tickTimer) {
+        pm->tickTimer = NULL;
+        if ((pm->pmMode != LOS_SYS_NORMAL_SLEEP) && (pm->pmMode != LOS_SYS_LIGHT_SLEEP)) {
+            pm->pmMode = LOS_SYS_NORMAL_SLEEP;
+        }
+        LOS_IntRestore(intSave);
+        return LOS_OK;
+    }
+
+    LOS_IntRestore(intSave);
+    return LOS_ERRNO_PM_INVALID_NODE;
+}
+
+STATIC UINT32 OsPmSysctrlUnregister(LosPmCB *pm, LosPmSysctrl *sysctrl)
+{
+    UINT32 intSave;
+    VOID *freeNode = NULL;
+
+    intSave = LOS_IntLock();
+    if (pm->sysctrl == sysctrl) {
+        if (pm->sysctrl == g_sysctrl) {
+            freeNode = (VOID *)pm->sysctrl;
+            g_sysctrl = NULL;
+        }
+
+        pm->sysctrl = NULL;
+        LOS_IntRestore(intSave);
+
+        if (freeNode != NULL) {
+            (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, freeNode);
+        }
+        return LOS_OK;
+    }
+
+    LOS_IntRestore(intSave);
+    return LOS_ERRNO_PM_INVALID_NODE;
+}
+
+UINT32 LOS_PmUnregister(LOS_PmNodeType type, VOID *node)
+{
+    LosPmCB *pm = &g_pmCB;
+
+    if (node == NULL) {
+        return LOS_ERRNO_PM_INVALID_PARAM;
+    }
+
+    switch (type) {
+        case LOS_PM_TYPE_DEVICE:
+            return OsPmDeviceUnregister(pm, (LosPmDevice *)node);
+        case LOS_PM_TYPE_TICK_TIMER:
+            return OsPmTickTimerUnregister(pm, (LosPmTickTimer *)node);
+        case LOS_PM_TYPE_SYSCTRL:
+            return OsPmSysctrlUnregister(pm, (LosPmSysctrl *)node);
+        default:
+            break;
+    }
+
+    return LOS_ERRNO_PM_INVALID_TYPE;
+}
+
+VOID LOS_PmWakeSet(VOID)
+{
+    UINT32 intSave;
+    LosPmCB *pm = &g_pmCB;
+
+    intSave = LOS_IntLock();
+    pm->isWake = TRUE;
+    LOS_IntRestore(intSave);
+    return;
+}
+
+LOS_SysSleepEnum LOS_PmModeGet(VOID)
+{
+    LOS_SysSleepEnum mode;
+    LosPmCB *pm = &g_pmCB;
+
+    UINT32 intSave = LOS_IntLock();
+    mode = pm->pmMode;
+    LOS_IntRestore(intSave);
+
+    return mode;
+}
+
+UINT32 LOS_PmModeSet(LOS_SysSleepEnum mode)
+{
+    UINT32 intSave;
+    UINT32 taskID;
+    UINT32 ret;
+    LosPmCB *pm = &g_pmCB;
+    INT32 sleepMode = (INT32)mode;
+    TSK_INIT_PARAM_S taskInitParam = { 0 };
+
+    if ((sleepMode < 0) || (sleepMode > LOS_SYS_SHUTDOWN)) {
+        return LOS_ERRNO_PM_INVALID_MODE;
+    }
+
+    intSave = LOS_IntLock();
+    if ((mode != LOS_SYS_NORMAL_SLEEP) && (pm->device == NULL)) {
+        LOS_IntRestore(intSave);
+        return LOS_ERRNO_PM_DEVICE_NULL;
+    }
+
+    if ((mode == LOS_SYS_LIGHT_SLEEP) && (pm->sysctrl->lightSuspend == NULL)) {
+        LOS_IntRestore(intSave);
+        return LOS_ERRNO_PM_HANDLER_NULL;
+    }
+
+    if ((mode == LOS_SYS_DEEP_SLEEP) && (pm->sysctrl->deepSuspend == NULL)) {
+        LOS_IntRestore(intSave);
+        return LOS_ERRNO_PM_HANDLER_NULL;
+    }
+
+    if ((mode == LOS_SYS_SHUTDOWN) && (pm->sysctrl->shutdownSuspend == NULL)) {
+        LOS_IntRestore(intSave);
+        return LOS_ERRNO_PM_HANDLER_NULL;
+    }
+
+    if ((mode == LOS_SYS_DEEP_SLEEP) || (mode == LOS_SYS_SHUTDOWN)) {
+        if ((pm->tickTimer == NULL) ||
+            (pm->tickTimer->tickLock == NULL) ||
+            (pm->tickTimer->tickUnlock == NULL)) {
+            LOS_IntRestore(intSave);
+            return LOS_ERRNO_PM_TICK_TIMER_NULL;
+        }
+    }
+
+    pm->pmMode = mode;
+    LOS_IntRestore(intSave);
+
+    if ((mode == LOS_SYS_DEEP_SLEEP) || (mode == LOS_SYS_SHUTDOWN)) {
+        taskInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)OsPmTask;
+        taskInitParam.uwStackSize = LOSCFG_KERNEL_PM_TASK_STACKSIZE;
+        taskInitParam.pcName = "pm";
+        taskInitParam.usTaskPrio = LOSCFG_KERNEL_PM_TASK_PTIORITY;
+        ret = LOS_TaskCreate(&taskID, &taskInitParam);
+        if (ret != LOS_OK) {
+            return ret;
+        }
+    }
+
+    return LOS_OK;
+}
+
+#if (LOSCFG_KERNEL_PM_DEBUG == 1)
+VOID LOS_PmLockInfoShow(VOID)
+{
+    UINT32 intSave;
+    LosPmCB *pm = &g_pmCB;
+    OsPmLockCB *lock = NULL;
+    LOS_DL_LIST *head = &pm->lockList;
+    LOS_DL_LIST *list = head->pstNext;
+
+    PRINTK("Name                          Count\n\r");
+
+    intSave = LOS_IntLock();
+    while (list != head) {
+        lock = LOS_DL_LIST_ENTRY(list, OsPmLockCB, list);
+        PRINTK("%-30s%5u\n\r", lock->name, lock->count);
+        list = list->pstNext;
+    }
+    LOS_IntRestore(intSave);
+
+    return;
+}
+#endif
+
+UINT32 LOS_PmLockRequest(const CHAR *name)
+{
+    UINT32 intSave;
+    UINT32 ret = LOS_ERRNO_PM_NOT_LOCK;
+    LosPmCB *pm = &g_pmCB;
+#if (LOSCFG_KERNEL_PM_DEBUG == 1)
+    OsPmLockCB *listNode = NULL;
+    OsPmLockCB *lock = NULL;
+    LOS_DL_LIST *head = &pm->lockList;
+    LOS_DL_LIST *list = head->pstNext;
+
+    if (name == NULL) {
+        return LOS_ERRNO_PM_INVALID_PARAM;
+    }
+#endif
+
+    intSave = LOS_IntLock();
+#if (LOSCFG_KERNEL_PM_DEBUG == 1)
+    while (list != head) {
+        listNode = LOS_DL_LIST_ENTRY(list, OsPmLockCB, list);
+        if (strcmp(name, listNode->name) == 0) {
+            lock = listNode;
+            break;
+        }
+
+        list = list->pstNext;
+    }
+
+    if (lock == NULL) {
+        lock = LOS_MemAlloc((VOID *)OS_SYS_MEM_ADDR, sizeof(OsPmLockCB));
+        if (lock == NULL) {
+            LOS_IntRestore(intSave);
+            return LOS_NOK;
+        }
+        lock->name = (CHAR *)name;
+        lock->count = 1;
+        LOS_ListTailInsert(head, &lock->list);
+    } else if (lock->count < OS_PM_LOCK_MAX) {
+        lock->count++;
+    }
+#endif
+
+    if (pm->lock < OS_PM_LOCK_MAX) {
+        pm->lock++;
+        ret = LOS_OK;
+    }
+
+    LOS_IntRestore(intSave);
+    return ret;
+}
+
+UINT32 LOS_PmLockRelease(const CHAR *name)
+{
+    UINT32 intSave;
+    UINT32 ret = LOS_ERRNO_PM_NOT_LOCK;
+    LosPmCB *pm = &g_pmCB;
+#if (LOSCFG_KERNEL_PM_DEBUG == 1)
+    OsPmLockCB *lock = NULL;
+    OsPmLockCB *listNode = NULL;
+    LOS_DL_LIST *head = &pm->lockList;
+    LOS_DL_LIST *list = head->pstNext;
+    VOID *lockFree = NULL;
+
+    if (name == NULL) {
+        return LOS_ERRNO_PM_INVALID_PARAM;
+    }
+#endif
+
+    intSave = LOS_IntLock();
+#if (LOSCFG_KERNEL_PM_DEBUG == 1)
+    while (list != head) {
+        listNode = LOS_DL_LIST_ENTRY(list, OsPmLockCB, list);
+        if (strcmp(name, listNode->name) == 0) {
+            lock = listNode;
+            break;
+        }
+
+        list = list->pstNext;
+    }
+
+    if (lock == NULL) {
+        LOS_IntRestore(intSave);
+        return LOS_ERRNO_PM_NOT_LOCK;
+    } else if (lock->count > 0) {
+        lock->count--;
+        if (lock->count == 0) {
+            LOS_ListDelete(&lock->list);
+            lockFree = lock;
+        }
+    }
+#endif
+
+    if (pm->lock > 0) {
+        pm->lock--;
+        ret = LOS_OK;
+    }
+
+    LOS_IntRestore(intSave);
+#if (LOSCFG_KERNEL_PM_DEBUG == 1)
+    (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, lockFree);
+#endif
+    return ret;
+}
+
+STATIC VOID OsPmSleepTimeSet(UINT64 sleepTime)
+{
+    g_pmSleepTime = sleepTime;
+}
+
+UINT32 OsPmInit(VOID)
+{
+    UINT32 ret;
+    LosPmCB *pm = &g_pmCB;
+return 0;//wangzhilei
+    (VOID)memset_s(pm, sizeof(LosPmCB), 0, sizeof(LosPmCB));
+
+    pm->pmMode = LOS_SYS_NORMAL_SLEEP;
+#if (LOSCFG_KERNEL_PM_DEBUG == 1)
+    LOS_ListInit(&pm->lockList);
+#endif
+
+    ret = OsSchedRealSleepTimeSet(OsPmSleepTimeSet);
+    if (ret != LOS_OK) {
+        return ret;
+    }
+
+    ret = OsPmEnterHandlerSet(OsPmEnter);
+    if (ret != LOS_OK) {
+        return ret;
+    }
+
+    g_sysctrl = (LosPmSysctrl *)LOS_MemAlloc((VOID *)OS_SYS_MEM_ADDR, sizeof(LosPmSysctrl));
+    if (g_sysctrl == NULL) {
+        return LOS_NOK;
+    }
+
+    (VOID)memset_s(g_sysctrl, sizeof(LosPmSysctrl), 0, sizeof(LosPmSysctrl));
+    g_sysctrl->normalSuspend = HalEnterSleep;
+
+    ret = LOS_PmRegister(LOS_PM_TYPE_SYSCTRL, (VOID *)g_sysctrl);
+    if (ret != LOS_OK) {
+        (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, g_sysctrl);
+        g_sysctrl = NULL;
+    }
+
+    return ret;
+}
+#endif
diff --git a/kernel/liteos_m/components/power/los_pm.h b/kernel/liteos_m/components/power/los_pm.h
new file mode 100644
index 0000000..9b00cee
--- /dev/null
+++ b/kernel/liteos_m/components/power/los_pm.h
@@ -0,0 +1,326 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_PM_H
+#define _LOS_PM_H
+
+#include "los_config.h"
+#include "los_compiler.h"
+#include "los_list.h"
+#include "los_error.h"
+
+/**
+ * @ingroup los_pm
+ * Pm error code: Invalid low power mode.
+ *
+ * Value: 0x02002001
+ *
+ */
+#define LOS_ERRNO_PM_INVALID_MODE        LOS_ERRNO_OS_ERROR(LOS_MOD_PM, 0x01)
+
+/**
+ * @ingroup los_pm
+ * Pm error code: Invalid input parameter.
+ *
+ * Value: 0x02002002
+ *
+ */
+#define LOS_ERRNO_PM_INVALID_PARAM       LOS_ERRNO_OS_ERROR(LOS_MOD_PM, 0x02)
+
+/**
+ * @ingroup los_pm
+ * Pm error code: The current mode is unlocked.
+ *
+ * Value: 0x02002003
+ *
+ */
+#define LOS_ERRNO_PM_NOT_LOCK            LOS_ERRNO_OS_ERROR(LOS_MOD_PM, 0x03)
+
+/**
+ * @ingroup los_pm
+ * Pm error code: The lock limit has been exceeded.
+ *
+ * Value: 0x02002004
+ *
+ */
+#define LOS_ERRNO_PM_LOCK_LIMIT          LOS_ERRNO_OS_ERROR(LOS_MOD_PM, 0x04)
+
+/**
+ * @ingroup los_pm
+ * Pm error code: Invalid device node.
+ *
+ * Value: 0x02002005
+ *
+ */
+#define LOS_ERRNO_PM_INVALID_NODE        LOS_ERRNO_OS_ERROR(LOS_MOD_PM, 0x05)
+
+/**
+ * @ingroup los_pm
+ * Pm error code: Invalid type.
+ *
+ * Value: 0x02002006
+ *
+ */
+#define LOS_ERRNO_PM_INVALID_TYPE        LOS_ERRNO_OS_ERROR(LOS_MOD_PM, 0x06)
+
+/**
+ * @ingroup los_pm
+ * Pm error code: The hook for mode is not implemented.
+ *
+ * Value: 0x02002007
+ *
+ */
+#define LOS_ERRNO_PM_HANDLER_NULL        LOS_ERRNO_OS_ERROR(LOS_MOD_PM, 0x07)
+
+/**
+ * @ingroup los_pm
+ * Pm error code: Deep and shutdown must implement the Tick Timer related interface.
+ *
+ * Value: 0x02002008
+ *
+ */
+#define LOS_ERRNO_PM_TICK_TIMER_NULL     LOS_ERRNO_OS_ERROR(LOS_MOD_PM, 0x08)
+
+/**
+ * @ingroup los_pm
+ * Pm error code: Device is not registered.
+ *
+ * Value: 0x02002009
+ *
+ */
+#define LOS_ERRNO_PM_DEVICE_NULL         LOS_ERRNO_OS_ERROR(LOS_MOD_PM, 0x09)
+
+typedef enum {
+    LOS_SYS_NORMAL_SLEEP = 0,
+    LOS_SYS_LIGHT_SLEEP,
+    LOS_SYS_DEEP_SLEEP,
+    LOS_SYS_SHUTDOWN,
+} LOS_SysSleepEnum;
+
+typedef enum {
+    LOS_PM_TYPE_DEVICE = 0,
+    LOS_PM_TYPE_TICK_TIMER,
+    LOS_PM_TYPE_SYSCTRL,
+} LOS_PmNodeType;
+
+typedef struct {
+    UINT32 (*suspend)(UINT32 mode);
+    VOID   (*resume)(UINT32 mode);
+} LosPmDevice;
+
+typedef struct {
+    UINT32 freq;                   /* The frequency of the low power timer */
+    VOID   (*timerStart)(UINT64);  /* Start the low power timer */
+    VOID   (*timerStop)(VOID);     /* Stop the low power timer */
+    UINT64 (*timerCycleGet)(VOID); /* Gets the running time of the low power timer in unit cycle */
+    VOID   (*tickLock)(VOID);      /* Pause the system tick timer */
+    VOID   (*tickUnlock)(VOID);    /* Restore the system tick timer */
+} LosPmTickTimer;
+
+typedef struct {
+    VOID (*normalSuspend)(LOS_SysSleepEnum sleep);
+    VOID   (*normalResume)(VOID);
+    VOID (*lightSuspend)(LOS_SysSleepEnum sleep);
+    VOID   (*lightResume)(VOID);
+    VOID (*deepSuspend)(LOS_SysSleepEnum sleep);
+    VOID   (*deepResume)(VOID);
+    VOID (*shutdownSuspend)(LOS_SysSleepEnum sleep);
+    VOID   (*shutdownResume)(VOID);
+} LosPmSysctrl;
+
+/**
+ * @ingroup los_pm
+ * @brief Initialize system low power frame.
+ *
+ * @par Description:
+ * This API is used to initialize the system low power frame.
+ *
+ * @attention None.
+ *
+ * @param  None.
+ *
+ * @retval error code, LOS_OK means success.
+ * @par Dependency:
+ * <ul><li>los_pm.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+UINT32 OsPmInit(VOID);
+
+/**
+ * @ingroup los_pm
+ * @brief Register a power management node.
+ *
+ * @par Description:
+ * This API is used to register a power management node.
+ *
+ * @attention None.
+ *
+ * @param  type [IN] The types supported by the PM module.
+ * @param  node [IN] power management node.
+ *
+ * @retval error code, LOS_OK means success.
+ * @par Dependency:
+ * <ul><li>los_pm.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_PmUnregister
+ */
+UINT32 LOS_PmRegister(LOS_PmNodeType type, VOID *node);
+
+/**
+ * @ingroup los_pm
+ * @brief Unregister a power management node.
+ *
+ * @par Description:
+ * This API is used to unregister a power management node.
+ *
+ * @attention None.
+ *
+ * @param  type [IN] The types supported by the PM module.
+ * @param  node [IN] power management node.
+ *
+ * @retval error code, LOS_OK means success.
+ * @par Dependency:
+ * <ul><li>los_pm.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_PmRegister
+ */
+UINT32 LOS_PmUnregister(LOS_PmNodeType type, VOID *node);
+
+/**
+ * @ingroup los_pm
+ * @brief Set the system wake up flag.
+ *
+ * @par Description:
+ * This API is used to set the system wake-up flag.
+ *
+ * @attention None.
+ *
+ * @param None.
+ *
+ * @retval None.
+ * @par Dependency:
+ * <ul><li>los_pm.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+VOID LOS_PmWakeSet(VOID);
+
+/**
+ * @ingroup los_pm
+ * @brief Get the low power mode of the current system.
+ *
+ * @par Description:
+ * This API is used to get the low power mode of the current system.
+ *
+ * @attention None.
+ *
+ * @param None.
+ *
+ * @retval error code, LOS_OK means success.
+ * @par Dependency:
+ * <ul><li>los_pm.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_PmModeSet
+ */
+LOS_SysSleepEnum LOS_PmModeGet(VOID);
+
+/**
+ * @ingroup los_pm
+ * @brief Set low power mode.
+ *
+ * @par Description:
+ * This API is used to set low power mode.
+ *
+ * @attention None.
+ *
+ * @param  mode [IN] low power mode.
+ *
+ * @retval error code, LOS_OK means success.
+ * @par Dependency:
+ * <ul><li>los_pm.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_PmModeGet
+ */
+UINT32 LOS_PmModeSet(LOS_SysSleepEnum mode);
+
+/**
+ * @ingroup los_pm
+ * @brief Request to obtain the lock in current mode, so that the system will not enter
+ * this mode when it enters the idle task next time.
+ *
+ * @par Description:
+ * This API is used to obtain the lock in current mode.
+ *
+ * @attention None.
+ *
+ * @param  name [IN] Who requests the lock.
+ *
+ * @retval error code, LOS_OK means success.
+ * @par Dependency:
+ * <ul><li>los_pm.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_PmLockRelease
+ */
+UINT32 LOS_PmLockRequest(const CHAR *name);
+
+/**
+ * @ingroup los_pm
+ * @brief Release the lock in current mode so that the next time the system enters
+ * the idle task, it will enter this mode.
+ *
+ * @par Description:
+ * This API is used to release the lock in current mode.
+ *
+ * @attention None.
+ *
+ * @param  name [IN] Who releases the lock.
+ *
+ * @retval error code, LOS_OK means success.
+ * @par Dependency:
+ * <ul><li>los_pm.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_PmLockRequest
+ */
+UINT32 LOS_PmLockRelease(const CHAR *name);
+
+#if (LOSCFG_KERNEL_PM_DEBUG == 1)
+/**
+ * @ingroup los_pm
+ * @brief Output the locking information of the pm lock.
+ *
+ * @par Description:
+ * This API is used to output the locking information of the pm lock.
+ *
+ * @attention None.
+ *
+ * @param None.
+ *
+ * @retval error code, LOS_OK means success.
+ * @par Dependency:
+ * <ul><li>los_pm.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_PmLockRequest
+ */
+VOID LOS_PmLockInfoShow(VOID);
+#endif
+#endif
diff --git a/kernel/liteos_m/components/shell/BUILD.gn b/kernel/liteos_m/components/shell/BUILD.gn
new file mode 100644
index 0000000..19dea48
--- /dev/null
+++ b/kernel/liteos_m/components/shell/BUILD.gn
@@ -0,0 +1,55 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("shell") {
+  sources = [
+    "src/base/shcmd.c",
+    "src/base/shcmdparse.c",
+    "src/base/shmsg.c",
+    "src/base/show.c",
+    "src/cmds/date_shell.c",
+    "src/cmds/shell_shellcmd.c",
+    "src/cmds/task_shellcmd.c",
+    "src/cmds/vfs_shellcmd.c",
+    "src/cmds/mempt_shellcmd.c",
+    "src/cmds/fullpath.c",
+  ]
+
+  include_dirs = [
+    "../../kernel/arch/include",
+    "../../kernel/include",
+    "../../utils",
+    "./include",
+  ]
+
+  deps = [
+    "//kernel/liteos_m/kal/posix",
+    "//third_party/bounds_checking_function:libsec_static",
+  ]
+}
diff --git a/kernel/liteos_m/components/shell/include/shcmd.h b/kernel/liteos_m/components/shell/include/shcmd.h
new file mode 100644
index 0000000..424209d
--- /dev/null
+++ b/kernel/liteos_m/components/shell/include/shcmd.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _HWLITEOS_SHELL_SHCMD_H
+#define _HWLITEOS_SHELL_SHCMD_H
+
+#include "string.h"
+#include "stdlib.h"
+#include "los_list.h"
+#include "shcmdparse.h"
+#include "show.h"
+
+#ifdef  __cplusplus
+#if  __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+typedef BOOL (*CmdVerifyTransID)(UINT32 transID);
+
+typedef struct {
+    CmdType cmdType;
+    const CHAR *cmdKey;
+    UINT32 paraNum;
+    CmdCallBackFunc cmdHook;
+} CmdItem;
+
+typedef struct {
+    LOS_DL_LIST list;
+    CmdItem *cmd;
+} CmdItemNode;
+
+/* global info for shell module */
+typedef struct {
+    CmdItemNode cmdList;
+    UINT32 listNum;
+    UINT32 initMagicFlag;
+    UINT32 muxLock;
+    CmdVerifyTransID transIdHook;
+} CmdModInfo;
+
+typedef struct {
+    UINT32 count;
+    LOS_DL_LIST list;
+    CHAR cmdString[0];
+} CmdKeyLink;
+
+#define SHELLCMD_ENTRY(l, cmdType, cmdKey, paraNum, cmdHook)    \
+    CmdItem l LOS_HAL_TABLE_ENTRY(shellcmd) = {                 \
+        cmdType,                                                \
+        cmdKey,                                                 \
+        paraNum,                                                \
+        cmdHook                                                 \
+    }
+
+#define NEED_NEW_LINE(timesPrint, lineCap) ((timesPrint) % (lineCap) == 0)
+#define SCREEN_IS_FULL(timesPrint, lineCap) ((timesPrint) >= ((lineCap) * DEFAULT_SCREEN_HEIGNT))
+
+extern CmdModInfo *OsCmdInfoGet(VOID);
+extern UINT32 OsCmdExec(CmdParsed *cmdParsed, CHAR *cmdStr);
+extern UINT32 OsCmdKeyShift(const CHAR *cmdKey, CHAR *cmdOut, UINT32 size);
+extern UINT32 OsShellKeyInit(ShellCB *shellCB);
+extern VOID OsShellKeyDeInit(CmdKeyLink *cmdKeyLink);
+extern UINT32 OsShellSysCmdRegister(VOID);
+extern int VfsNormalizePath(const char *directory, const char *filename, char **pathname);
+extern INT32 OsShellCmdDate(INT32 argc, const CHAR **argv);
+extern INT32 OsShellCmdDumpTask(INT32 argc, const CHAR **argv);
+extern UINT32 OsShellCmdFree(INT32 argc, const CHAR **argv);
+extern UINT32 lwip_ifconfig(INT32 argc, const CHAR **argv);
+extern UINT32 OsShellPing(INT32 argc, const CHAR **argv);
+extern INT32 OsShellCmdTouch(INT32 argc, const CHAR **argv);
+extern INT32 OsShellCmdLs(INT32 argc, const CHAR **argv);
+extern INT32 OsShellCmdPwd(INT32 argc, const CHAR **argv);
+extern INT32 OsShellCmdCd(INT32 argc, const CHAR **argv);
+extern INT32 OsShellCmdCat(INT32 argc, const CHAR **argv);
+extern INT32 OsShellCmdRm(INT32 argc, const CHAR **argv);
+extern INT32 OsShellCmdRmdir(INT32 argc, const CHAR **argv);
+extern INT32 OsShellCmdMkdir(INT32 argc, const CHAR **argv);
+extern INT32 OsShellCmdCp(INT32 argc, const CHAR **argv);
+extern INT32 OsShellCmdHelp(INT32 argc, const CHAR **argv);
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* _HWLITEOS_SHELL_SHCMD_H */
diff --git a/kernel/liteos_m/components/shell/include/shcmdparse.h b/kernel/liteos_m/components/shell/include/shcmdparse.h
new file mode 100644
index 0000000..c3e7784
--- /dev/null
+++ b/kernel/liteos_m/components/shell/include/shcmdparse.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _HWLITEOS_SHELL_SHCMDPARSE_H
+#define _HWLITEOS_SHELL_SHCMDPARSE_H
+
+#include "string.h"
+#include "show.h"
+
+#ifdef  __cplusplus
+#if  __cplusplus
+extern "C" {
+#endif
+#endif
+
+#define CMD_PARSED_RETCODE_BASE            LOS_OK
+#define CMD_PARSED_RETCODE_TYPE_INVALID    (CMD_PARSED_RETCODE_BASE + 1)
+#define CMD_PARSED_RETCODE_PARAM_OVERTOP   (CMD_PARSED_RETCODE_BASE + 3)
+#define CMD_PARSED_RETCODE_CMDKEY_NOTFOUND (CMD_PARSED_RETCODE_BASE + 4)
+
+typedef UINT32 (*FUNC_ONE_TOKEN)(VOID *ctx, UINT32 index, CHAR *token);
+
+/*
+ * Description: the info struct after cmd parser
+ */
+typedef struct {
+    UINT32 paramCnt;                /* count of para */
+    CmdType cmdType;                /* cmd type, judge cmd keyword */
+    CHAR cmdKeyword[CMD_KEY_LEN];   /* cmd keyword str */
+    CHAR *paramArray[CMD_MAX_PARAS];
+} CmdParsed;
+
+extern UINT32 OsCmdParse(CHAR *cmdStr, CmdParsed *cmdParsed);
+extern CHAR *OsCmdParseStrdup(const CHAR *str);
+extern UINT32 OsCmdParseOneToken(CmdParsed *cmdParsed, UINT32 index, const CHAR *token);
+extern UINT32 OsCmdTokenSplit(CHAR *cmdStr, CHAR split, CmdParsed *cmdParsed);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* _HWLITEOS_SHELL_SHCMDPARSE_H */
diff --git a/kernel/liteos_m/components/shell/include/shell.h b/kernel/liteos_m/components/shell/include/shell.h
new file mode 100644
index 0000000..4d1131c
--- /dev/null
+++ b/kernel/liteos_m/components/shell/include/shell.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _HWLITEOS_SHELL_H
+#define _HWLITEOS_SHELL_H
+
+#include "pthread.h"
+#include "limits.h"
+#include "los_compiler.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define OS_ERRNO_SHELL_NO_HOOK                  LOS_ERRNO_OS_ERROR(LOS_MOD_SHELL, 0x00)
+#define OS_ERRNO_SHELL_CMDREG_PARA_ERROR        LOS_ERRNO_OS_ERROR(LOS_MOD_SHELL, 0x01)
+#define OS_ERRNO_SHELL_CMDREG_CMD_ERROR         LOS_ERRNO_OS_ERROR(LOS_MOD_SHELL, 0x02)
+#define OS_ERRNO_SHELL_CMDREG_CMD_EXIST         LOS_ERRNO_OS_ERROR(LOS_MOD_SHELL, 0x03)
+#define OS_ERRNO_SHELL_CMDREG_MEMALLOC_ERROR    LOS_ERRNO_OS_ERROR(LOS_MOD_SHELL, 0x04)
+#define OS_ERRNO_SHELL_SHOW_HOOK_NULL           LOS_ERRNO_OS_ERROR(LOS_MOD_SHELL, 0x05)
+#define OS_ERRNO_SHELL_SHOW_HOOK_EXIST          LOS_ERRNO_OS_ERROR(LOS_MOD_SHELL, 0x06)
+#define OS_ERRNO_SHELL_SHOW_HOOK_TOO_MUCH       LOS_ERRNO_OS_ERROR(LOS_MOD_SHELL, 0x07)
+#define OS_ERRNO_SHELL_NOT_INIT                 LOS_ERRNO_OS_ERROR(LOS_MOD_SHELL, 0x08)
+#define OS_ERRNO_SHELL_CMD_HOOK_NULL            LOS_ERRNO_OS_ERROR(LOS_MOD_SHELL, 0x09)
+#define OS_ERRNO_SHELL_FIFO_ERROR               LOS_ERRNO_OS_ERROR(LOS_MOD_SHELL, 0x10)
+
+/* Max len of show str */
+#define SHOW_MAX_LEN CMD_MAX_LEN
+
+#define XARGS 0xFFFFFFFF /* default args */
+
+#define CMD_MAX_PARAS           32
+#define CMD_KEY_LEN             16U
+#define CMD_MAX_LEN             (256U + CMD_KEY_LEN)
+#define CMD_KEY_NUM             32
+#define CMD_HISTORY_LEN         10
+#define CMD_MAX_PATH            256
+#define DEFAULT_SCREEN_WIDTH    80
+#define DEFAULT_SCREEN_HEIGNT   24
+
+#define SHELL_MODE              0
+#define OTHER_MODE              1
+
+#define SWITCH_QUOTES_STATUS(qu) do {   \
+    if ((qu) == TRUE) {                 \
+        (qu) = FALSE;                   \
+    } else {                            \
+        (qu) = TRUE;                    \
+    }                                   \
+} while (0)
+
+#define QUOTES_STATUS_CLOSE(qu) ((qu) == FALSE)
+#define QUOTES_STATUS_OPEN(qu)  ((qu) == TRUE)
+
+typedef struct {
+    UINT32   consoleID;
+    UINT32   shellTaskHandle;
+    UINT32   shellEntryHandle;
+    VOID     *cmdKeyLink;
+    VOID     *cmdHistoryKeyLink;
+    VOID     *cmdMaskKeyLink;
+    UINT32   shellBufOffset;
+    UINT32   shellKeyType;
+    pthread_mutex_t keyMutex;
+    pthread_mutex_t historyMutex;
+    CHAR     shellBuf[SHOW_MAX_LEN];
+    CHAR     shellWorkingDirectory[PATH_MAX];
+} ShellCB;
+
+/* All support cmd types */
+typedef enum {
+    CMD_TYPE_SHOW = 0,
+    CMD_TYPE_STD = 1,
+    CMD_TYPE_EX = 2,
+    CMD_TYPE_BUTT
+} CmdType;
+
+typedef enum {
+    CMD_KEY_UP = 0,
+    CMD_KEY_DOWN = 1,
+    CMD_KEY_RIGHT = 2,
+    CMD_KEY_LEFT = 4,
+    CMD_KEY_BUTT
+} CmdKeyDirection;
+
+/*
+ * Hook for user-defined debug function
+ * Unify differnt module's func for registration
+ */
+typedef UINT32 (*CmdCallBackFunc)(UINT32 argc, const CHAR **argv);
+
+/* External interface, need reserved */
+typedef CmdCallBackFunc CMD_CBK_FUNC;
+typedef CmdType CMD_TYPE_E;
+
+extern UINT32 osCmdReg(CmdType cmdType, const CHAR *cmdKey, UINT32 paraNum, CmdCallBackFunc cmdProc);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _HWLITEOS_SHELL_H */
diff --git a/kernel/liteos_m/components/shell/include/shmsg.h b/kernel/liteos_m/components/shell/include/shmsg.h
new file mode 100644
index 0000000..789a024
--- /dev/null
+++ b/kernel/liteos_m/components/shell/include/shmsg.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _HWLITEOS_SHELL_SHMSG_H
+#define _HWLITEOS_SHELL_SHMSG_H
+
+#include "shell.h"
+#include "shcmdparse.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+extern UINT32 ShellMsgTypeGet(CmdParsed *cmdParsed, const CHAR *cmdType);
+extern void ExecCmdline(const char *cmdline);
+
+#define SHELL_CMD_PARSE_EVENT   0x111
+
+#define SH_OK  0
+#define SH_NOK 1
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _HWLITEOS_SHELL_SHMSG_H */
diff --git a/kernel/liteos_m/kal/kal.c b/kernel/liteos_m/components/shell/include/show.h
old mode 100755
new mode 100644
similarity index 63%
rename from kernel/liteos_m/kal/kal.c
rename to kernel/liteos_m/components/shell/include/show.h
index 4e8e5b1..698c729
--- a/kernel/liteos_m/kal/kal.c
+++ b/kernel/liteos_m/components/shell/include/show.h
@@ -29,44 +29,38 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "kal.h"
-#include "los_interrupt.h"
-#include "los_swtmr.h"
+#ifndef _HWLITEOS_SHELL_SHOW_H
+#define _HWLITEOS_SHELL_SHOW_H
+
+#include "shell.h"
+#include "los_debug.h"
+#include "errno.h"
 
 #ifdef __cplusplus
 #if __cplusplus
 extern "C" {
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
-
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-osTimerId_t osTimerExtNew(osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr,
-    osTimerRouses_t ucRouses, osTimerAlign_t ucSensitive)
-{
-    UNUSED(attr);
-    UINT32 usSwTmrID;
-    UINT8 mode;
+#endif /* __cplusplus */
+#endif /* __cplusplus */
 
-    if ((OS_INT_ACTIVE) || (NULL == func) || ((osTimerOnce != type) && (osTimerPeriodic != type))) {
-        return (osTimerId_t)NULL;
-    }
+extern CHAR *OsShellGetWorkingDirtectory(VOID);
+extern UINT32 OsShellInit(INT32 consoleId);
+extern INT32 OsShellDeinit(INT32 consoleId);
 
-    if (osTimerOnce == type) {
-        mode = LOS_SWTMR_MODE_NO_SELFDELETE;
-    } else {
-        mode = LOS_SWTMR_MODE_PERIOD;
-    }
-    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)func, &usSwTmrID,
-        (UINT32)(UINTPTR)argument, ucRouses, ucSensitive)) {
-        return (osTimerId_t)NULL;
-    }
+static inline void SetErrno(int errcode)
+{
+    errno = errcode;
+}
 
-    return (osTimerId_t)OS_SWT_FROM_SID(usSwTmrID);
+static inline void SetErr(int errcode, const char *errMessage)
+{
+    SetErrno(errcode);
+    PRINTK(errMessage);
 }
-#endif
 
 #ifdef __cplusplus
 #if __cplusplus
 }
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
\ No newline at end of file
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _HWLITEOS_SHELL_SHOW_H */
\ No newline at end of file
diff --git a/kernel/liteos_m/components/shell/src/base/shcmd.c b/kernel/liteos_m/components/shell/src/base/shcmd.c
new file mode 100644
index 0000000..4c32188
--- /dev/null
+++ b/kernel/liteos_m/components/shell/src/base/shcmd.c
@@ -0,0 +1,452 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "shcmd.h"
+#include "show.h"
+#include "shmsg.h"
+#include "stdlib.h"
+#include "unistd.h"
+#include "dirent.h"
+#include "securec.h"
+#include "los_mux.h"
+#include "los_memory.h"
+
+#define SHELL_INIT_MAGIC_FLAG 0xABABABAB
+
+STATIC CmdModInfo cmdInfo;
+ShellCB *g_shellCB = NULL;
+CmdItem g_shellcmdAll[] = {
+    {CMD_TYPE_STD, "date", XARGS, (CmdCallBackFunc)OsShellCmdDate},
+    {CMD_TYPE_EX, "task", 1, (CmdCallBackFunc)OsShellCmdDumpTask},
+    {CMD_TYPE_EX, "free", XARGS, (CmdCallBackFunc)OsShellCmdFree},
+    {CMD_TYPE_EX, "ifconfig", XARGS, (CmdCallBackFunc)lwip_ifconfig},
+    {CMD_TYPE_EX, "ping", XARGS, (CmdCallBackFunc)OsShellPing},
+    {CMD_TYPE_EX, "touch", XARGS, (CmdCallBackFunc)OsShellCmdTouch},
+    {CMD_TYPE_EX, "ls", XARGS, (CmdCallBackFunc)OsShellCmdLs},
+    {CMD_TYPE_EX, "pwd", XARGS, (CmdCallBackFunc)OsShellCmdPwd},
+    {CMD_TYPE_EX, "cd", XARGS, (CmdCallBackFunc)OsShellCmdCd},
+    {CMD_TYPE_EX, "cat", XARGS, (CmdCallBackFunc)OsShellCmdCat},
+    {CMD_TYPE_EX, "rm", XARGS, (CmdCallBackFunc)OsShellCmdRm},
+    {CMD_TYPE_EX, "rmdir", XARGS, (CmdCallBackFunc)OsShellCmdRmdir},
+    {CMD_TYPE_EX, "mkdir", XARGS, (CmdCallBackFunc)OsShellCmdMkdir},
+    {CMD_TYPE_EX, "cp", XARGS, (CmdCallBackFunc)OsShellCmdCp},
+    {CMD_TYPE_EX, "help", 0, (CmdCallBackFunc)OsShellCmdHelp},
+};
+
+CmdModInfo *OsCmdInfoGet(VOID)
+{
+    return &cmdInfo;
+}
+
+/*
+ * Description: Pass in the string and clear useless space ,which inlcude:
+ *                1) The overmatch space which is not be marked by Quote's area
+ *                   Squeeze the overmatch space into one space
+ *                2) Clear all space before first vaild charatctor
+ * Input:       cmdKey : Pass in the buff string, which is ready to be operated
+ *              cmdOut : Pass out the buffer string ,which has already been operated
+ *              size : cmdKey length
+ */
+LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdKeyShift(const CHAR *cmdKey, CHAR *cmdOut, UINT32 size)
+{
+    CHAR *output = NULL;
+    CHAR *outputBak = NULL;
+    UINT32 len;
+    INT32 ret;
+    BOOL quotes = FALSE;
+
+    if ((cmdKey == NULL) || (cmdOut == NULL)) {
+        return (UINT32)OS_ERROR;
+    }
+
+    len = strlen(cmdKey);
+    if (len >= size) {
+        return (UINT32)OS_ERROR;
+    }
+    output = (CHAR*)LOS_MemAlloc(m_aucSysMem0, len + 1);
+    if (output == NULL) {
+        PRINTK("malloc failure in %s[%d]", __FUNCTION__, __LINE__);
+        return (UINT32)OS_ERROR;
+    }
+    /* Backup the 'output' start address */
+    outputBak = output;
+    /* Scan each charactor in 'cmdKey',and squeeze the overmuch space and ignore invaild charactor */
+    for (; *cmdKey != '\0'; cmdKey++) {
+        /* Detected a Double Quotes, switch the matching status */
+        if (*(cmdKey) == '\"') {
+            SWITCH_QUOTES_STATUS(quotes);
+        }
+        /* Ignore the current charactor in following situation */
+        /* 1) Quotes matching status is FALSE (which said that the space is not been marked by double quotes) */
+        /* 2) Current charactor is a space */
+        /* 3) Next charactor is a space too, or the string is been seeked to the end already(\0) */
+        /* 4) Invaild charactor, such as single quotes */
+        if ((*cmdKey == ' ') && ((*(cmdKey + 1) == ' ') || (*(cmdKey + 1) == '\0')) && QUOTES_STATUS_CLOSE(quotes)) {
+            continue;
+        }
+        if (*cmdKey == '\'') {
+            continue;
+        }
+        *output = *cmdKey;
+        output++;
+    }
+    *output = '\0';
+    /* Restore the 'output' start address */
+    output = outputBak;
+    len = strlen(output);
+    /* Clear the space which is located at the first charactor in buffer */
+    if (*outputBak == ' ') {
+        output++;
+        len--;
+    }
+    /* Copy out the buffer which is been operated already */
+    ret = strncpy_s(cmdOut, size, output, len);
+    if (ret != EOK) {
+        PRINT_ERR("%s,%d strncpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
+        (VOID)LOS_MemFree(m_aucSysMem0, output);
+        return OS_ERROR;
+    }
+    cmdOut[len] = '\0';
+
+    (VOID)LOS_MemFree(m_aucSysMem0, output);
+
+    return LOS_OK;
+}
+
+LITE_OS_SEC_TEXT_MINOR BOOL OsCmdKeyCheck(const CHAR *cmdKey)
+{
+    const CHAR *temp = cmdKey;
+    enum Stat {
+        STAT_NONE,
+        STAT_DIGIT,
+        STAT_OTHER
+    } state = STAT_NONE;
+
+    if (strlen(cmdKey) >= CMD_KEY_LEN) {
+        return FALSE;
+    }
+
+    while (*temp != '\0') {
+        if (!((*temp <= '9') && (*temp >= '0')) &&
+            !((*temp <= 'z') && (*temp >= 'a')) &&
+            !((*temp <= 'Z') && (*temp >= 'A')) &&
+            (*temp != '_') && (*temp != '-')) {
+            return FALSE;
+        }
+
+        if ((*temp >= '0') && (*temp <= '9')) {
+            if (state == STAT_NONE) {
+                state = STAT_DIGIT;
+            }
+        } else {
+            state = STAT_OTHER;
+        }
+
+        temp++;
+    }
+
+    if (state == STAT_DIGIT) {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+LITE_OS_SEC_TEXT_MINOR VOID OsCmdAscendingInsert(CmdItemNode *cmd)
+{
+    CmdItemNode *cmdItem = NULL;
+    CmdItemNode *cmdNext = NULL;
+
+    if (cmd == NULL) {
+        return;
+    }
+
+    for (cmdItem = LOS_DL_LIST_ENTRY((&cmdInfo.cmdList.list)->pstPrev, CmdItemNode, list);
+        &cmdItem->list != &(cmdInfo.cmdList.list);) {
+        cmdNext = LOS_DL_LIST_ENTRY(cmdItem->list.pstPrev, CmdItemNode, list);
+        if (&cmdNext->list != &(cmdInfo.cmdList.list)) {
+            if ((strncmp(cmdItem->cmd->cmdKey, cmd->cmd->cmdKey, strlen(cmd->cmd->cmdKey)) >= 0) &&
+                (strncmp(cmdNext->cmd->cmdKey, cmd->cmd->cmdKey, strlen(cmd->cmd->cmdKey)) < 0)) {
+                LOS_ListTailInsert(&(cmdItem->list), &(cmd->list));
+                return;
+            }
+            cmdItem = cmdNext;
+        } else {
+            if (strncmp(cmd->cmd->cmdKey, cmdItem->cmd->cmdKey, strlen(cmd->cmd->cmdKey)) > 0) {
+                cmdItem = cmdNext;
+            }
+            break;
+        }
+    }
+
+    LOS_ListTailInsert(&(cmdItem->list), &(cmd->list));
+}
+
+LITE_OS_SEC_TEXT_MINOR UINT32 OsShellKeyInit(ShellCB *shellCB)
+{
+    CmdKeyLink *cmdKeyLink = NULL;
+    CmdKeyLink *cmdHistoryLink = NULL;
+
+    if (shellCB == NULL) {
+        return OS_ERROR;
+    }
+    cmdKeyLink = (CmdKeyLink *)LOS_MemAlloc(m_aucSysMem0, sizeof(CmdKeyLink));
+    if (cmdKeyLink == NULL) {
+        PRINT_ERR("Shell CmdKeyLink memory alloc error!\n");
+        return OS_ERROR;
+    }
+    cmdHistoryLink = (CmdKeyLink *)LOS_MemAlloc(m_aucSysMem0, sizeof(CmdKeyLink));
+    if (cmdHistoryLink == NULL) {
+        (VOID)LOS_MemFree(m_aucSysMem0, cmdKeyLink);
+        PRINT_ERR("Shell CmdHistoryLink memory alloc error!\n");
+        return OS_ERROR;
+    }
+
+    cmdKeyLink->count = 0;
+    LOS_ListInit(&(cmdKeyLink->list));
+    shellCB->cmdKeyLink = (VOID *)cmdKeyLink;
+
+    cmdHistoryLink->count = 0;
+    LOS_ListInit(&(cmdHistoryLink->list));
+    shellCB->cmdHistoryKeyLink = (VOID *)cmdHistoryLink;
+    shellCB->cmdMaskKeyLink = (VOID *)cmdHistoryLink;
+    return LOS_OK;
+}
+
+LITE_OS_SEC_TEXT_MINOR VOID OsShellKeyDeInit(CmdKeyLink *cmdKeyLink)
+{
+    CmdKeyLink *cmdtmp = NULL;
+    if (cmdKeyLink == NULL) {
+        return;
+    }
+
+    while (!LOS_ListEmpty(&(cmdKeyLink->list))) {
+        cmdtmp = LOS_DL_LIST_ENTRY(cmdKeyLink->list.pstNext, CmdKeyLink, list);
+        LOS_ListDelete(&cmdtmp->list);
+        (VOID)LOS_MemFree(m_aucSysMem0, cmdtmp);
+    }
+
+    cmdKeyLink->count = 0;
+    (VOID)LOS_MemFree(m_aucSysMem0, cmdKeyLink);
+}
+
+LITE_OS_SEC_TEXT_MINOR UINT32 OsShellSysCmdRegister(VOID)
+{
+    UINT32 i;
+    UINT8 *cmdItemGroup = NULL;
+    UINT32 index = sizeof(g_shellcmdAll) / sizeof(CmdItem);
+    CmdItemNode *cmdItem = NULL;
+
+    cmdItemGroup = (UINT8 *)LOS_MemAlloc(m_aucSysMem0, index * sizeof(CmdItemNode));
+    if (cmdItemGroup == NULL) {
+        PRINT_ERR("[%s]System memory allocation failure!\n", __FUNCTION__);
+        return (UINT32)OS_ERROR;
+    }
+
+    for (i = 0; i < index; ++i) {
+        cmdItem = (CmdItemNode *)(cmdItemGroup + i * sizeof(CmdItemNode));
+        cmdItem->cmd = &g_shellcmdAll[i];
+        OsCmdAscendingInsert(cmdItem);
+    }
+    cmdInfo.listNum += index;
+    return LOS_OK;
+}
+
+LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdExec(CmdParsed *cmdParsed, CHAR *cmdStr)
+{
+    UINT32 ret;
+    CmdCallBackFunc cmdHook = NULL;
+    CmdItemNode *curCmdItem = NULL;
+    UINT32 i;
+    const CHAR *cmdKey = NULL;
+
+    if ((cmdParsed == NULL) || (cmdStr == NULL) || (strlen(cmdStr) == 0)) {
+        return (UINT32)OS_ERROR;
+    }
+
+    ret = OsCmdParse(cmdStr, cmdParsed);
+    if (ret != LOS_OK) {
+        goto OUT;
+    }
+
+    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &(cmdInfo.cmdList.list), CmdItemNode, list) {
+        cmdKey = curCmdItem->cmd->cmdKey;
+        if ((cmdParsed->cmdType == curCmdItem->cmd->cmdType) &&
+            (strlen(cmdKey) == strlen(cmdParsed->cmdKeyword)) &&
+            (strncmp(cmdKey, (CHAR *)(cmdParsed->cmdKeyword), strlen(cmdKey)) == 0)) {
+            cmdHook = curCmdItem->cmd->cmdHook;
+            break;
+        }
+    }
+
+    ret = OS_ERROR;
+    if (cmdHook != NULL) {
+        ret = (cmdHook)(cmdParsed->paramCnt, (const CHAR **)cmdParsed->paramArray);
+    }
+
+OUT:
+    for (i = 0; i < cmdParsed->paramCnt; i++) {
+        if (cmdParsed->paramArray[i] != NULL) {
+            (VOID)LOS_MemFree(m_aucSysMem0, cmdParsed->paramArray[i]);
+            cmdParsed->paramArray[i] = NULL;
+        }
+    }
+
+    return (UINT32)ret;
+}
+
+ShellCB *OsGetShellCb(VOID)
+{
+    return g_shellCB;
+}
+
+char *OsShellGetWorkingDirtectory(VOID)
+{
+    return OsGetShellCb()->shellWorkingDirectory;
+}
+
+VOID OsShellCBInit(VOID)
+{
+    int ret;
+    ShellCB *shellCB = NULL;
+
+    shellCB = (ShellCB *)malloc(sizeof(ShellCB));
+    if (shellCB == NULL) {
+        goto ERR_OUT1;
+    }
+    ret = memset_s(shellCB, sizeof(ShellCB), 0, sizeof(ShellCB));
+    if (ret != SH_OK) {
+        goto ERR_OUT1;
+    }
+
+    ret = (int)OsShellKeyInit(shellCB);
+    if (ret != SH_OK) {
+        goto ERR_OUT1;
+    }
+    (void)strncpy_s(shellCB->shellWorkingDirectory, PATH_MAX, "/", 2); /* 2:space for "/" */
+
+    g_shellCB = shellCB;
+    return;
+
+ERR_OUT1:
+    (void)free(shellCB);
+    return;
+}
+
+LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdInit(VOID)
+{
+    UINT32 ret;
+    LOS_ListInit(&(cmdInfo.cmdList.list));
+    cmdInfo.listNum = 0;
+    cmdInfo.initMagicFlag = SHELL_INIT_MAGIC_FLAG;
+    ret = LOS_MuxCreate(&cmdInfo.muxLock);
+    if (ret != LOS_OK) {
+        PRINT_ERR("Create mutex for shell cmd info failed\n");
+        return OS_ERROR;
+    }
+    OsShellCBInit();
+
+    return LOS_OK;
+}
+
+STATIC UINT32 OsCmdItemCreate(CmdType cmdType, const CHAR *cmdKey, UINT32 paraNum, CmdCallBackFunc cmdProc)
+{
+    CmdItem *cmdItem = NULL;
+    CmdItemNode *cmdItemNode = NULL;
+
+    cmdItem = (CmdItem *)LOS_MemAlloc(m_aucSysMem0, sizeof(CmdItem));
+    if (cmdItem == NULL) {
+        return OS_ERRNO_SHELL_CMDREG_MEMALLOC_ERROR;
+    }
+    (VOID)memset_s(cmdItem, sizeof(CmdItem), '\0', sizeof(CmdItem));
+
+    cmdItemNode = (CmdItemNode *)LOS_MemAlloc(m_aucSysMem0, sizeof(CmdItemNode));
+    if (cmdItemNode == NULL) {
+        (VOID)LOS_MemFree(m_aucSysMem0, cmdItem);
+        return OS_ERRNO_SHELL_CMDREG_MEMALLOC_ERROR;
+    }
+    (VOID)memset_s(cmdItemNode, sizeof(CmdItemNode), '\0', sizeof(CmdItemNode));
+    cmdItemNode->cmd = cmdItem;
+    cmdItemNode->cmd->cmdHook = cmdProc;
+    cmdItemNode->cmd->paraNum = paraNum;
+    cmdItemNode->cmd->cmdType = cmdType;
+    cmdItemNode->cmd->cmdKey = cmdKey;
+
+    (VOID)LOS_MuxPend(cmdInfo.muxLock, LOS_WAIT_FOREVER);
+    OsCmdAscendingInsert(cmdItemNode);
+    cmdInfo.listNum++;
+    (VOID)LOS_MuxPost(cmdInfo.muxLock);
+
+    return LOS_OK;
+}
+
+/* open API */
+LITE_OS_SEC_TEXT_MINOR UINT32 osCmdReg(CmdType cmdType, const CHAR *cmdKey, UINT32 paraNum, CmdCallBackFunc cmdProc)
+{
+    CmdItemNode *cmdItemNode = NULL;
+
+    (VOID)LOS_MuxPend(cmdInfo.muxLock, LOS_WAIT_FOREVER);
+    if (cmdInfo.initMagicFlag != SHELL_INIT_MAGIC_FLAG) {
+        (VOID)LOS_MuxPost(cmdInfo.muxLock);
+        PRINT_ERR("[%s] shell is not yet initialized!\n", __FUNCTION__);
+        return OS_ERRNO_SHELL_NOT_INIT;
+    }
+    (VOID)LOS_MuxPost(cmdInfo.muxLock);
+
+    if ((cmdProc == NULL) || (cmdKey == NULL) ||
+        (cmdType >= CMD_TYPE_BUTT) || (strlen(cmdKey) >= CMD_KEY_LEN) || !strlen(cmdKey)) {
+        return OS_ERRNO_SHELL_CMDREG_PARA_ERROR;
+    }
+
+    if (paraNum > CMD_MAX_PARAS) {
+        if (paraNum != XARGS) {
+            return OS_ERRNO_SHELL_CMDREG_PARA_ERROR;
+        }
+    }
+
+    if (OsCmdKeyCheck(cmdKey) != TRUE) {
+        return OS_ERRNO_SHELL_CMDREG_CMD_ERROR;
+    }
+
+    (VOID)LOS_MuxPend(cmdInfo.muxLock, LOS_WAIT_FOREVER);
+    LOS_DL_LIST_FOR_EACH_ENTRY(cmdItemNode, &(cmdInfo.cmdList.list), CmdItemNode, list) {
+        if ((cmdType == cmdItemNode->cmd->cmdType) &&
+            ((strlen(cmdKey) == strlen(cmdItemNode->cmd->cmdKey)) &&
+            (strncmp((CHAR *)(cmdItemNode->cmd->cmdKey), cmdKey, strlen(cmdKey)) == 0))) {
+            (VOID)LOS_MuxPost(cmdInfo.muxLock);
+            return OS_ERRNO_SHELL_CMDREG_CMD_EXIST;
+        }
+    }
+    (VOID)LOS_MuxPost(cmdInfo.muxLock);
+
+    return OsCmdItemCreate(cmdType, cmdKey, paraNum, cmdProc);
+}
+
diff --git a/kernel/liteos_m/components/shell/src/base/shcmdparse.c b/kernel/liteos_m/components/shell/src/base/shcmdparse.c
new file mode 100644
index 0000000..974f0ac
--- /dev/null
+++ b/kernel/liteos_m/components/shell/src/base/shcmdparse.c
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "shcmd.h"
+#include "los_memory.h"
+
+
+/*
+ * Filter out double quote or single-quoted strings at both ends
+ */
+LITE_OS_SEC_TEXT_MINOR CHAR *OsCmdParseStrdup(const CHAR *str)
+{
+    CHAR *tempStr = NULL;
+    CHAR *newStr = NULL;
+
+    newStr = (CHAR *)LOS_MemAlloc(m_aucSysMem0, strlen(str) + 1);
+    if (newStr == NULL) {
+        return NULL;
+    }
+
+    tempStr = newStr;
+    for (; *str != '\0'; str++) {
+        if ((*str == '\"') || (*str == '\'')) {
+            continue;
+        }
+        *newStr = *str;
+        newStr++;
+    }
+    *newStr = '\0';
+    return tempStr;
+}
+
+LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdParseParaGet(CHAR **value, const CHAR *paraTokenStr)
+{
+    if ((paraTokenStr == NULL) || (value == NULL)) {
+        return (UINT32)OS_ERROR;
+    }
+
+    *value = OsCmdParseStrdup(paraTokenStr);
+    if (*value == NULL) {
+        return LOS_NOK;
+    }
+    return LOS_OK;
+}
+
+LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdParseOneToken(CmdParsed *cmdParsed, UINT32 index, const CHAR *token)
+{
+    UINT32 ret = LOS_OK;
+    UINT32 tempLen;
+
+    if (cmdParsed == NULL) {
+        return (UINT32)OS_ERROR;
+    }
+
+    if (index == 0) {
+        if (cmdParsed->cmdType != CMD_TYPE_STD) {
+            return ret;
+        }
+    }
+
+    if ((token != NULL) && (cmdParsed->paramCnt < CMD_MAX_PARAS)) {
+        tempLen = cmdParsed->paramCnt;
+        ret = OsCmdParseParaGet(&(cmdParsed->paramArray[tempLen]), token);
+        if (ret != LOS_OK) {
+            return ret;
+        }
+        cmdParsed->paramCnt++;
+    }
+    return ret;
+}
+
+LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdTokenSplit(CHAR *cmdStr, CHAR split, CmdParsed *cmdParsed)
+{
+    enum {
+        STAT_INIT,
+        STAT_TOKEN_IN,
+        STAT_TOKEN_OUT
+    } state = STAT_INIT;
+    UINT32 count = 0;
+    CHAR *p = NULL;
+    CHAR *token = cmdStr;
+    UINT32 ret = LOS_OK;
+    BOOL quotes = FALSE;
+
+    if (cmdStr == NULL) {
+        return (UINT32)OS_ERROR;
+    }
+
+    for (p = cmdStr; (*p != '\0') && (ret == LOS_OK); p++) {
+        if (*p == '\"') {
+            SWITCH_QUOTES_STATUS(quotes);
+        }
+        switch (state) {
+            case STAT_INIT:
+            case STAT_TOKEN_IN:
+                if ((*p == split) && QUOTES_STATUS_CLOSE(quotes)) {
+                    *p = '\0';
+                    ret = OsCmdParseOneToken(cmdParsed, count++, token);
+                    state = STAT_TOKEN_OUT;
+                }
+                break;
+            case STAT_TOKEN_OUT:
+                if (*p != split) {
+                    token = p;
+                    state = STAT_TOKEN_IN;
+                }
+                break;
+            default:
+                break;
+        }
+    }
+
+    if (((ret == LOS_OK) && (state == STAT_TOKEN_IN)) || (state == STAT_INIT)) {
+        ret = OsCmdParseOneToken(cmdParsed, count, token);
+    }
+
+    return ret;
+}
+
+LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdParse(CHAR *cmdStr, CmdParsed *cmdParsed)
+{
+    if ((cmdStr == NULL) || (cmdParsed == NULL) || (strlen(cmdStr) == 0)) {
+        return (UINT32)OS_ERROR;
+    }
+    return OsCmdTokenSplit(cmdStr, ' ', cmdParsed);
+}
+
diff --git a/kernel/liteos_m/components/shell/src/base/shmsg.c b/kernel/liteos_m/components/shell/src/base/shmsg.c
new file mode 100644
index 0000000..ea7b4b3
--- /dev/null
+++ b/kernel/liteos_m/components/shell/src/base/shmsg.c
@@ -0,0 +1,223 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "shmsg.h"
+#include "shcmd.h"
+#include "show.h"
+#include "securec.h"
+
+UINT32 ShellMsgTypeGet(CmdParsed *cmdParsed, const CHAR *cmdType)
+{
+    CmdItemNode *curCmdItem = (CmdItemNode *)NULL;
+    UINT32 len;
+    UINT32 minLen;
+    CmdModInfo *cmdInfo = OsCmdInfoGet();
+
+    if ((cmdParsed == NULL) || (cmdType == NULL)) {
+        return OS_INVALID;
+    }
+
+    len = strlen(cmdType);
+    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &(cmdInfo->cmdList.list), CmdItemNode, list) {
+        if ((len == strlen(curCmdItem->cmd->cmdKey)) &&
+            (strncmp((CHAR *)(curCmdItem->cmd->cmdKey), cmdType, len) == 0)) {
+            minLen = (len < CMD_KEY_LEN) ? len : CMD_KEY_LEN;
+            (VOID)memcpy_s((CHAR *)(cmdParsed->cmdKeyword), CMD_KEY_LEN, cmdType, minLen);
+            cmdParsed->cmdType = curCmdItem->cmd->cmdType;
+            return LOS_OK;
+        }
+    }
+
+    return OS_INVALID;
+}
+
+char *GetCmdName(const char *cmdline, unsigned int len)
+{
+    unsigned int loop;
+    const char *tmpStr = NULL;
+    BOOL quotes = FALSE;
+    char *cmdName = NULL;
+    if (cmdline == NULL) {
+        return NULL;
+    }
+
+    cmdName = (char *)malloc(len + 1);
+    if (cmdName == NULL) {
+        PRINTK("malloc failure in %s[%d]\n", __FUNCTION__, __LINE__);
+        return NULL;
+    }
+
+    /* Scan the 'cmdline' string for command */
+    /* Notice: Command string must not have any special name */
+    for (tmpStr = cmdline, loop = 0; (*tmpStr != '\0') && (loop < len);) {
+        /* If reach a double quotes, switch the quotes matching status */
+        if (*tmpStr == '\"') {
+            SWITCH_QUOTES_STATUS(quotes);
+            /* Ignore the double quote charactor itself */
+            tmpStr++;
+            continue;
+        }
+        /* If detected a space which the quotes matching status is false */
+        /* which said has detected the first space for seperator, finish this scan operation */
+        if ((*tmpStr == ' ') && (QUOTES_STATUS_CLOSE(quotes))) {
+            break;
+        }
+        cmdName[loop] = *tmpStr++;
+        loop++;
+    }
+    cmdName[loop] = '\0';
+
+    return cmdName;
+}
+
+int ShellCmdExec(const char *msgName, const char *cmdString)
+{
+    unsigned int uintRet;
+    errno_t err;
+    CmdParsed cmdParsed;
+
+    if (msgName == NULL || cmdString == NULL) {
+        return -EFAULT;
+    }
+    err = memset_s(&cmdParsed, sizeof(CmdParsed), 0, sizeof(CmdParsed));
+    if (err != EOK) {
+        return -EFAULT;
+    }
+
+    uintRet = ShellMsgTypeGet(&cmdParsed, msgName);
+
+    if (uintRet != LOS_OK) {
+        PRINTK("%s:command not found\n", msgName);
+        return -EFAULT;
+    } else {
+
+        (void)OsCmdExec(&cmdParsed, (char *)cmdString);
+    }
+    return 0;
+}
+
+unsigned int PreHandleCmdline(const char *input, char **output, unsigned int *outputlen)
+{
+    unsigned int shiftLen;
+    unsigned int ret;
+    const char *cmdBuf = input;
+    unsigned int cmdBufLen = strlen(cmdBuf);
+    char *shiftStr = (char *)malloc(cmdBufLen + 1);
+
+    if (shiftStr == NULL) {
+        PRINTK("malloc failure in %s[%d]\n", __FUNCTION__, __LINE__);
+        return SH_NOK;
+    }
+    (void)memset_s(shiftStr, cmdBufLen + 1, 0, cmdBufLen + 1);
+
+    /* Call function 'OsCmdKeyShift' to squeeze and clear useless or overmuch space if string buffer */
+    ret = OsCmdKeyShift(cmdBuf, shiftStr, cmdBufLen + 1);
+    shiftLen = strlen(shiftStr);
+    if ((ret != SH_OK) || (shiftLen == 0)) {
+        ret = SH_NOK;
+        goto END_FREE_SHIFTSTR;
+    }
+    *output = shiftStr;
+    *outputlen = shiftLen;
+
+    ret = SH_OK;
+    goto END;
+
+END_FREE_SHIFTSTR:
+    free(shiftStr);
+END:
+    return ret;
+}
+
+static void ParseAndExecCmdline(CmdParsed *cmdParsed, const char *cmdline, unsigned int len)
+{
+    int i;
+    unsigned int ret;
+    char *cmdlineOrigin = NULL;
+    char *cmdName = NULL;
+
+    cmdlineOrigin = strdup(cmdline);
+    if (cmdlineOrigin == NULL) {
+        PRINTK("malloc failure in %s[%d]\n", __FUNCTION__, __LINE__);
+        return;
+    }
+
+    cmdName = GetCmdName(cmdline, len);
+    if (cmdName == NULL) {
+        free(cmdlineOrigin);
+        PRINTK("malloc failure in %s[%d]\n", __FUNCTION__, __LINE__);
+        return;
+    }
+
+    ret = OsCmdParse((char *)cmdline, cmdParsed);
+    if (ret != SH_OK) {
+        PRINTK("cmd parse failure in %s[%d]\n", __FUNCTION__, __LINE__);
+        goto OUT;
+    }
+
+    (void)ShellCmdExec(cmdName, cmdlineOrigin);
+
+OUT:
+    for (i = 0; i < cmdParsed->paramCnt; i++) {
+        if (cmdParsed->paramArray[i] != NULL) {
+            free(cmdParsed->paramArray[i]);
+            cmdParsed->paramArray[i] = NULL;
+        }
+    }
+    free(cmdName);
+    free(cmdlineOrigin);
+}
+
+LITE_OS_SEC_TEXT_MINOR void ExecCmdline(const char *cmdline)
+{
+    unsigned int ret;
+    char *output = NULL;
+    unsigned int outputlen;
+    CmdParsed cmdParsed;
+
+    if (cmdline == NULL) {
+        return;
+    }
+
+    OsShellInit(0);
+
+    /* strip out unnecessary characters */
+    ret = PreHandleCmdline(cmdline, &output, &outputlen);
+    if (ret == SH_NOK) {
+        return;
+    }
+
+    (void)memset_s(&cmdParsed, sizeof(CmdParsed), 0, sizeof(CmdParsed));
+    ParseAndExecCmdline(&cmdParsed, output, outputlen);
+    free(output);
+}
+
diff --git a/kernel/liteos_m/components/shell/src/base/show.c b/kernel/liteos_m/components/shell/src/base/show.c
new file mode 100644
index 0000000..b1fcaf1
--- /dev/null
+++ b/kernel/liteos_m/components/shell/src/base/show.c
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "show.h"
+#include "shmsg.h"
+#include "shcmd.h"
+
+
+STATIC BOOL g_shellSourceFlag = FALSE;
+
+STATIC UINT32 OsShellCmdInit(VOID)
+{
+    UINT32 ret = OsCmdInit();
+    if (ret != LOS_OK) {
+        return ret;
+    }
+
+    return OsShellSysCmdRegister();
+}
+
+UINT32 OsShellInit(INT32 consoleId)
+{
+    if (g_shellSourceFlag == FALSE) {
+        UINT32 ret = OsShellCmdInit();
+        if (ret == LOS_OK) {
+            g_shellSourceFlag = TRUE;
+        } else {
+            return ret;
+        }
+    }
+
+    return 0;
+}
+
diff --git a/kernel/liteos_m/components/shell/src/cmds/date_shell.c b/kernel/liteos_m/components/shell/src/cmds/date_shell.c
new file mode 100644
index 0000000..efa9727
--- /dev/null
+++ b/kernel/liteos_m/components/shell/src/cmds/date_shell.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "shcmd.h"
+#include "shell.h"
+#include "stdlib.h"
+#include "sys/time.h"
+#include "sys/stat.h"
+#include "securec.h"
+
+#define  DATE_ERR           (-1)
+#define  DATE_OK            0
+
+INT32 OsShellCmdDate(INT32 argc, const CHAR **argv)
+{
+    struct timeval nowTime;
+
+    if (argc == 1) { /* 1:count of parameters */
+        if (gettimeofday(&nowTime, NULL)) {
+            return DATE_ERR;
+        }
+        PRINTK("%s\n", ctime(&nowTime.tv_sec));
+        return DATE_OK;
+    }
+
+    return DATE_OK;
+}
+
diff --git a/kernel/liteos_m/components/shell/src/cmds/fullpath.c b/kernel/liteos_m/components/shell/src/cmds/fullpath.c
new file mode 100644
index 0000000..457a970
--- /dev/null
+++ b/kernel/liteos_m/components/shell/src/cmds/fullpath.c
@@ -0,0 +1,271 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "stdio.h"
+#include "stdlib.h"
+#include "string.h"
+#include "errno.h"
+#include "limits.h"
+#include "shell.h"
+#include "show.h"
+
+#define TEMP_PATH_MAX (PATH_MAX + SHOW_MAX_LEN)
+
+static unsigned int VfsStrnlen(const char *str, size_t maxlen)
+{
+    const char *p = NULL;
+
+    for (p = str; ((maxlen-- != 0) && (*p != '\0')); ++p) {}
+
+    return p - str;
+}
+
+/* abandon the redundant '/' in the path, only keep one. */
+static char *StrPath(char *path)
+{
+    char *dest = path;
+    char *src = path;
+
+    while (*src != '\0') {
+        if (*src == '/') {
+            *dest++ = *src++;
+            while (*src == '/') {
+                src++;
+            }
+            continue;
+        }
+        *dest++ = *src++;
+    }
+    *dest = '\0';
+    return path;
+}
+
+static void StrRemovePathEndSlash(char *dest, const char *fullpath)
+{
+    if ((*dest == '.') && (*(dest - 1) == '/')) {
+        *dest = '\0';
+        dest--;
+    }
+    if ((dest != fullpath) && (*dest == '/')) {
+        *dest = '\0';
+    }
+}
+
+static char *StrNormalizePath(char *fullpath)
+{
+    char *dest = fullpath;
+    char *src = fullpath;
+
+    /* 2: The position of the path character: / and the end character /0 */
+    while (*src != '\0') {
+        if (*src == '.') {
+            if (*(src + 1) == '/') {
+                src += 2;
+                continue;
+            } else if (*(src + 1) == '.') {
+                if ((*(src + 2) == '/') || (*(src + 2) == '\0')) {
+                    src += 2;
+                } else {
+                    while ((*src != '\0') && (*src != '/')) {
+                        *dest++ = *src++;
+                    }
+                    continue;
+                }
+            } else {
+                *dest++ = *src++;
+                continue;
+            }
+        } else {
+            *dest++ = *src++;
+            continue;
+        }
+
+        if ((dest - 1) != fullpath) {
+            dest--;
+        }
+
+        while ((dest > fullpath) && (*(dest - 1) != '/')) {
+            dest--;
+        }
+
+        if (*src == '/') {
+            src++;
+        }
+    }
+
+    *dest = '\0';
+
+    /* remove '/' in the end of path if exist */
+
+    dest--;
+
+    StrRemovePathEndSlash(dest, fullpath);
+    return dest;
+}
+
+static int VfsNormalizePathParameCheck(const char *filename, char **pathname)
+{
+    int namelen;
+    char *name = NULL;
+
+    if (pathname == NULL) {
+        return -EINVAL;
+    }
+
+    /* check parameters */
+
+    if (filename == NULL) {
+        *pathname = NULL;
+        return -EINVAL;
+    }
+
+    namelen = VfsStrnlen(filename, PATH_MAX);
+    if (!namelen) {
+        *pathname = NULL;
+        return -EINVAL;
+    } else if (namelen >= PATH_MAX) {
+        *pathname = NULL;
+        return -ENAMETOOLONG;
+    }
+
+    for (name = (char *)filename + namelen; ((name != filename) && (*name != '/')); name--) {
+        if (strlen(name) > NAME_MAX) {
+            *pathname = NULL;
+            return -ENAMETOOLONG;
+        }
+    }
+
+    return namelen;
+}
+
+static char *VfsNotAbsolutePath(const char *directory, const char *filename, char **pathname, int namelen)
+{
+    int ret;
+    char *fullpath = NULL;
+
+    /* 2: The position of the path character: / and the end character /0 */
+
+    if ((namelen > 1) && (filename[0] == '.') && (filename[1] == '/')) {
+        filename += 2;
+    }
+
+    fullpath = (char *)malloc(strlen(directory) + namelen + 2);
+    if (fullpath == NULL) {
+        *pathname = NULL;
+        SetErrno(ENOMEM);
+        return (char *)NULL;
+    }
+
+    /* join path and file name */
+
+    ret = snprintf_s(fullpath, strlen(directory) + namelen + 2, strlen(directory) + namelen + 1,
+                     "%s/%s", directory, filename);
+    if (ret < 0) {
+        *pathname = NULL;
+        free(fullpath);
+        SetErrno(ENAMETOOLONG);
+        return (char *)NULL;
+    }
+
+    return fullpath;
+}
+
+static char *VfsNormalizeFullpath(const char *directory, const char *filename, char **pathname, int namelen)
+{
+    char *fullpath = NULL;
+
+    if (filename[0] != '/') {
+        /* not a absolute path */
+
+        fullpath = VfsNotAbsolutePath(directory, filename, pathname, namelen);
+        if (fullpath == NULL) {
+            return (char *)NULL;
+        }
+    } else {
+        /* it's a absolute path, use it directly */
+
+        fullpath = strdup(filename); /* copy string */
+
+        if (fullpath == NULL) {
+            *pathname = NULL;
+            SetErrno(ENOMEM);
+            return (char *)NULL;
+        }
+        if (filename[1] == '/') {
+            *pathname = NULL;
+            free(fullpath);
+            SetErrno(EINVAL);
+            return (char *)NULL;
+        }
+    }
+
+    return fullpath;
+}
+
+int VfsNormalizePath(const char *directory, const char *filename, char **pathname)
+{
+    char *fullpath = NULL;
+    int namelen;
+
+    namelen = VfsNormalizePathParameCheck(filename, pathname);
+    if (namelen < 0) {
+        return namelen;
+    }
+
+    if ((directory == NULL) && (filename[0] != '/')) {
+        PRINT_ERR("NO_WORKING_DIR\n");
+        *pathname = NULL;
+        return -EINVAL;
+    }
+
+    /* 2: The position of the path character: / and the end character /0 */
+
+    if ((filename[0] != '/') && (strlen(directory) + namelen + 2 > TEMP_PATH_MAX)) {
+        return -ENAMETOOLONG;
+    }
+
+    fullpath = VfsNormalizeFullpath(directory, filename, pathname, namelen);
+    if (fullpath == NULL) {
+        return -errno;
+    }
+
+    (void)StrPath(fullpath);
+    (void)StrNormalizePath(fullpath);
+    if (strlen(fullpath) >= PATH_MAX) {
+        *pathname = NULL;
+        free(fullpath);
+        return -ENAMETOOLONG;
+    }
+
+    *pathname = fullpath;
+    return 0;
+}
+
diff --git a/kernel/liteos_m/components/shell/src/cmds/mempt_shellcmd.c b/kernel/liteos_m/components/shell/src/cmds/mempt_shellcmd.c
new file mode 100644
index 0000000..8dbb1ae
--- /dev/null
+++ b/kernel/liteos_m/components/shell/src/cmds/mempt_shellcmd.c
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "stdlib.h"
+#include "shcmd.h"
+#include "shell.h"
+
+#define MEM_SIZE_1K 0x400
+#define MEM_SIZE_1M 0x100000
+
+#define MEM_SIZE_TO_KB(size) (((size) + (MEM_SIZE_1K >> 1)) / MEM_SIZE_1K)
+#define MEM_SIZE_TO_MB(size) (((size) + (MEM_SIZE_1M >> 1)) / MEM_SIZE_1M)
+
+LITE_OS_SEC_TEXT_MINOR STATIC UINT32 OsShellCmdFreeInfo(INT32 argc, const CHAR *argv[])
+{
+    UINT32 memUsed = LOS_MemTotalUsedGet(m_aucSysMem0);
+    UINT32 totalMem = LOS_MemPoolSizeGet(m_aucSysMem0);
+    UINT32 freeMem = totalMem - memUsed;
+
+    if ((argc == 0) ||
+        ((argc == 1) && (strcmp(argv[0], "-k") == 0)) ||
+        ((argc == 1) && (strcmp(argv[0], "-m") == 0))) {
+        PRINTK("\r\n        total        used          free\n");
+    }
+
+    if ((argc == 1) && (strcmp(argv[0], "-k") == 0)) {
+        PRINTK("Mem:    %-9u    %-10u    %-10u\n", MEM_SIZE_TO_KB(totalMem), MEM_SIZE_TO_KB(memUsed),
+               MEM_SIZE_TO_KB(freeMem));
+    } else if ((argc == 1) && (strcmp(argv[0], "-m") == 0)) {
+        PRINTK("Mem:    %-9u    %-10u    %-10u\n", MEM_SIZE_TO_MB(totalMem), MEM_SIZE_TO_MB(memUsed),
+               MEM_SIZE_TO_MB(freeMem));
+    } else if (argc == 0) {
+        PRINTK("Mem:    %-9u    %-10u    %-10u\n", totalMem, memUsed, freeMem);
+    } else {
+        PRINTK("\nUsage: free or free [-k/-m]\n");
+        return OS_ERROR;
+    }
+    return 0;
+}
+
+LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdFree(INT32 argc, const CHAR *argv[])
+{
+    if (argc > 1) {
+        PRINTK("\nUsage: free or free [-k/-m]\n");
+        return OS_ERROR;
+    }
+    if (OsShellCmdFreeInfo(argc, argv) != 0) {
+        return OS_ERROR;
+    }
+    return 0;
+}
+
diff --git a/kernel/liteos_m/components/shell/src/cmds/shell_shellcmd.c b/kernel/liteos_m/components/shell/src/cmds/shell_shellcmd.c
new file mode 100644
index 0000000..45b56d7
--- /dev/null
+++ b/kernel/liteos_m/components/shell/src/cmds/shell_shellcmd.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "shcmd.h"
+
+INT32 OsShellCmdHelp(INT32 argc, const CHAR **argv)
+{
+    UINT32 loop = 0;
+    CmdItemNode *curCmdItem = NULL;
+    CmdModInfo *cmdInfo = OsCmdInfoGet();
+
+    (VOID)argv;
+    if (argc > 0) {
+        PRINTK("\nUsage: help\n");
+        return OS_ERROR;
+    }
+
+    PRINTK("*******************shell commands:*************************\n");
+    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &(cmdInfo->cmdList.list), CmdItemNode, list) {
+        if ((loop & (8 - 1)) == 0) { /* 8 - 1:just align print */
+            PRINTK("\n");
+        }
+        PRINTK("%-12s  ", curCmdItem->cmd->cmdKey);
+
+        loop++;
+    }
+
+    PRINTK("\n");
+    return 0;
+}
diff --git a/kernel/liteos_m/components/shell/src/cmds/task_shellcmd.c b/kernel/liteos_m/components/shell/src/cmds/task_shellcmd.c
new file mode 100644
index 0000000..1c055e8
--- /dev/null
+++ b/kernel/liteos_m/components/shell/src/cmds/task_shellcmd.c
@@ -0,0 +1,154 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "stdlib.h"
+#include "los_config.h"
+#include "los_task.h"
+#include "los_sem.h"
+#include "shcmd.h"
+#include "shell.h"
+
+#define OS_INVALID_SEM_ID  0xFFFFFFFF
+#define OS_ALL_TASK_MASK   0xFFFFFFFF
+
+LITE_OS_SEC_TEXT_MINOR UINT8 *OsShellCmdConvertTskStatus(UINT16 taskStatus)
+{
+    if (taskStatus & OS_TASK_STATUS_RUNNING) {
+        return (UINT8 *)"Running";
+    } else if (taskStatus & OS_TASK_STATUS_READY) {
+        return (UINT8 *)"Ready";
+    } else {
+        if (taskStatus & OS_TASK_STATUS_DELAY) {
+            return (UINT8 *)"Delay";
+        } else if (taskStatus & OS_TASK_STATUS_PEND_TIME) {
+            return (UINT8 *)"PendTime";
+        } else if (taskStatus & OS_TASK_STATUS_PEND) {
+            return (UINT8 *)"Pend";
+        } else if (taskStatus & OS_TASK_STATUS_SUSPEND) {
+            return (UINT8 *)"Suspend";
+        }
+    }
+
+    return (UINT8 *)"Invalid";
+}
+
+LITE_OS_SEC_TEXT_MINOR STATIC VOID OsShellCmdTskInfoTitle(VOID)
+{
+    PRINTK("\r\nName                   TaskEntryAddr       TID    ");
+
+    PRINTK("Priority   Status       "
+           "StackSize       StackPoint   TopOfStack");
+
+    PRINTK("\n");
+    PRINTK("----                   -------------       ---    ");
+    PRINTK("--------   --------     "
+           "---------       ----------   ----------");
+    PRINTK("\n");
+}
+
+LITE_OS_SEC_TEXT_MINOR STATIC INLINE UINT32 OsGetSemID(const LosTaskCB *taskCB)
+{
+    UINT32 semId = OS_INVALID_SEM_ID;
+
+    if (taskCB->taskSem != NULL) {
+        semId = ((LosSemCB *)taskCB->taskSem)->semID;
+    }
+
+    return semId;
+}
+
+LITE_OS_SEC_TEXT_MINOR STATIC VOID OsShellCmdTskInfoData(const LosTaskCB *allTaskArray)
+{
+    const LosTaskCB *taskCB = NULL;
+    UINT32 loop;
+    UINT32 semId;
+
+    for (loop = 0; loop < g_taskMaxNum; ++loop) {
+        taskCB = allTaskArray + loop;
+        if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
+            continue;
+        }
+
+        semId = OsGetSemID(taskCB);
+
+        PRINTK("%-23s%-20p0x%-5x", taskCB->taskName, taskCB->taskEntry, taskCB->taskID);
+        PRINTK("%-11u%-13s0x%-11x   0x%-8x   0x%-10x   ", taskCB->priority,
+               OsShellCmdConvertTskStatus(taskCB->taskStatus), taskCB->stackSize,
+               taskCB->stackPointer, taskCB->topOfStack, semId);
+        PRINTK("\n");
+    }
+}
+
+LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdTskInfoGet(UINT32 taskId)
+{
+    BOOL backupFlag = TRUE;
+    UINT32 size;
+    LosTaskCB *tcbArray = NULL;
+    INT32 ret;
+
+    if (taskId == OS_ALL_TASK_MASK) {
+        size = g_taskMaxNum * sizeof(LosTaskCB);
+        tcbArray = (LosTaskCB *)LOS_MemAlloc(m_aucSysMem0, size);
+        if (tcbArray == NULL) {
+            PRINTK("Memory is not enough to save task info!\n");
+            tcbArray = g_taskCBArray;
+            backupFlag = FALSE;
+        }
+        if (backupFlag == TRUE) {
+            ret = memcpy_s(tcbArray, size, g_taskCBArray, size);
+            if (ret != 0) {
+                return LOS_NOK;
+            }
+        }
+
+        OsShellCmdTskInfoTitle();
+        OsShellCmdTskInfoData(tcbArray);
+
+        if (backupFlag == TRUE) {
+            (VOID)LOS_MemFree(m_aucSysMem0, tcbArray);
+        }
+    }
+
+    return LOS_OK;
+}
+
+INT32 OsShellCmdDumpTask(INT32 argc, const CHAR **argv)
+{
+    size_t taskId = OS_ALL_TASK_MASK;
+
+    if (argc < 1) {
+        return OsShellCmdTskInfoGet((UINT32)taskId);
+    } else {
+        PRINTK("\nUsage: task\n");
+        return OS_ERROR;
+    }
+}
+
diff --git a/kernel/liteos_m/components/shell/src/cmds/vfs_shellcmd.c b/kernel/liteos_m/components/shell/src/cmds/vfs_shellcmd.c
new file mode 100644
index 0000000..c3a6cbc
--- /dev/null
+++ b/kernel/liteos_m/components/shell/src/cmds/vfs_shellcmd.c
@@ -0,0 +1,953 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_config.h"
+
+#include "los_task.h"
+#include "shell.h"
+#include "sys/stat.h"
+#include "stdlib.h"
+#include "unistd.h"
+#include "fcntl.h"
+#include "stdio.h"
+#include "pthread.h"
+
+#include "shcmd.h"
+#include "securec.h"
+#include "show.h"
+
+#include <dirent.h>
+#include <ctype.h>
+
+#define VFS_ERROR OS_ERROR
+#define SHOW_MAX_LEN CMD_MAX_LEN
+#define TEMP_PATH_MAX (PATH_MAX + SHOW_MAX_LEN)
+
+typedef enum {
+    RM_RECURSIVER,
+    RM_FILE,
+    RM_DIR,
+    CP_FILE,
+    CP_COUNT
+} wildcard_type;
+
+#define ERROR_OUT_IF(condition, message_function, handler) \
+    do { \
+        if (condition) { \
+            message_function; \
+            handler; \
+        } \
+    } while (0)
+
+int OsShellCmdDoChdir(const char *path)
+{
+    char *fullpath = NULL;
+    char *fullpathBak = NULL;
+    DIR *dirent = NULL;
+    int ret;
+    char *shellWorkingDirectory = OsShellGetWorkingDirtectory();
+    if (shellWorkingDirectory == NULL) {
+        return -1;
+    }
+
+    if (path == NULL) {
+        LOS_TaskLock();
+        PRINTK("%s\n", shellWorkingDirectory);
+        LOS_TaskUnlock();
+        return 0;
+    }
+
+    ERROR_OUT_IF(strlen(path) > PATH_MAX, SetErr(ENOTDIR, "cd error"), return -1);
+
+    ret = VfsNormalizePath(shellWorkingDirectory, path, &fullpath);
+    ERROR_OUT_IF(ret < 0, SetErr(-ret, "cd error"), return -1);
+
+    fullpathBak = fullpath;
+    dirent = opendir(fullpath);
+    if (dirent == NULL) {
+        free(fullpathBak);
+        /* this is a not exist directory */
+        PRINTK("no such file or directory\n");
+        return -1;
+    }
+
+    /* close directory stream */
+    (void)closedir(dirent);
+
+    /* copy full path to working directory */
+    LOS_TaskLock();
+    ret = strncpy_s(shellWorkingDirectory, PATH_MAX, fullpath, strlen(fullpath));
+    if (ret != EOK) {
+        free(fullpathBak);
+        LOS_TaskUnlock();
+        return -1;
+    }
+    LOS_TaskUnlock();
+    /* release normalize directory path name */
+
+    free(fullpathBak);
+    return 0;
+}
+
+static char *OsLsGetFullpath(const char *path, struct dirent *pdirent)
+{
+    char *fullpath = NULL;
+    int ret;
+
+    if (path[1] != '\0') {
+        fullpath = (char *)malloc(strlen(path) + strlen(pdirent->d_name) + 2);
+        if (fullpath == NULL) {
+            goto exit_with_nomem;
+        }
+
+        ret = snprintf_s(fullpath, strlen(path) + strlen(pdirent->d_name) + 2,
+                         strlen(path) + strlen(pdirent->d_name) + 1, "%s/%s", path, pdirent->d_name);
+        if (ret < 0) {
+            free(fullpath);
+            return NULL;
+        }
+    } else {
+        fullpath = (char *)malloc(strlen(pdirent->d_name) + 2);
+        if (fullpath == NULL) {
+            goto exit_with_nomem;
+        }
+
+        ret = snprintf_s(fullpath, strlen(pdirent->d_name) + 2, strlen(pdirent->d_name) + 1,
+                         "/%s", pdirent->d_name);
+        if (ret < 0) {
+            free(fullpath);
+            return NULL;
+        }
+    }
+return fullpath;
+exit_with_nomem:
+    return (char *)NULL;
+}
+
+void OsLs(const char *pathname)
+{
+    struct dirent *pdirent = NULL;
+    char *path = NULL;
+    char *fullpath = NULL;
+    char *fullpathBak = NULL;
+    int ret;
+    struct stat statInfo = { 0 };
+    DIR *d = NULL;
+
+    /* list all directory and file */
+    if (pathname == NULL) {
+        path = strdup("/");
+        if (path == NULL) {
+            return;
+        }
+    } else {
+        ret = VfsNormalizePath(NULL, pathname, &path);
+        if (ret < 0) {
+            SetErrno(-ret);
+            return;
+        }
+    }
+
+    d = opendir(path);
+    if (d == NULL) {
+        PRINT_ERR("No such directory = %s\n", path);
+    } else {
+        PRINTK("Directory %s:\n", path);
+        do {
+            pdirent = readdir(d);
+            if (pdirent != NULL) {
+                (void)memset_s(&statInfo, sizeof(struct stat), 0, sizeof(struct stat));
+                fullpath = OsLsGetFullpath(path, pdirent);
+                if (fullpath == NULL) {
+                    free(path);
+                    (void)closedir(d);
+                    return;
+                }
+
+                fullpathBak = fullpath;
+                if (stat(fullpath, &statInfo) == 0) {
+                    PRINTK("%-20s", pdirent->d_name);
+                    if (S_ISDIR(statInfo.st_mode)) {
+                        PRINTK(" %-25s\n", "<DIR>");
+                    } else {
+                        PRINTK(" %-25lu\n", statInfo.st_size);
+                    }
+                } else {
+                    PRINTK("BAD file: %s\n", pdirent->d_name);
+                }
+                free(fullpathBak);
+            }
+        } while (pdirent != NULL);
+
+        (void)closedir(d);
+    }
+}
+
+int OsShellCmdLs(int argc, const char **argv)
+{
+    char *fullpath = NULL;
+    const char *filename = NULL;
+    int ret;
+    char *shellWorkingDirectory = OsShellGetWorkingDirtectory();
+    if (shellWorkingDirectory == NULL) {
+        return -1;
+    }
+
+    ERROR_OUT_IF(argc > 1, PRINTK("ls or ls [DIRECTORY]\n"), return -1);
+
+    if (argc == 0) {
+        OsLs(shellWorkingDirectory);
+        return 0;
+    }
+
+    filename = argv[0];
+    ret = VfsNormalizePath(shellWorkingDirectory, filename, &fullpath);
+    ERROR_OUT_IF(ret < 0, SetErr(-ret, "ls error"), return -1);
+
+    OsLs(fullpath);
+    free(fullpath);
+
+    return 0;
+}
+
+int OsShellCmdCd(int argc, const char **argv)
+{
+    if (argc == 0) {
+        (void)OsShellCmdDoChdir("/");
+        return 0;
+    }
+
+    OsShellCmdDoChdir(argv[0]);
+    return 0;
+}
+
+#define CAT_BUF_SIZE  512
+#define CAT_TASK_PRIORITY  10
+#define CAT_TASK_STACK_SIZE  0x3000
+pthread_mutex_t g_mutex_cat = PTHREAD_MUTEX_INITIALIZER;
+
+int OsShellCmdCat(int argc, const char **argv)
+{
+    char *fullpath = NULL;
+    int ret;
+    CHAR buf[CAT_BUF_SIZE];
+    size_t size;
+
+    char *shellWorkingDirectory = OsShellGetWorkingDirtectory();
+
+    if (shellWorkingDirectory == NULL) {
+        return -1;
+    }
+
+    ERROR_OUT_IF(argc != 1, PRINTK("cat [FILE]\n"), return -1);
+
+    ret = VfsNormalizePath(shellWorkingDirectory, argv[0], &fullpath);
+    ERROR_OUT_IF(ret < 0, SetErr(-ret, "cat error"), return -1);
+
+    int fd = open(fullpath, O_RDONLY, 0666);
+
+    if (fd == -1) {
+        ret = -1;
+        return ret;
+    }
+
+    do {
+        (void)memset_s(buf, sizeof(buf), 0, CAT_BUF_SIZE);
+        size = read(fd, buf, CAT_BUF_SIZE - 1);
+        if ((int)size < 0) {
+            free(fullpath);
+            close(fd);
+            return -1;
+        }
+        PRINTK("%s", buf);
+        (void)LOS_TaskDelay(1);
+    } while (size == CAT_BUF_SIZE);
+
+    free(fullpath);
+    close(fd);
+
+    return ret;
+}
+
+int OsShellCmdMkdir(int argc, const char **argv)
+{
+    int ret;
+    char *fullpath = NULL;
+    const char *filename = NULL;
+    char *shellWorkingDirectory = OsShellGetWorkingDirtectory();
+    if (shellWorkingDirectory == NULL) {
+        return -1;
+    }
+
+    ERROR_OUT_IF(argc != 1, PRINTK("mkdir [DIRECTORY]\n"), return 0);
+
+    filename = argv[0];
+    ret = VfsNormalizePath(shellWorkingDirectory, filename, &fullpath);
+    ERROR_OUT_IF(ret < 0, SetErr(-ret, "mkdir error"), return -1);
+
+    ret = mkdir(fullpath, S_IRWXU | S_IRWXG | S_IRWXO);
+    if (ret == -1) {
+        perror("mkdir error");
+    }
+    free(fullpath);
+    return 0;
+}
+
+int OsShellCmdPwd(int argc, const char **argv)
+{
+    char buf[SHOW_MAX_LEN] = {0};
+    DIR *dir = NULL;
+    char *shellWorkingDirectory = OsShellGetWorkingDirtectory();
+    if (shellWorkingDirectory == NULL) {
+        return -1;
+    }
+
+    ERROR_OUT_IF(argc > 0, PRINTK("\nUsage: pwd\n"), return -1);
+
+    LOS_TaskLock();
+    if (strncpy_s(buf, SHOW_MAX_LEN, shellWorkingDirectory, SHOW_MAX_LEN - 1) != EOK) {
+        LOS_TaskUnlock();
+        PRINTK("pwd error: strncpy_s error!\n");
+        return -1;
+    }
+    LOS_TaskUnlock();
+
+    PRINTK("%s\n", buf);
+    return 0;
+}
+
+int OsShellCmdTouch(int argc, const char **argv)
+{
+    int ret;
+    int fd = -1;
+    char *fullpath = NULL;
+    const char *filename = NULL;
+    char *shellWorkingDirectory = OsShellGetWorkingDirtectory();
+    if (shellWorkingDirectory == NULL) {
+        return -1;
+    }
+
+    ERROR_OUT_IF(argc != 1, PRINTK("touch [FILE]\n"), return -1);
+
+    filename = argv[0];
+    ret = VfsNormalizePath(shellWorkingDirectory, filename, &fullpath);
+    ERROR_OUT_IF(ret < 0, SetErr(-ret, "touch error"), return -1);
+
+    fd = open(fullpath, O_RDWR | O_CREAT, 0777);
+    free(fullpath);
+    if (fd == -1) {
+        perror("touch error");
+        return -1;
+    }
+
+    (void)close(fd);
+    return 0;
+}
+
+#define CP_BUF_SIZE 4096
+pthread_mutex_t g_mutexCp = PTHREAD_MUTEX_INITIALIZER;
+
+static int OsShellCmdDoCp(const char *srcFilePath, const char *dstFileName)
+{
+    int  ret;
+    char *srcFullPath = NULL;
+    char *drcFullPath = NULL;
+    const char *srcFileName = NULL;
+    char *dstFilePath = NULL;
+    char *buf = NULL;
+    const char *filename = NULL;
+    size_t rdSize, wrSize;
+    int srcFd = -1;
+    int dstFd = -1;
+    struct stat statBuf;
+    mode_t srcMode;
+    char *shellWorkingDirectory = OsShellGetWorkingDirtectory();
+    if (shellWorkingDirectory == NULL) {
+        return -1;
+    }
+
+    buf = (char *)malloc(CP_BUF_SIZE);
+    if (buf == NULL) {
+        PRINTK("cp error: Out of memory!\n");
+        return -1;
+    }
+
+    /* Get source fullpath. */
+    ret = VfsNormalizePath(shellWorkingDirectory, srcFilePath, &srcFullPath);
+    if (ret < 0) {
+        SetErrno(-ret);
+        PRINTK("cp error: %s\n", strerror(errno));
+        free(buf);
+        return -1;
+    }
+
+    /* Is source path exist? */
+    ret = stat(srcFullPath, &statBuf);
+    if (ret == -1) {
+        PRINTK("cp %s error: %s\n", srcFullPath, strerror(errno));
+        goto errout_with_srcpath;
+    }
+    srcMode = statBuf.st_mode;
+    /* Is source path a directory? */
+    if (S_ISDIR(statBuf.st_mode)) {
+        PRINTK("cp %s error: Source file can't be a directory.\n", srcFullPath);
+        goto errout_with_srcpath;
+    }
+
+    /* Get dest fullpath. */
+    drcFullPath = strdup(dstFileName);
+    if (drcFullPath == NULL) {
+        PRINTK("cp error: Out of memory.\n");
+        goto errout_with_srcpath;
+    }
+    /* Is dest path exist? */
+    ret = stat(drcFullPath, &statBuf);
+    if (ret == 0) {
+        /* Is dest path a directory? */
+        if (S_ISDIR(statBuf.st_mode)) {
+            /* Get source file name without '/'. */
+            srcFileName = srcFilePath;
+            while (1) {
+                filename = strchr(srcFileName, '/');
+                if (filename == NULL) {
+                    break;
+                }
+                srcFileName = filename + 1;
+            }
+            /* Add the source file after dest path. */
+            ret = VfsNormalizePath(drcFullPath, srcFileName, &dstFilePath);
+            if (ret < 0) {
+                SetErrno(-ret);
+                PRINTK("cp error. %s.\n", strerror(errno));
+                goto errout_with_path;
+            }
+            free(drcFullPath);
+            drcFullPath = dstFilePath;
+        }
+    }
+
+    /* Is dest file same as source file? */
+    if (strcmp(srcFullPath, drcFullPath) == 0) {
+        PRINTK("cp error: '%s' and '%s' are the same file\n", srcFullPath, drcFullPath);
+        goto errout_with_path;
+    }
+
+    /* Copy begins. */
+    (void)pthread_mutex_lock(&g_mutexCp);
+    srcFd = open(srcFullPath, O_RDONLY);
+    if (srcFd < 0) {
+        PRINTK("cp error: can't open %s. %s.\n", srcFullPath, strerror(errno));
+        goto errout_with_mutex;
+    }
+
+    dstFd = open(drcFullPath, O_CREAT | O_WRONLY | O_TRUNC, srcMode);
+    if (dstFd < 0) {
+        PRINTK("cp error: can't create %s. %s.\n", drcFullPath, strerror(errno));
+        goto errout_with_srcfd;
+    }
+
+    do {
+        (void)memset_s(buf, CP_BUF_SIZE, 0, CP_BUF_SIZE);
+        rdSize = read(srcFd, buf, CP_BUF_SIZE);
+        if (rdSize < 0) {
+            PRINTK("cp %s %s failed. %s.\n", srcFullPath, drcFullPath, strerror(errno));
+            goto errout_with_fd;
+        }
+        wrSize = write(dstFd, buf, rdSize);
+        if (wrSize != rdSize) {
+            PRINTK("cp %s %s failed. %s.\n", srcFullPath, drcFullPath, strerror(errno));
+            goto errout_with_fd;
+        }
+    } while (rdSize == CP_BUF_SIZE);
+
+    /* Release resource. */
+    free(buf);
+    free(srcFullPath);
+    free(drcFullPath);
+    (void)close(srcFd);
+    (void)close(dstFd);
+    (void)pthread_mutex_unlock(&g_mutexCp);
+    return LOS_OK;
+
+errout_with_fd:
+    (void)close(dstFd);
+errout_with_srcfd:
+    (void)close(srcFd);
+errout_with_mutex:
+    (void)pthread_mutex_unlock(&g_mutexCp);
+errout_with_path:
+    free(drcFullPath);
+errout_with_srcpath:
+    free(srcFullPath);
+    free(buf);
+    return -1;
+}
+
+/* The separator and EOF for a directory fullpath: '/'and '\0' */
+#define SEPARATOR_EOF_LEN 2
+
+static int OsShellCmdDoRmdir(const char *pathname)
+{
+    struct dirent *dirent = NULL;
+    struct stat statInfo;
+    DIR *d = NULL;
+    char *fullpath = NULL;
+    int ret;
+
+    (void)memset_s(&statInfo, sizeof(statInfo), 0, sizeof(struct stat));
+    if (stat(pathname, &statInfo) != 0) {
+        return -1;
+    }
+
+    if (S_ISREG(statInfo.st_mode) || S_ISLNK(statInfo.st_mode)) {
+        return remove(pathname);
+    }
+    d = opendir(pathname);
+    if (d == NULL) {
+        return -1;
+    }
+    while (1) {
+        dirent = readdir(d);
+        if (dirent == NULL) {
+            break;
+        }
+        if (strcmp(dirent->d_name, "..") && strcmp(dirent->d_name, ".")) {
+            size_t fullPathBufSize = strlen(pathname) + strlen(dirent->d_name) + SEPARATOR_EOF_LEN;
+            if (fullPathBufSize <= 0) {
+                PRINTK("buffer size is invalid!\n");
+                (void)closedir(d);
+                return -1;
+            }
+            fullpath = (char *)malloc(fullPathBufSize);
+            if (fullpath == NULL) {
+                PRINTK("malloc failure!\n");
+                (void)closedir(d);
+                return -1;
+            }
+            ret = snprintf_s(fullpath, fullPathBufSize, fullPathBufSize - 1, "%s/%s", pathname, dirent->d_name);
+            if (ret < 0) {
+                PRINTK("name is too long!\n");
+                free(fullpath);
+                (void)closedir(d);
+                return -1;
+            }
+            (void)OsShellCmdDoRmdir(fullpath);
+            free(fullpath);
+        }
+    }
+    (void)closedir(d);
+    return rmdir(pathname);
+}
+
+/*  Wildcard matching operations  */
+static int OsWildcardMatch(const char *src, const char *filename)
+{
+    int ret;
+
+    if (*src != '\0') {
+        if (*filename == '*') {
+            while ((*filename == '*') || (*filename == '?')) {
+                filename++;
+            }
+
+            if (*filename == '\0') {
+                return 0;
+            }
+
+            while (*src != '\0' && !(*src == *filename)) {
+                src++;
+            }
+
+            if (*src == '\0') {
+                return -1;
+            }
+
+            ret = OsWildcardMatch(src, filename);
+
+            while ((ret != 0) && (*(++src) != '\0')) {
+                if (*src == *filename) {
+                    ret = OsWildcardMatch(src, filename);
+                }
+            }
+            return ret;
+        } else {
+            if ((*src == *filename) || (*filename == '?')) {
+                return OsWildcardMatch(++src, ++filename);
+            }
+            return -1;
+        }
+    }
+
+    while (*filename != '\0') {
+        if (*filename != '*') {
+            return -1;
+        }
+        filename++;
+    }
+    return 0;
+}
+
+/*   To determine whether a wildcard character exists in a path   */
+static int OsIsContainersWildcard(const char *filename)
+{
+    while (*filename != '\0') {
+        if ((*filename == '*') || (*filename == '?')) {
+            return 1;
+        }
+        filename++;
+    }
+    return 0;
+}
+
+/*  Delete a matching file or directory  */
+
+static int OsWildcardDeleteFileOrDir(const char *fullpath, wildcard_type mark)
+{
+    int ret;
+
+    switch (mark) {
+        case RM_RECURSIVER:
+            ret = OsShellCmdDoRmdir(fullpath);
+            break;
+        case RM_FILE:
+            ret = unlink(fullpath);
+            break;
+        case RM_DIR:
+            ret = rmdir(fullpath);
+            break;
+        default:
+            return VFS_ERROR;
+    }
+    if (ret == -1) {
+        PRINTK("%s  ", fullpath);
+        perror("rm/rmdir error!");
+        return ret;
+    }
+
+    PRINTK("%s match successful!delete!\n", fullpath);
+    return 0;
+}
+
+/*  Split the path with wildcard characters  */
+
+static char* OsWildcardSplitPath(char *fullpath, char **handle, char **wait)
+{
+    int n;
+    int a = 0;
+    int b = 0;
+    int len  = strlen(fullpath);
+
+    for (n = 0; n < len; n++) {
+        if (fullpath[n] == '/') {
+            if (b != 0) {
+                fullpath[n] = '\0';
+                *wait = fullpath + n + 1;
+                break;
+            }
+            a = n;
+        } else if (fullpath[n] == '*' || fullpath[n] == '?') {
+            b = n;
+            fullpath[a] = '\0';
+            if (a == 0) {
+                *handle = fullpath + a + 1;
+                continue;
+            }
+            *handle = fullpath + a + 1;
+        }
+    }
+    return fullpath;
+}
+
+/*  Handling entry of the path with wildcard characters  */
+
+static int OsWildcardExtractDirectory(char *fullpath, void *dst, wildcard_type mark)
+{
+    char separator[] = "/";
+    char src[PATH_MAX] = {0};
+    struct dirent *dirent = NULL;
+    char *f = NULL;
+    char *s = NULL;
+    char *t = NULL;
+    int ret = 0;
+    DIR *d = NULL;
+    struct stat statBuf;
+    int deleteFlag = 0;
+
+    f = OsWildcardSplitPath(fullpath, &s, &t);
+
+    if (s == NULL) {
+        if (mark == CP_FILE) {
+            ret = OsShellCmdDoCp(fullpath, dst);
+        } else if (mark == CP_COUNT) {
+            ret = stat(fullpath, &statBuf);
+            if (ret == 0 && (S_ISREG(statBuf.st_mode) || S_ISLNK(statBuf.st_mode))) {
+                (*(int *)dst)++;
+            }
+        } else {
+            ret = OsWildcardDeleteFileOrDir(fullpath, mark);
+        }
+        return ret;
+    }
+
+    d = (*f == '\0') ? opendir("/") : opendir(f);
+
+    if (d == NULL) {
+        perror("opendir error");
+        return VFS_ERROR;
+    }
+
+    while (1) {
+        dirent = readdir(d);
+        if (dirent == NULL) {
+            break;
+        }
+
+        ret = strcpy_s(src, PATH_MAX, f);
+        if (ret != EOK) {
+            goto closedir_out;
+        }
+
+        ret = OsWildcardMatch(dirent->d_name, s);
+        if (ret == 0) {
+            ret = strcat_s(src, sizeof(src), separator);
+            if (ret != EOK) {
+                goto closedir_out;
+            }
+            ret = strcat_s(src, sizeof(src), dirent->d_name);
+            if (ret != EOK) {
+                goto closedir_out;
+            }
+            if (t == NULL) {
+                if (mark == CP_FILE) {
+                    ret = OsShellCmdDoCp(src, dst);
+                } else if (mark == CP_COUNT) {
+                    ret = stat(src, &statBuf);
+                    if (ret == 0 && (S_ISREG(statBuf.st_mode) || S_ISLNK(statBuf.st_mode))) {
+                        (*(int *)dst)++;
+                        if ((*(int *)dst) > 1) {
+                            break;
+                        }
+                    }
+                } else {
+                    ret = OsWildcardDeleteFileOrDir(src, mark);
+                    if (ret == 0) {
+                        deleteFlag = 1;
+                    }
+                }
+            } else {
+                ret = strcat_s(src, sizeof(src), separator);
+                if (ret != EOK) {
+                    goto closedir_out;
+                }
+                ret = strcat_s(src, sizeof(src), t);
+                if (ret != EOK) {
+                    goto closedir_out;
+                }
+                ret = OsWildcardExtractDirectory(src, dst, mark);
+                if (mark == CP_COUNT && (*(int *)dst) > 1) {
+                    break;
+                }
+            }
+        }
+    }
+    (void)closedir(d);
+    if (deleteFlag == 1) {
+        ret = 0;
+    }
+    return ret;
+closedir_out:
+    (void)closedir(d);
+    return VFS_ERROR;
+}
+
+int OsShellCmdCp(int argc, const char **argv)
+{
+    int  ret;
+    const char *src = NULL;
+    const char *dst = NULL;
+    char *srcFullPath = NULL;
+    char *drcFullPath = NULL;
+    struct stat statBuf;
+    int count = 0;
+    char *shellWorkingDirectory = OsShellGetWorkingDirtectory();
+    if (shellWorkingDirectory == NULL) {
+        return -1;
+    }
+
+    ERROR_OUT_IF(argc < 2, PRINTK("cp [SOURCEFILE] [DESTFILE]\n"), return -1);
+
+    src = argv[0];
+    dst = argv[1];
+
+    /* Get source fullpath. */
+
+    ret = VfsNormalizePath(shellWorkingDirectory, src, &srcFullPath);
+    if (ret < 0) {
+        SetErrno(-ret);
+        PRINTK("cp error:%s\n", strerror(errno));
+        return -1;
+    }
+
+    if (src[strlen(src) - 1] == '/') {
+        PRINTK("cp %s error: Source file can't be a directory.\n", src);
+        goto errout_with_srcpath;
+    }
+
+    /* Get dest fullpath. */
+    ret = VfsNormalizePath(shellWorkingDirectory, dst, &drcFullPath);
+    if (ret < 0) {
+        SetErrno(-ret);
+        PRINTK("cp error: can't open %s. %s\n", dst, strerror(errno));
+        goto errout_with_srcpath;
+    }
+
+    /* Is dest path exist? */
+
+    ret = stat(drcFullPath, &statBuf);
+    if (ret < 0) {
+        /* Is dest path a directory? */
+        if (dst[strlen(dst) - 1] == '/') {
+            PRINTK("cp error: %s, %s.\n", drcFullPath, strerror(errno));
+            goto errout_with_path;
+        }
+    } else {
+        if ((S_ISREG(statBuf.st_mode) || S_ISLNK(statBuf.st_mode)) && dst[strlen(dst) - 1] == '/') {
+            PRINTK("cp error: %s is not a directory.\n", drcFullPath);
+            goto errout_with_path;
+        }
+    }
+
+    if (OsIsContainersWildcard(srcFullPath)) {
+        if (ret < 0 || S_ISREG(statBuf.st_mode) || S_ISLNK(statBuf.st_mode)) {
+            char *srcCopy = strdup(srcFullPath);
+            if (srcCopy == NULL) {
+                PRINTK("cp error : Out of memory.\n");
+                goto errout_with_path;
+            }
+            (void)OsWildcardExtractDirectory(srcCopy, &count, CP_COUNT);
+            free(srcCopy);
+            if (count > 1) {
+                PRINTK("cp error : %s is not a directory.\n", drcFullPath);
+                goto errout_with_path;
+            }
+        }
+        ret = OsWildcardExtractDirectory(srcFullPath, drcFullPath, CP_FILE);
+    } else {
+        ret = OsShellCmdDoCp(srcFullPath, drcFullPath);
+    }
+    free(drcFullPath);
+    free(srcFullPath);
+    return ret;
+
+errout_with_path:
+    free(drcFullPath);
+errout_with_srcpath:
+    free(srcFullPath);
+    return VFS_ERROR;
+}
+
+static inline void PrintRmUsage(void)
+{
+    PRINTK("rm [FILE] or rm [-r/-R] [FILE]\n");
+}
+
+int OsShellCmdRm(int argc, const char **argv)
+{
+    int  ret;
+    char *fullpath = NULL;
+    const char *filename = NULL;
+    char *shellWorkingDirectory = OsShellGetWorkingDirtectory();
+
+    if (shellWorkingDirectory == NULL) {
+        return -1;
+    }
+
+    ERROR_OUT_IF(argc != 1 && argc != 2, PrintRmUsage(), return -1);
+
+    if (argc == 2) {
+        ERROR_OUT_IF(strcmp(argv[0], "-r") != 0 && strcmp(argv[0], "-R") != 0, PrintRmUsage(), return -1);
+
+        filename = argv[1];
+        ret = VfsNormalizePath(shellWorkingDirectory, filename, &fullpath);
+        ERROR_OUT_IF(ret < 0, SetErr(-ret, "rm error"), return -1);
+
+        if (OsIsContainersWildcard(fullpath)) {
+            ret = OsWildcardExtractDirectory(fullpath, NULL, RM_RECURSIVER);
+        } else {
+            ret = OsShellCmdDoRmdir(fullpath);
+        }
+    } else {
+        filename = argv[0];
+        ret = VfsNormalizePath(shellWorkingDirectory, filename, &fullpath);
+        ERROR_OUT_IF(ret < 0, SetErr(-ret, "rm error"), return -1);
+
+        if (OsIsContainersWildcard(fullpath)) {
+            ret = OsWildcardExtractDirectory(fullpath, NULL, RM_FILE);
+        } else {
+            ret = unlink(fullpath);
+        }
+    }
+    if (ret == -1) {
+        perror("rm error");
+    }
+    free(fullpath);
+    return 0;
+}
+
+int OsShellCmdRmdir(int argc, const char **argv)
+{
+    int  ret;
+    char *fullpath = NULL;
+    const char *filename = NULL;
+    char *shellWorkingDirectory = OsShellGetWorkingDirtectory();
+    if (shellWorkingDirectory == NULL) {
+        return -1;
+    }
+
+    ERROR_OUT_IF(argc == 0, PRINTK("rmdir [DIRECTORY]\n"), return -1);
+
+    filename = argv[0];
+    ret = VfsNormalizePath(shellWorkingDirectory, filename, &fullpath);
+    ERROR_OUT_IF(ret < 0, SetErr(-ret, "rmdir error"), return -1);
+
+    if (OsIsContainersWildcard(fullpath)) {
+        ret = OsWildcardExtractDirectory(fullpath, NULL, RM_DIR);
+    } else {
+        ret = rmdir(fullpath);
+    }
+    if (ret == -1) {
+        PRINTK("rmdir %s failed. Error: %s.\n", fullpath, strerror(errno));
+    }
+    free(fullpath);
+
+    return 0;
+}
+
diff --git a/kernel/liteos_m/config/target_config.h b/kernel/liteos_m/config/target_config.h
new file mode 100644
index 0000000..3aed0cf
--- /dev/null
+++ b/kernel/liteos_m/config/target_config.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**@defgroup los_config System configuration items
+ * @ingroup kernel
+ */
+
+#ifndef _TARGET_CONFIG_H_
+#define _TARGET_CONFIG_H_
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define CMSIS_OS_VER                       2 
+#define LOSCFG_KERNEL_PRINTF               1
+
+#define LOS_TICK_UNIT_CLOCK                26000000 
+#define LOS_TICK_MS                        2
+#define LOS_TICKS_PER_SECOND              (1000UL/LOS_TICK_MS)
+
+/*=============================================================================
+ *System clock module configuration
+ *=============================================================================*/
+#define OS_SYS_CLOCK                                        (LOS_TICK_UNIT_CLOCK) 
+#define LOSCFG_BASE_CORE_TICK_PER_SECOND                    (LOS_TICKS_PER_SECOND)
+#define LOSCFG_BASE_CORE_TICK_HW_TIME                       0
+#define LOSCFG_BASE_CORE_TICK_WTIMER                        0
+#define LOSCFG_BASE_CORE_TICK_RESPONSE_MAX                  0xFFFFFFFF
+
+/*=============================================================================
+ *Hardware interrupt module configuration
+ *=============================================================================*/
+#define LOSCFG_PLATFORM_HWI                                 1
+#define LOSCFG_PLATFORM_HWI_LIMIT                           128
+
+/*=============================================================================
+ *Task module configuration
+ *=============================================================================*/
+#define LOSCFG_BASE_CORE_TSK_LIMIT                          30
+#define LOSCFG_BASE_CORE_TSK_IDLE_STACK_SIZE                (0x500U)
+#define LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE             (0x3D0U)
+
+/*scheduler occupies too much stack for every thread*/
+#define LOSCFG_BASE_CORE_TSK_MIN_STACK_SIZE                 (0x300U)
+#define LOSCFG_BASE_CORE_TIMESLICE                          1
+#define LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT                  20000
+
+/*=============================================================================
+ *Semaphore module configuration
+ *=============================================================================*/
+#define LOSCFG_BASE_IPC_SEM                                 1
+#define LOSCFG_BASE_IPC_SEM_LIMIT                           32
+
+/*=============================================================================
+ *Mutex module configuration
+ *=============================================================================*/
+#define LOSCFG_BASE_IPC_MUX                                 1
+#define LOSCFG_BASE_IPC_MUX_LIMIT                           32
+
+/*=============================================================================
+ *Queue module configuration
+ *=============================================================================*/
+#define LOSCFG_BASE_IPC_QUEUE                               1
+#define LOSCFG_BASE_IPC_QUEUE_LIMIT                         32
+
+/*=============================================================================
+ *Software timer module configuration
+ *=============================================================================*/
+#define LOSCFG_BASE_CORE_SWTMR                              1
+#define LOSCFG_BASE_CORE_SWTMR_ALIGN                        1
+#define LOSCFG_BASE_CORE_SWTMR_LIMIT                        32
+
+/*=============================================================================
+ *Memory module configuration
+ *=============================================================================*/
+#define LOSCFG_SYS_EXTERNAL_HEAP                            1
+#define OS_SYS_MEM_SIZE                                     0x0001000
+#define LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK                1
+#define LOSCFG_BASE_MEM_NODE_SIZE_CHECK                     1
+
+#define LOSCFG_MEM_MUL_POOL                                 1
+
+#define OS_SYS_MEM_NUM                                      20
+#define LOSCFG_KERNEL_MEM_SLAB                              0
+/*=============================================================================
+ *Exception module configuration
+ *=============================================================================*/
+#define LOSCFG_PLATFORM_EXC                                 0
+
+extern void uart_putc(char c);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+
+#endif /* _TARGET_CONFIG_H */
diff --git a/kernel/liteos_m/config.gni b/kernel/liteos_m/config.gni
new file mode 100644
index 0000000..10493eb
--- /dev/null
+++ b/kernel/liteos_m/config.gni
@@ -0,0 +1,42 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+declare_args() {
+  enable_ohos_kernel_liteos_m_cppsupport = true
+  enable_ohos_kernel_liteos_m_cpup = true
+  enable_ohos_kernel_liteos_m_exchook = true
+  enable_ohos_kernel_liteos_m_kal = true
+  enable_ohos_kernel_liteos_m_fs = true
+  enable_ohos_kernel_liteos_m_shell = true
+  enable_ohos_kernel_liteos_m_backtrace = true
+  enable_ohos_kernel_liteos_m_test = false
+  enable_ohos_kernel_liteos_m_pm = true
+  enable_ohos_kernel_liteos_m_lwip = false
+  ohos_kernel_liteos_m_lwip_path = "components/net/lwip-2.1:lwip"
+}
diff --git "a/kernel/liteos_m/figures/OpenHarmony-LiteOS-M\346\240\270\345\206\205\346\240\270\346\236\266\346\236\204\345\233\276.png" "b/kernel/liteos_m/figures/OpenHarmony-LiteOS-M\342\225\221\342\225\246\342\224\200\342\224\214\342\225\221\342\225\246\342\225\235\342\226\204\342\225\243\342\225\243\342\225\220\342\225\235.png"
similarity index 100%
rename from "kernel/liteos_m/figures/OpenHarmony-LiteOS-M\346\240\270\345\206\205\346\240\270\346\236\266\346\236\204\345\233\276.png"
rename to "kernel/liteos_m/figures/OpenHarmony-LiteOS-M\342\225\221\342\225\246\342\224\200\342\224\214\342\225\221\342\225\246\342\225\235\342\226\204\342\225\243\342\225\243\342\225\220\342\225\235.png"
diff --git a/kernel/liteos_m/kal/BUILD.gn b/kernel/liteos_m/kal/BUILD.gn
index 05c2d2a..f74df3d 100644
--- a/kernel/liteos_m/kal/BUILD.gn
+++ b/kernel/liteos_m/kal/BUILD.gn
@@ -1,55 +1,47 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-declare_args() {
-  enable_ohos_kernel_liteos_m_cmsis = true
-  enable_ohos_kernel_liteos_m_posix = true
-}
-
-static_library("kal") {
-  sources = [ "kal.c" ]
-
-  include_dirs = [
-    "../kernel/arch/include",
-    "../kernel/include",
-    "../utils",
-    "../kal/cmsis",
-    "../kal",
-  ]
-
-  deps = []
-
-  if (enable_ohos_kernel_liteos_m_cmsis == true) {
-    deps += [ "cmsis/" ]
-  }
-
-  if (enable_ohos_kernel_liteos_m_posix == true) {
-    deps += [ "posix/" ]
-  }
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+import("//build/lite/config/component/lite_component.gni")
+
+declare_args() {
+  enable_ohos_kernel_liteos_m_cmsis = true
+  enable_ohos_kernel_liteos_m_posix = true
+}
+
+lite_component("kal") {
+  features = []
+
+  if (enable_ohos_kernel_liteos_m_cmsis == true) {
+    features += [ "cmsis" ]
+  }
+
+  if (enable_ohos_kernel_liteos_m_posix == true) {
+    features += [ "posix" ]
+  }
+}
diff --git a/kernel/liteos_m/kal/cmsis/BUILD.gn b/kernel/liteos_m/kal/cmsis/BUILD.gn
index 7cb21e4..403df30 100644
--- a/kernel/liteos_m/kal/cmsis/BUILD.gn
+++ b/kernel/liteos_m/kal/cmsis/BUILD.gn
@@ -1,41 +1,48 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-static_library("cmsis") {
-  sources = [ "cmsis_liteos.c" ]
-
-  include_dirs = [
-    "//third_party/bounds_checking_function/include",
-    "../../kernel/include",
-    "../../kernel/arch/include",
-    "../../utils",
-    "../../kal/cmsis",
-    "../../kal",
-  ]
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("cmsis") {
+  sources = [ "cmsis_liteos2.c" ]
+
+  include_dirs = [
+    "//third_party/bounds_checking_function/include",
+    "../../kernel/include",
+    "../../kernel/arch/include",
+    "../../utils",
+  ]
+
+  public_configs = [ ":include" ]
+}
+
+config("include") {
+  include_dirs = [
+    ".",
+    "//third_party/cmsis/CMSIS/RTOS2/Include",
+  ]
+}
diff --git a/kernel/liteos_m/kal/cmsis/LICENSE.txt b/kernel/liteos_m/kal/cmsis/LICENSE.txt
deleted file mode 100644
index 8dada3e..0000000
--- a/kernel/liteos_m/kal/cmsis/LICENSE.txt
+++ /dev/null
@@ -1,201 +0,0 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "{}"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright {yyyy} {name of copyright owner}
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
diff --git a/kernel/liteos_m/kal/cmsis/README.OpenSource b/kernel/liteos_m/kal/cmsis/README.OpenSource
deleted file mode 100644
index c05284e..0000000
--- a/kernel/liteos_m/kal/cmsis/README.OpenSource
+++ /dev/null
@@ -1,11 +0,0 @@
-[
-    {
-        "Name"                  : "CMSIS",
-        "License"               : "Apache License V2.0",
-        "License File"          : "LICENSE.txt",
-        "Version Number"        : "5.7.0",
-        "Owner"                 : "denny.shenwei@huawei.com",
-        "Upstream URL"          : "http://www.arm.com/zh/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php",
-        "Description"           : "The Cortex Microcontroller Software Interface Standard (CMSIS) is a vendor-independent hardware abstraction layer for microcontrollers that are based on Arm® Cortex® processors"
-    }
-]
diff --git a/kernel/liteos_m/kal/cmsis/cmsis_liteos2.c b/kernel/liteos_m/kal/cmsis/cmsis_liteos2.c
old mode 100755
new mode 100644
index c37552a..2b5eebc
--- a/kernel/liteos_m/kal/cmsis/cmsis_liteos2.c
+++ b/kernel/liteos_m/kal/cmsis/cmsis_liteos2.c
@@ -29,7 +29,8 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "cmsis_os.h"
+#include "cmsis_os2.h"
+#include "kal.h"
 #include "los_event.h"
 #include "los_membox.h"
 #include "los_memory.h"
@@ -40,25 +41,23 @@
 #include "los_swtmr.h"
 #include "los_task.h"
 #include "los_timer.h"
-#include "kal.h"
 #include "los_debug.h"
 
 #include "string.h"
 #include "securec.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
-#if (CMSIS_OS_VER == 2)
 
 /* Kernel initialization state */
 static osKernelState_t g_kernelState;
 
 extern BOOL g_taskScheduled;
 
-#define LOS_PRIORITY_WIN 8
+/* LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO <---> osPriorityNormal */
+#define LOS_PRIORITY(cmsisPriority) (LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO - ((cmsisPriority) - osPriorityNormal))
+#define CMSIS_PRIORITY(losPriority) (osPriorityNormal + (LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO - (losPriority)))
+
+/* OS_TASK_PRIORITY_HIGHEST and OS_TASK_PRIORITY_LOWEST is reserved for internal TIMER and IDLE task use only. */
+#define ISVALID_LOS_PRIORITY(losPrio) ((losPrio) > OS_TASK_PRIORITY_HIGHEST && (losPrio) < OS_TASK_PRIORITY_LOWEST)
 
 const osVersion_t g_stLosVersion = { 001, 001 };
 
@@ -74,8 +73,6 @@ const osVersion_t g_stLosVersion = { 001, 001 };
 #define KERNEL_ID "HUAWEI-LiteOS"
 
 //  ==== Kernel Management Functions ====
-uint32_t osTaskStackWaterMarkGet(UINT32 taskID);
-
 
 osStatus_t osKernelInitialize(void)
 {
@@ -242,25 +239,7 @@ int32_t osKernelRestoreLock(int32_t lock)
 
 uint32_t osKernelGetTickCount(void)
 {
-    uint64_t ticks;
-    UINTPTR uvIntSave;
-
-    if (OS_INT_ACTIVE) {
-#ifndef LITEOS_WIFI_IOT_VERSION
-        ticks = g_ullTickCount;
-#else
-        ticks = g_tickCount;
-#endif
-    } else {
-        uvIntSave = LOS_IntLock();
-#ifndef LITEOS_WIFI_IOT_VERSION
-        ticks = g_ullTickCount;
-#else
-        ticks = g_tickCount;
-#endif
-        LOS_IntRestore(uvIntSave);
-    }
-
+    uint64_t ticks = LOS_TickCountGet();
     return (uint32_t)ticks;
 }
 
@@ -279,12 +258,11 @@ uint32_t osKernelGetTickFreq(void)
 
 uint32_t osKernelGetSysTimerCount(void)
 {
-    uint32_t countHigh = 0;
-    uint32_t countLow = 0;
+    uint32_t countLow;
     if (OS_INT_ACTIVE) {
         countLow = 0U;
     } else {
-        HalGetCpuCycle((UINT32 *)&countHigh, (UINT32 *)&countLow);
+        countLow = (UINT32)LOS_SysCycleGet();
     }
     return countLow;
 }
@@ -303,27 +281,24 @@ osThreadId_t osThreadNew(osThreadFunc_t func, void *argument, const osThreadAttr
     UINT32 uwTid;
     UINT32 uwRet;
     LosTaskCB *pstTaskCB = NULL;
-    TSK_INIT_PARAM_S stTskInitParam;
+    TSK_INIT_PARAM_S stTskInitParam = {NULL};
+    UINT16 usPriority;
 
-    if (OS_INT_ACTIVE) {
-        return NULL;
+    if (OS_INT_ACTIVE || (func == NULL)) {
+        return (osThreadId_t)NULL;
     }
 
-    if ((attr == NULL) || (func == NULL) || (attr->priority < osPriorityLow1) ||
-        (attr->priority > osPriorityAboveNormal6)) {
+    usPriority = attr ? LOS_PRIORITY(attr->priority) : LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO;
+    if (!ISVALID_LOS_PRIORITY(usPriority)) {
+        /* unsupported priority */
         return (osThreadId_t)NULL;
     }
 
-    (void)memset_s(&stTskInitParam, sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
     stTskInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)func;
-#ifndef LITEOS_WIFI_IOT_VERSION
     stTskInitParam.uwArg = (UINT32)argument;
-#else
-    stTskInitParam.auwArgs[0] = (UINT32)argument;
-#endif
-    stTskInitParam.uwStackSize = attr->stack_size;
-    stTskInitParam.pcName = (CHAR *)attr->name;
-    stTskInitParam.usTaskPrio = OS_TASK_PRIORITY_LOWEST - ((UINT16)(attr->priority) - LOS_PRIORITY_WIN); /* 0~31 */
+    stTskInitParam.uwStackSize = attr ? attr->stack_size : LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
+    stTskInitParam.pcName = (CHAR *)(attr ? attr->name : "[NULL]");
+    stTskInitParam.usTaskPrio = usPriority;
 
     uwRet = LOS_TaskCreate(&uwTid, &stTskInitParam);
 
@@ -370,11 +345,7 @@ void *osThreadGetArgument(void)
     if (taskCb == NULL) {
         return NULL;
     }
-#ifndef LITEOS_WIFI_IOT_VERSION
     return (void *)(taskCb->arg);
-#else
-    return (void *)(taskCb->args[0]);
-#endif
 }
 
 osThreadState_t osThreadGetState(osThreadId_t thread_id)
@@ -395,7 +366,7 @@ osThreadState_t osThreadGetState(osThreadId_t thread_id)
     } else if (taskStatus & OS_TASK_STATUS_READY) {
         stState = osThreadReady;
     } else if (taskStatus &
-        (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND | OS_TASK_STATUS_SUSPEND | OS_TASK_STATUS_PEND_QUEUE)) {
+        (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND | OS_TASK_STATUS_SUSPEND)) {
         stState = osThreadBlocked;
     } else if (taskStatus & OS_TASK_STATUS_UNUSED) {
         stState = osThreadInactive;
@@ -425,18 +396,18 @@ uint32_t osTaskStackWaterMarkGet(UINT32 taskID)
 {
     UINT32 uwCount = 0;
     UINT32 *ptopOfStack;
-    UINTPTR uvIntSave;
+    UINT32 intSave;
     LosTaskCB *pstTaskCB = NULL;
 
     if (taskID > LOSCFG_BASE_CORE_TSK_LIMIT) {
         return 0;
     }
 
-    uvIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
 
     pstTaskCB = OS_TCB_FROM_TID(taskID);
     if (OS_TASK_STATUS_UNUSED & (pstTaskCB->taskStatus)) {
-        LOS_IntRestore(uvIntSave);
+        LOS_IntRestore(intSave);
         return 0;
     }
 
@@ -450,7 +421,7 @@ uint32_t osTaskStackWaterMarkGet(UINT32 taskID)
 
     uwCount *= sizeof(UINT32);
 
-    LOS_IntRestore(uvIntSave);
+    LOS_IntRestore(intSave);
     return uwCount;
 }
 
@@ -483,12 +454,12 @@ osStatus_t osThreadSetPriority(osThreadId_t thread_id, osPriority_t priority)
         return osErrorParameter;
     }
 
-    if (priority < osPriorityLow1 || priority > osPriorityAboveNormal6) {
+    usPriority = LOS_PRIORITY(priority);
+    if (!ISVALID_LOS_PRIORITY(usPriority)) {
         return osErrorParameter;
     }
 
     pstTaskCB = (LosTaskCB *)thread_id;
-    usPriority = OS_TASK_PRIORITY_LOWEST - ((UINT16)priority - LOS_PRIORITY_WIN);
     uwRet = LOS_TaskPriSet(pstTaskCB->taskID, usPriority);
     switch (uwRet) {
         case LOS_ERRNO_TSK_PRIOR_ERROR:
@@ -521,7 +492,7 @@ osPriority_t osThreadGetPriority(osThreadId_t thread_id)
         return osPriorityError;
     }
 
-    return (osPriority_t)(OS_TASK_PRIORITY_LOWEST - (usRet - LOS_PRIORITY_WIN));
+    return (osPriority_t)CMSIS_PRIORITY(usRet);
 }
 
 
@@ -654,6 +625,13 @@ uint32_t osThreadGetCount(void)
 }
 
 
+void osThreadExit(void)
+{
+    (void)LOS_TaskDelete(LOS_CurTaskIDGet());
+    UNREACHABLE;
+}
+
+
 osStatus_t osDelay(uint32_t ticks)
 {
     UINT32 uwRet = LOS_OK;
@@ -661,7 +639,7 @@ osStatus_t osDelay(uint32_t ticks)
         return osOK;
     }
     if (osKernelGetState() != osKernelRunning) {
-        HalDelay(ticks);
+        LOS_UDelay(ticks * OS_US_PER_TICK);
     } else {
         uwRet = LOS_TaskDelay(ticks);
     }
@@ -724,6 +702,34 @@ osTimerId_t osTimerNew(osTimerFunc_t func, osTimerType_t type, void *argument, c
     return (osTimerId_t)OS_SWT_FROM_SID(usSwTmrID);
 }
 
+
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+osTimerId_t osTimerExtNew(osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr,
+    osTimerRouses_t ucRouses, osTimerAlign_t ucSensitive)
+{
+    UNUSED(attr);
+    UINT32 usSwTmrID;
+    UINT8 mode;
+
+    if ((OS_INT_ACTIVE) || (NULL == func) || ((osTimerOnce != type) && (osTimerPeriodic != type))) {
+        return (osTimerId_t)NULL;
+    }
+
+    if (osTimerOnce == type) {
+        mode = LOS_SWTMR_MODE_NO_SELFDELETE;
+    } else {
+        mode = LOS_SWTMR_MODE_PERIOD;
+    }
+    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)func, &usSwTmrID,
+        (UINT32)(UINTPTR)argument, ucRouses, ucSensitive)) {
+        return (osTimerId_t)NULL;
+    }
+
+    return (osTimerId_t)OS_SWT_FROM_SID(usSwTmrID);
+}
+#endif
+
+
 osStatus_t osTimerStart(osTimerId_t timer_id, uint32_t ticks)
 {
     UINT32 uwRet;
@@ -733,7 +739,7 @@ osStatus_t osTimerStart(osTimerId_t timer_id, uint32_t ticks)
         return osErrorParameter;
     }
 
-    UINTPTR intSave = LOS_IntLock();
+    UINT32 intSave = LOS_IntLock();
     pstSwtmr = (SWTMR_CTRL_S *)timer_id;
     pstSwtmr->uwInterval = ticks;
     uwRet = LOS_SwtmrStart(pstSwtmr->usTimerID);
@@ -863,7 +869,7 @@ uint32_t osEventFlagsSet(osEventFlagsId_t ef_id, uint32_t flags)
 uint32_t osEventFlagsClear(osEventFlagsId_t ef_id, uint32_t flags)
 {
     PEVENT_CB_S pstEventCB = (PEVENT_CB_S)ef_id;
-    UINTPTR uwIntSave;
+    UINT32 intSave;
     uint32_t rflags;
     UINT32 uwRet;
 
@@ -871,11 +877,11 @@ uint32_t osEventFlagsClear(osEventFlagsId_t ef_id, uint32_t flags)
         return (uint32_t)osFlagsErrorParameter;
     }
 
-    uwIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
     rflags = pstEventCB->uwEventID;
 
     uwRet = LOS_EventClear(pstEventCB, ~flags);
-    LOS_IntRestore(uwIntSave);
+    LOS_IntRestore(intSave);
     if (uwRet != LOS_OK) {
         return (uint32_t)osFlagsErrorParameter;
     } else {
@@ -887,16 +893,16 @@ uint32_t osEventFlagsClear(osEventFlagsId_t ef_id, uint32_t flags)
 uint32_t osEventFlagsGet(osEventFlagsId_t ef_id)
 {
     PEVENT_CB_S pstEventCB = (PEVENT_CB_S)ef_id;
-    UINTPTR uwIntSave;
+    UINT32 intSave;
     uint32_t rflags;
 
     if (pstEventCB == NULL) {
-        return (uint32_t)osFlagsErrorParameter;
+        return 0;
     }
 
-    uwIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
     rflags = pstEventCB->uwEventID;
-    LOS_IntRestore(uwIntSave);
+    LOS_IntRestore(intSave);
 
     return rflags;
 }
@@ -948,16 +954,16 @@ uint32_t osEventFlagsWait(osEventFlagsId_t ef_id, uint32_t flags, uint32_t optio
 osStatus_t osEventFlagsDelete(osEventFlagsId_t ef_id)
 {
     PEVENT_CB_S pstEventCB = (PEVENT_CB_S)ef_id;
-    UINTPTR uwIntSave;
+    UINT32 intSave;
     osStatus_t uwRet;
 
-    uwIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
     if (LOS_EventDestroy(pstEventCB) == LOS_OK) {
         uwRet = osOK;
     } else {
         uwRet = osErrorParameter;
     }
-    LOS_IntRestore(uwIntSave);
+    LOS_IntRestore(intSave);
 
     if (LOS_MemFree(m_aucSysMem0, (void *)pstEventCB) == LOS_OK) {
         uwRet = osOK;
@@ -1034,7 +1040,7 @@ osStatus_t osMutexRelease(osMutexId_t mutex_id)
 
 osThreadId_t osMutexGetOwner(osMutexId_t mutex_id)
 {
-    UINT32 uwIntSave;
+    UINT32 intSave;
     LosTaskCB *pstTaskCB;
 
     if (OS_INT_ACTIVE) {
@@ -1045,9 +1051,9 @@ osThreadId_t osMutexGetOwner(osMutexId_t mutex_id)
         return NULL;
     }
 
-    uwIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
     pstTaskCB = ((LosMuxCB *)mutex_id)->owner;
-    LOS_IntRestore(uwIntSave);
+    LOS_IntRestore(intSave);
 
     return (osThreadId_t)pstTaskCB;
 }
@@ -1152,7 +1158,7 @@ osStatus_t osSemaphoreRelease(osSemaphoreId_t semaphore_id)
 
 uint32_t osSemaphoreGetCount(osSemaphoreId_t semaphore_id)
 {
-    UINT32 uwIntSave;
+    UINT32 intSave;
     UINT32 uwCount;
 
     if (OS_INT_ACTIVE) {
@@ -1163,9 +1169,9 @@ uint32_t osSemaphoreGetCount(osSemaphoreId_t semaphore_id)
         return 0;
     }
 
-    uwIntSave = LOS_IntLock();
+    intSave = LOS_IntLock();
     uwCount = ((LosSemCB *)semaphore_id)->semCount;
-    LOS_IntRestore(uwIntSave);
+    LOS_IntRestore(intSave);
 
     return uwCount;
 }
@@ -1302,15 +1308,15 @@ uint32_t osMessageQueueGetMsgSize(osMessageQueueId_t mq_id)
 uint32_t osMessageQueueGetCount(osMessageQueueId_t mq_id)
 {
     uint32_t count;
-    UINTPTR uwIntSave;
+    UINT32 intSave;
     LosQueueCB *pstQueue = (LosQueueCB *)mq_id;
 
     if (pstQueue == NULL) {
         count = 0U;
     } else {
-        uwIntSave = LOS_IntLock();
+        intSave = LOS_IntLock();
         count = (uint32_t)(pstQueue->readWriteableCnt[OS_QUEUE_READ]);
-        LOS_IntRestore(uwIntSave);
+        LOS_IntRestore(intSave);
     }
     return count;
 }
@@ -1319,15 +1325,15 @@ uint32_t osMessageQueueGetCount(osMessageQueueId_t mq_id)
 uint32_t osMessageQueueGetSpace(osMessageQueueId_t mq_id)
 {
     uint32_t space;
-    UINTPTR uwIntSave;
+    UINT32 intSave;
     LosQueueCB *pstQueue = (LosQueueCB *)mq_id;
 
     if (pstQueue == NULL) {
         space = 0U;
     } else {
-        uwIntSave = LOS_IntLock();
+        intSave = LOS_IntLock();
         space = (uint32_t)pstQueue->readWriteableCnt[OS_QUEUE_WRITE];
-        LOS_IntRestore(uwIntSave);
+        LOS_IntRestore(intSave);
     }
     return space;
 }
@@ -1354,12 +1360,9 @@ osStatus_t osMessageQueueDelete(osMessageQueueId_t mq_id)
         return osErrorResource;
     }
 }
-void osThreadExit(void)
-{
-    return;
-}
 #endif
 
+
 #define MP_ALLOC        1U
 #define MD_ALLOC        2U
 #define MEM_POOL_VALID  0xFFEEFF00
@@ -1449,7 +1452,7 @@ void *osMemoryPoolAlloc(osMemoryPoolId_t mp_id, uint32_t timeout)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
     LOS_MEMBOX_NODE *node = NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
 
     UNUSED(timeout);
 
@@ -1476,7 +1479,7 @@ osStatus_t osMemoryPoolFree(osMemoryPoolId_t mp_id, void *block)
     MemPoolCB *mp = (MemPoolCB *)mp_id;
     LOS_MEMBOX_NODE *node = NULL;
     LOS_MEMBOX_NODE *nodeTmp = NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
 
     if ((mp_id == NULL) || (block == NULL)) {
         return osErrorParameter;
@@ -1507,7 +1510,7 @@ osStatus_t osMemoryPoolFree(osMemoryPoolId_t mp_id, void *block)
 osStatus_t osMemoryPoolDelete(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
-    UINTPTR intSave;
+    UINT32 intSave;
 
     if (OS_INT_ACTIVE) {
         return osErrorISR;
@@ -1542,7 +1545,7 @@ osStatus_t osMemoryPoolDelete(osMemoryPoolId_t mp_id)
 uint32_t osMemoryPoolGetCapacity(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
-    UINTPTR intSave;
+    UINT32 intSave;
     uint32_t num;
 
     if (mp_id == NULL) {
@@ -1563,7 +1566,7 @@ uint32_t osMemoryPoolGetCapacity(osMemoryPoolId_t mp_id)
 uint32_t osMemoryPoolGetBlockSize(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
-    UINTPTR intSave;
+    UINT32 intSave;
     uint32_t size;
 
     if (mp_id == NULL) {
@@ -1584,7 +1587,7 @@ uint32_t osMemoryPoolGetBlockSize(osMemoryPoolId_t mp_id)
 uint32_t osMemoryPoolGetCount(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
-    UINTPTR intSave;
+    UINT32 intSave;
     uint32_t count;
 
     if (mp_id == NULL) {
@@ -1605,7 +1608,7 @@ uint32_t osMemoryPoolGetCount(osMemoryPoolId_t mp_id)
 uint32_t osMemoryPoolGetSpace(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
-    UINTPTR intSave;
+    UINT32 intSave;
     uint32_t space;
 
     if (mp_id == NULL) {
@@ -1628,7 +1631,7 @@ const char *osMemoryPoolGetName(osMemoryPoolId_t mp_id)
 {
     MemPoolCB *mp = (MemPoolCB *)mp_id;
     const char *p = NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
 
     if (mp_id == NULL) {
         return NULL;
@@ -1646,10 +1649,3 @@ const char *osMemoryPoolGetName(osMemoryPoolId_t mp_id)
 
     return p;
 }
-
-#endif // (CMSIS_OS_VER == 2)
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kal/cmsis/cmsis_os2.h b/kernel/liteos_m/kal/cmsis/cmsis_os2.h
index d4e1436..fe91990 100644
--- a/kernel/liteos_m/kal/cmsis/cmsis_os2.h
+++ b/kernel/liteos_m/kal/cmsis/cmsis_os2.h
@@ -1,1215 +1,32 @@
 /*
- * Copyright (c) 2013-2018 Arm Limited. All rights reserved.
- *
- * SPDX-License-Identifier: Apache-2.0
- *
- * Licensed under the Apache License, Version 2.0 (the License); you may
- * not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an AS IS BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * ----------------------------------------------------------------------
- *
- * $Date:        18. June 2018
- * $Revision:    V2.1.3
- *
- * Project:      CMSIS-RTOS2 API
- * Title:        cmsis_os2.h header file
- *
- * Version 2.1.3
- *    Additional functions allowed to be called from Interrupt Service Routines:
- *    - osThreadGetId
- * Version 2.1.2
- *    Additional functions allowed to be called from Interrupt Service Routines:
- *    - osKernelGetInfo, osKernelGetState
- * Version 2.1.1
- *    Additional functions allowed to be called from Interrupt Service Routines:
- *    - osKernelGetTickCount, osKernelGetTickFreq
- *    Changed Kernel Tick type to uint32_t:
- *    - updated: osKernelGetTickCount, osDelayUntil
- * Version 2.1.0
- *    Support for critical and uncritical sections (nesting safe):
- *    - updated: osKernelLock, osKernelUnlock
- *    - added: osKernelRestoreLock
- *    Updated Thread and Event Flags:
- *    - changed flags parameter and return type from int32_t to uint32_t
- * Version 2.0.0
- *    Initial Release
- *---------------------------------------------------------------------------*/
-
-/**
- * @addtogroup CMSIS
- * @{
- *
- * @brief Provides standard, universal real-time operating system (RTOS) APIs.
- *
- * CMSIS Module may contain portions from ARM Cortex Microcontroller Software Interface Standard (CMSIS) licensed under Apache License v2.0.
- *
- * @since 1.0
- * @version 1.0
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef CMSIS_OS2_H_
-#define CMSIS_OS2_H_
-
-#ifndef __NO_RETURN
-#if   defined(__CC_ARM)
-#define __NO_RETURN __declspec(noreturn)
-#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
-#define __NO_RETURN __attribute__((__noreturn__))
-#elif defined(__GNUC__)
-#define __NO_RETURN __attribute__((__noreturn__))
-#elif defined(__ICCARM__)
-#define __NO_RETURN __noreturn
-#else
-#define __NO_RETURN
-#endif
-#endif
-
-#include <stdint.h>
-#include <stddef.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-//  ==== Enumerations, structures, defines ====
-
-/**
-* @brief Describes the system version.
-*
-* @since 1.0
-* @version 1.0
-*/
-typedef struct {
-  /** API version */
-  uint32_t                       api;
-  /** Kernel version */
-  uint32_t                    kernel;
-} osVersion_t;
-
-/**
-* @brief Enumerates kernel states.
-*
-*/
-typedef enum {
-  /** The kernel is inactive. */
-  osKernelInactive        =  0,
-  /** The kernel is ready. */
-  osKernelReady           =  1,
-  /** The kernel is running. */
-  osKernelRunning         =  2,
-  /** The kernel is locked. */
-  osKernelLocked          =  3,
-  /** The kernel is suspended. */
-  osKernelSuspended       =  4,
-  /** The kernel is abnormal. */
-  osKernelError           = -1,
-  /** Reserved */
-  osKernelReserved        = 0x7FFFFFFFU
-} osKernelState_t;
-
-/**
-* @brief Enumerates thread states.
-*
-*/
-typedef enum {
-  /** The thread is inactive. */
-  osThreadInactive        =  0,
-  /** The thread is ready. */
-  osThreadReady           =  1,
-  /** The thread is running. */
-  osThreadRunning         =  2,
-  /** The thread is blocked. */
-  osThreadBlocked         =  3,
-  /** The thread is terminated. */
-  osThreadTerminated      =  4,
-  /** The thread is abnormal. */
-  osThreadError           = -1,
-  /** Reserved */
-  osThreadReserved        = 0x7FFFFFFF
-} osThreadState_t;
-
-/**
-* @brief Enumerates thread priorities.
-*
-*/
-typedef enum {
-  /** Undefined */
-  osPriorityNone          =  0,
-  /** Reserved for idle threads */
-  osPriorityIdle          =  1,
-  /** Low (unsupported) */
-  osPriorityLow           =  8,
-  /** Low + 1 */
-  osPriorityLow1          =  8+1,
-  /** Low + 2 */
-  osPriorityLow2          =  8+2,
-  /** Low + 3 */
-  osPriorityLow3          =  8+3,
-  /** Low + 4 */
-  osPriorityLow4          =  8+4,
-  /** Low + 5 */
-  osPriorityLow5          =  8+5,
-  /** Low + 6 */
-  osPriorityLow6          =  8+6,
-  /** Low + 7 */
-  osPriorityLow7          =  8+7,
-  /** Below normal */
-  osPriorityBelowNormal   = 16,
-  /** Below normal + 1 */
-  osPriorityBelowNormal1  = 16+1,
-  /** Below normal + 2 */
-  osPriorityBelowNormal2  = 16+2,
-  /** Below normal + 3 */
-  osPriorityBelowNormal3  = 16+3,
-  /** Below normal + 4 */
-  osPriorityBelowNormal4  = 16+4,
-  /** Below normal + 5 */
-  osPriorityBelowNormal5  = 16+5,
-  /** Below normal + 6 */
-  osPriorityBelowNormal6  = 16+6,
-  /** Below normal + 7 */
-  osPriorityBelowNormal7  = 16+7,
-  /** Normal */
-  osPriorityNormal        = 24,
-  /** Normal + 1 */
-  osPriorityNormal1       = 24+1,
-  /** Normal + 2 */
-  osPriorityNormal2       = 24+2,
-  /** Normal + 3 */
-  osPriorityNormal3       = 24+3,
-  /** Normal + 4 */
-  osPriorityNormal4       = 24+4,
-  /** Normal + 5 */
-  osPriorityNormal5       = 24+5,
-  /** Normal + 6 */
-  osPriorityNormal6       = 24+6,
-  /** Normal + 7 */
-  osPriorityNormal7       = 24+7,
-  /** Above normal */
-  osPriorityAboveNormal   = 32,
-  /** Above normal + 1 */
-  osPriorityAboveNormal1  = 32+1,
-  /** Above normal + 2 */
-  osPriorityAboveNormal2  = 32+2,
-  /** Above normal + 3 */
-  osPriorityAboveNormal3  = 32+3,
-  /** Above normal + 4 */
-  osPriorityAboveNormal4  = 32+4,
-  /** Above normal + 5 */
-  osPriorityAboveNormal5  = 32+5,
-  /** Above normal + 6 */
-  osPriorityAboveNormal6  = 32+6,
-  /** Above normal + 7 (unsupported) */
-  osPriorityAboveNormal7  = 32+7,
-  /** High (unsupported) */
-  osPriorityHigh          = 40,
-  /** High + 1 (unsupported) */
-  osPriorityHigh1         = 40+1,
-  /** High + 2 (unsupported)  */
-  osPriorityHigh2         = 40+2,
-  /** High + 3 (unsupported)  */
-  osPriorityHigh3         = 40+3,
-  /** High + 4 (unsupported)  */
-  osPriorityHigh4         = 40+4,
-  /** High + 5 (unsupported)  */
-  osPriorityHigh5         = 40+5,
-  /** High + 6 (unsupported)  */
-  osPriorityHigh6         = 40+6,
-  /** High + 7 (unsupported)  */
-  osPriorityHigh7         = 40+7,
-  /** Real-time (unsupported)  */
-  osPriorityRealtime      = 48,
-  /** Real-time + 1 (unsupported) */
-  osPriorityRealtime1     = 48+1,
-  /** Real-time + 2 (unsupported) */
-  osPriorityRealtime2     = 48+2,
-  /** Real-time + 3 (unsupported) */
-  osPriorityRealtime3     = 48+3,
-  /** Real-time + 4 (unsupported) */
-  osPriorityRealtime4     = 48+4,
-  /** Real-time + 5 (unsupported) */
-  osPriorityRealtime5     = 48+5,
-  /** Real-time + 6 (unsupported) */
-  osPriorityRealtime6     = 48+6,
-  /** Real-time + 7 (unsupported) */
-  osPriorityRealtime7     = 48+7,
-  /** Reserved for ISR deferred threads (unsupported) */
-  osPriorityISR           = 56,
-  /** Invalid */
-  osPriorityError         = -1,
-  /** Reserved. It enables the compiler to identify enumeration variables as 32-bit numbers and prevents the enumeration variables from being optimized. */
-  osPriorityReserved      = 0x7FFFFFFF
-} osPriority_t;
-
-/**
-* @brief Callback for thread scheduling
-*
-*/
-typedef void (*osThreadFunc_t) (void *argument);
-
-/**
-* @brief Callback for timer triggering
-*
-*/
-typedef void (*osTimerFunc_t) (void *argument);
-
-/**
-* @brief Enumerates timer types.
-*
-*/
-typedef enum {
-  /** One-shot timer */
-  osTimerOnce               = 0,
-  /** Repeating timer */
-  osTimerPeriodic           = 1
-} osTimerType_t;
-
-/**
-* @brief Indicates that the RTOS waits forever unless an event flag is received.
-*
-*/
-#define osWaitForever         0xFFFFFFFFU
-
-/**
-* @brief Indicates that the RTOS does not wait.
-*
-*/
-#define osNoWait              0x0U
-
-/**
-* @brief Indicates that the RTOS waits until any event flag is triggered.
-*
-*/
-#define osFlagsWaitAny        0x00000000U
-
-/**
-* @brief Indicates that the system waits until all event flags are triggered.
-*
-*/
-#define osFlagsWaitAll        0x00000001U
-
-/**
-* @brief Indicates that defined flags are not cleared.
-*
-*/
-#define osFlagsNoClear        0x00000002U
-
-/**
-* @brief Indicates a flag error.
-*
-*/
-#define osFlagsError          0x80000000U
-
-/**
-* @brief Indicates an unknown error.
-*
-*/
-#define osFlagsErrorUnknown   0xFFFFFFFFU
-
-/**
-* @brief Indicates a timeout.
-*
-*/
-#define osFlagsErrorTimeout   0xFFFFFFFEU
-
-/**
-* @brief Indicates a resource error.
-*
-*/
-#define osFlagsErrorResource  0xFFFFFFFDU
-
-/**
-* @brief Indicates an incorrect parameter.
-*
-*/
-#define osFlagsErrorParameter 0xFFFFFFFCU
-#define osFlagsErrorISR       0xFFFFFFFAU
-
-// Thread attributes (attr_bits in \ref osThreadAttr_t).
-#define osThreadDetached      0x00000000U
-#define osThreadJoinable      0x00000001U
-
-// Mutex attributes (attr_bits in \ref osMutexAttr_t).
-#define osMutexRecursive      0x00000001U
-#define osMutexPrioInherit    0x00000002U
-#define osMutexRobust         0x00000008U
-
-/**
-* @brief Enumerates return values of CMSIS-RTOS.
-*
-*/
-typedef enum {
-  /** Operation completed successfully */
-  osOK                      =  0,
-  /** Unspecified error */
-  osError                   = -1,
-  /** Timeout */
-  osErrorTimeout            = -2,
-  /** Resource error */
-  osErrorResource           = -3,
-  /** Incorrect parameter */
-  osErrorParameter          = -4,
-  /** Insufficient memory */
-  osErrorNoMemory           = -5,
-  /** Service interruption */
-  osErrorISR                = -6,
-  /** Reserved. It is used to prevent the compiler from optimizing enumerations. */
-  osStatusReserved          = 0x7FFFFFFF
-} osStatus_t;
-
-/**
-* @brief Identifies a thread.
-*
-*/
-typedef void *osThreadId_t;
-
-/**
-* @brief Identifies a timer.
-*
-*/
-typedef void *osTimerId_t;
-
-/**
-* @brief Identifies an event flag.
-*
-*/
-typedef void *osEventFlagsId_t;
-
-/**
-* @brief Identifies a mutex.
-*
-*/
-typedef void *osMutexId_t;
-
-/**
-* @brief Identifies a semaphore object.
-*
-*/
-typedef void *osSemaphoreId_t;
-
-
-typedef void *osMemoryPoolId_t;
-
-/**
-* @brief Identifies a message queue.
-*
-*/
-typedef void *osMessageQueueId_t;
-
-
-#ifndef TZ_MODULEID_T
-#define TZ_MODULEID_T
-
-/**
-* @brief Identifies a TrustZone module call process.
-*
-*/
-typedef uint32_t TZ_ModuleId_t;
-#endif
-
-/**
-* @brief Describes thread attributes.
-*
-* @since 1.0
-* @version 1.0
-*/
-typedef struct {
-  /** Thread name */
-  const char                   *name;
-  /** Thread attribute bits */
-  uint32_t                 attr_bits;
-  /** Memory for the thread control block */
-  void                      *cb_mem;
-  /** Size of the memory for the thread control block */
-  uint32_t                   cb_size;
-  /** Memory for the thread stack */
-  void                   *stack_mem;
-  /** Size of the thread stack */
-  uint32_t                stack_size;
-  /** Thread priority */
-  osPriority_t              priority;
-  /** TrustZone module of the thread */
-  TZ_ModuleId_t            tz_module;
-  /** Reserved */
-  uint32_t                  reserved;
-} osThreadAttr_t;
-
-/**
-* @brief Describes timer attributes.
-*
-* @since 1.0
-* @version 1.0
-*/
-typedef struct {
-  /** Timer name */
-  const char                   *name;
-  /** Reserved attribute bits */
-  uint32_t                 attr_bits;
-  /** Memory for the timer control block */
-  void                      *cb_mem;
-  /** Size of the memory for the timer control block */
-  uint32_t                   cb_size;
-} osTimerAttr_t;
-
-/**
-* @brief Describes event attributes.
-*
-* @since 1.0
-* @version 1.0
-*/
-typedef struct {
-  /** Event name */
-  const char                   *name;
-  /** Reserved attribute bits */
-  uint32_t                 attr_bits;
-  /** Memory for the event control block */
-  void                      *cb_mem;
-  /** Size of the memory for the event control block */
-  uint32_t                   cb_size;
-} osEventFlagsAttr_t;
-
-/**
-* @brief Describes mutex attributes.
-*
-* @since 1.0
-* @version 1.0
-*/
-typedef struct {
-  /** Mutex name */
-  const char                   *name;
-  /** Reserved attribute bits */
-  uint32_t                 attr_bits;
-  /** Memory for the mutex control block */
-  void                      *cb_mem;
-  /** Size of the memory for the mutex control block */
-  uint32_t                   cb_size;
-} osMutexAttr_t;
-
-/**
-* @brief Describes semaphore attributes.
-*
-* @since 1.0
-* @version 1.0
-*/
-typedef struct {
-  /** Semaphore name */
-  const char                   *name;
-  /** Reserved attribute bits */
-  uint32_t                 attr_bits;
-  /** Memory for the semaphore control block */
-  void                      *cb_mem;
-  /** Size of the memory for the semaphore control block */
-  uint32_t                   cb_size;
-} osSemaphoreAttr_t;
-
-
-typedef struct {
-  const char                   *name;
-  uint32_t                 attr_bits;
-  void                      *cb_mem;
-  uint32_t                   cb_size;
-  void                      *mp_mem;
-  uint32_t                   mp_size;
-} osMemoryPoolAttr_t;
-
-/**
-* @brief Describes message queue attributes.
-*
-* @since 1.0
-* @version 1.0
-*/
-typedef struct {
-  /** Message queue name */
-  const char                   *name;
-  /** Reserved attribute bits */
-  uint32_t                 attr_bits;
-  /** Memory for the message queue control block */
-  void                      *cb_mem;
-  /** Size of the memory for the message queue control block */
-  uint32_t                   cb_size;
-  /** Memory for storing data in the message queue */
-  void                      *mq_mem;
-  /** Size of the memory for storing data in the message queue */
-  uint32_t                   mq_size;
-} osMessageQueueAttr_t;
-
-
-//  ==== Kernel Management Functions ====
-
-/**
-* @brief Initializes the RTOS kernel.
-*
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osKernelInitialize (void);
-
-/**
-* @brief Obtains the system version and name.
-*
-* @param version Indicates the pointer to the buffer for storing the version.
-* @param id_buf Indicates the pointer to the buffer for storing the kernel ID.
-* @param id_size Indicates the size of the buffer for storing the kernel ID.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size);
-
-/**
-* @brief Obtains the kernel state.
-*
-* @return Returns the kernel state.
-* @since 1.0
-* @version 1.0
-*/
-osKernelState_t osKernelGetState (void);
-
-/**
-* @brief Starts the kernel.
-*
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osKernelStart (void);
-
-/**
-* @brief Locks the kernel.
-*
-* @return Returns 1 if the kernel is locked successfully; returns 0 if the lock starts; returns a negative value in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-int32_t osKernelLock (void);
-
-/**
-* @brief Unlocks the kernel.
-*
-* @return Returns 1 if the kernel is unlocked successfully; returns 0 if the kernel is not locked; returns a negative value in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-int32_t osKernelUnlock (void);
-
-/**
-* @brief Restores the previous lock state of the kernel.
-*
-* @param lock Indicates the lock state to restore to. The value 1 indicates the locked state, and 0 indicates the unlocked state.
-* @return Returns 1 if the kernel is locked; returns 0 if the kernel is not locked; returns a negative value in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-int32_t osKernelRestoreLock (int32_t lock);
-
-uint32_t osKernelSuspend (void);
-
-void osKernelResume (uint32_t sleep_ticks);
-
-/// Get the RTOS kernel tick count.
-/// \return RTOS kernel current tick count.
-uint32_t osKernelGetTickCount (void);
-
-
-
-/**
-* @brief Obtains the number of kernel ticks per second.
-*
-* @return Returns the number of kernel ticks.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osKernelGetTickFreq (void);
-
-/**
-* @brief Obtains the kernel system timer.
-*
-* @return Returns the kernel system timer.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osKernelGetSysTimerCount (void);
-
-/**
-* @brief Obtains the frequency of the system timer.
-*
-* @return Returns the system timer frequency.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osKernelGetSysTimerFreq (void);
-
-
-//  ==== Thread Management Functions ====
-
-/**
-* @brief Creates an active thread.
-*
-* The task priority ranges from 9 (highest priority) to 38 (lowest priority). {@code LOSCFG_BASE_CORE_TSK_LIMIT} declared in target_config.h specifies the
-maximum number of tasks running in this system.
-* @param func Indicates the entry of the thread callback function.
-* @param argument Indicates the pointer to the argument passed to the thread.
-* @param attr Indicates the thread attributes.
-* @return Returns the thread ID; returns NULL in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr);
-
-/**
-* @brief Obtains the name of a thread.
-*
-* @param thread_id Indicates the thread ID, which is obtained using osThreadNew or osThreadGetId.
-* @return Returns the thread name; returns NULL in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-const char *osThreadGetName (osThreadId_t thread_id);
-
-/**
-* @brief Obtains the ID of the currently running thread.
-*
-* @return Returns the thread ID; returns NULL in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-osThreadId_t osThreadGetId (void);
-
-
-/**
-* @brief Obtains the state of a thread.
-*
-* @param thread_id Indicates the thread ID, which is obtained using osThreadNew or osThreadGetId.
-* @return Returns the thread state.
-* @since 1.0
-* @version 1.0
-*/
-osThreadState_t osThreadGetState (osThreadId_t thread_id);
-
-/**
-* @brief Obtains the stack size of a thread.
-*
-* @param thread_id Indicates the thread ID, which is obtained using osThreadNew or osThreadGetId.
-* @return Returns the stack size, in bytes; returns 0 in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osThreadGetStackSize (osThreadId_t thread_id);
-
-/**
-* @brief Obtains the size of the available stack space for a thread based on the stack watermark.
-*
-* @param thread_id Indicates the thread ID, which is obtained using osThreadNew or osThreadGetId.
-* @return Returns the available stack size, in bytes; returns 0 in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osThreadGetStackSpace (osThreadId_t thread_id);
-
-/**
-* @brief Changes the priority of a thread.
-*
-* @param thread_id Indicates the thread ID, which is obtained using osThreadNew or osThreadGetId.
-* @param priority Indicates the new priority.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority);
-
-/**
-* @brief Gets the prority of an active thread.
-*
-* @param thread_id Indicates the thread ID, which is obtained using osThreadNew or osThreadGetId.
-* @return Returns the prority of the thread.
-* @since 1.0
-* @version 1.0
-*/
-osPriority_t osThreadGetPriority (osThreadId_t thread_id);
-
-/**
-* @brief Sets the currently running thread to the ready state.
-*
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osThreadYield (void);
-
-/**
-* @brief Suspends a thread.
-*
-* @param thread_id Indicates the thread ID, which is obtained using osThreadNew or osThreadGetId.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osThreadSuspend (osThreadId_t thread_id);
-
-/**
-* @brief Resumes a thread from the suspended state.
-*
-* @param thread_id Indicates the thread ID, which is obtained using osThreadNew or osThreadGetId.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osThreadResume (osThreadId_t thread_id);
-
-osStatus_t osThreadDetach (osThreadId_t thread_id);
-
-osStatus_t osThreadJoin (osThreadId_t thread_id);
-
-void osThreadExit (void);
-
-/**
-* @brief Terminates a thread.
-*
-* @param thread_id Indicates the thread ID, which is obtained using osThreadNew or osThreadGetId.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osThreadTerminate (osThreadId_t thread_id);
-
-/**
-* @brief Obtains the number of active threads.
-*
-* @return Returns the number; returns 0 in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osThreadGetCount (void);
-
-uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items);
-
-
-//  ==== Thread Flags Functions ====
-
-uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags);
-
-uint32_t osThreadFlagsClear (uint32_t flags);
-
-uint32_t osThreadFlagsGet (void);
-
-uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout);
-
-
-//  ==== Generic Wait Functions ====
-
-/**
-* @brief Waits for a period of time.
-*
-* @param ticks Indicates the number of ticks to wait for.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osDelay (uint32_t ticks);
-
-/**
-* @brief Waits until a specified time arrives.
-*
-* This function handles the overflow of the system timer. Note that the maximum value of this parameter is (2^31 - 1) ticks.
-* @param ticks Indicates the number of ticks converted from the absolute time.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osDelayUntil (uint32_t ticks);
-
-
-//  ==== Timer Management Functions ====
-
-/**
-* @brief Creates and initializes a timer.
-*
-* This function creates a timer associated with the arguments callback function. The timer stays in the stopped state until OSTimerStart is used to start the timer.
-* The timer precision is 1000 / LOSCFG_BASE_CORE_TICK_PER_SECOND ms(LOSCFG_BASE_CORE_TICK_PER_SECOND is defined in the traget_config.h).
-* @param func Indicates the entry of the timer callback function.
-* @param type Indicates the timer type.
-* @param argument Indicates the pointer to the argument used in timer callback.
-* @param attr Indicates the pointer to the timer attributes. This parameter is not used.
-* @return Returns the timer ID; returns NULL in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-osTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr);
-
-/**
-* @brief Obtains the timer name.
-*
-* @param timer_id Indicates the timer ID, which is obtained using osTimerNew.
-* @return Returns the timer name; returns NULL in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-const char *osTimerGetName (osTimerId_t timer_id);
-
-/**
-* @brief Starts or restarts a timer.
-*
-* @param timer_id Indicates the timer ID, which is obtained using osTimerNew.
-* @param ticks Indicates the number of ticks since the timer starts running.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks);
-
-/**
-* @brief Stops a timer.
-*
-* @param timer_id Indicates the timer ID, which is obtained using osTimerNew.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osTimerStop (osTimerId_t timer_id);
-
-/**
-* @brief Checks whether a timer is running.
-*
-* @param timer_id Indicates the timer ID, which is obtained using osTimerNew.
-* @return Returns 1 if the timer is running; returns 0 otherwise.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osTimerIsRunning (osTimerId_t timer_id);
-
-/**
-* @brief Deletes a timer.
-*
-* @param timer_id Indicates the timer ID, which is obtained using osTimerNew.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osTimerDelete (osTimerId_t timer_id);
-
-
-//  ==== Event Flags Management Functions ====
-
-/**
-* @brief Creates and initializes an event flags object.
-*
-* @param attr Indicates the pointer to the event flags attributes. This parameter is not used.
-* @return Returns the event flags ID; returns NULL in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-osEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr);
-
-/**
-* @brief Obtains the name of an event flags object.
-*
-* @param ef_id Indicates the event flags ID, which is obtained using osEventFlagsNew.
-* @return Returns the event flags name; returns NULL in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-const char *osEventFlagsGetName (osEventFlagsId_t ef_id);
-
-/**
-* @brief Sets event flags.
-*
-* @param ef_id Indicates the event flags ID, which is obtained using osEventFlagsNew.
-* @param flags Indicates the event flags to set.
-* @return Returns the event flags; returns osFlagsErrorParameter in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags);
-
-/**
-* @brief Clears event flags.
-*
-* @param ef_id Indicates the event flags ID, which is obtained using osEventFlagsNew.
-* @param flags Indicates the event flags to clear.
-* @return Returns the event flags; returns osFlagsErrorParameter in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags);
-
-/**
-* @brief Obtains event flags.
-*
-* @param ef_id Indicates the event flags ID, which is obtained using osEventFlagsNew.
-* @return Returns the event flags triggered.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osEventFlagsGet (osEventFlagsId_t ef_id);
-
-/**
-* @brief Waits for event flags to trigger.
-*
-* This function is blocked if the specified event flags are not set via {@code flags}.
-* @param ef_id Indicates the event flags ID, which is obtained using osEventFlagsNew.
-* @param flags Indicates the event flags to trigger.
-* @param options Indicates the configuration of the event flags to trigger.
-* @param timeout Indicates the timeout duration.
-* @return Returns the triggered event flags; returns an error value in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout);
-
-/**
-* @brief Deletes an event flags object.
-*
-* @param ef_id Indicates the event flags ID, which is obtained using osEventFlagsNew.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id);
-
-
-//  ==== Mutex Management Functions ====
-
-/**
-* @brief Creates and initializes a mutex.
-*
-* @param attr Indicates the pointer to the mutex attributes. This parameter is not used.
-* @return Returns the mutex ID; returns NULL in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-osMutexId_t osMutexNew (const osMutexAttr_t *attr);
-
-const char *osMutexGetName (osMutexId_t mutex_id);
-
-/**
-* @brief Obtains a mutex.
-*
-* @param mutex_id Indicates the mutex ID, which is obtained using osMutexNew.
-* @param timeout Indicates the timeout duration.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout);
-
-/**
-* @brief Releases a mutex.
-*
-* @param mutex_id Indicates the mutex ID, which is obtained using osMutexNew.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osMutexRelease (osMutexId_t mutex_id);
-
-/**
-* @brief Obtains the thread ID of the currently acquired mutex.
-*
-* @param mutex_id Indicates the mutex ID, which is obtained using osMutexNew.
-* @return Returns the thread ID.
-* @since 1.0
-* @version 1.0
-*/
-osThreadId_t osMutexGetOwner (osMutexId_t mutex_id);
-
-/**
-* @brief Deletes a mutex.
-*
-* @param mutex_id Indicates the mutex ID, which is obtained using osMutexNew.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osMutexDelete (osMutexId_t mutex_id);
-
-
-//  ==== Semaphore Management Functions ====
-
-/**
-* @brief Creates and initializes a semaphore object.
-*
-* @param max_count Indicates the maximum number of available tokens that can be applied for.
-* @param initial_count Indicates the initial number of available tokens.
-* @param attr Indicates the pointer to the semaphore attributes. This parameter is not used.
-* @return Returns the semaphore ID; returns NULL in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr);
-
-const char *osSemaphoreGetName (osSemaphoreId_t semaphore_id);
-
-/**
-* @brief Acquires a token of a semaphore object.
-*
-* @param semaphore_id Indicates the semaphore ID, which is obtained using osSemaphoreNew.
-* @param timeout Indicates the timeout duration, in ticks.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout);
-
-/**
-* @brief Releases a token of a semaphore object.
-*
-* @param semaphore_id Indicates the semaphore ID, which is obtained using osSemaphoreNew.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id);
-
-/**
-* @brief Obtains the number of available tokens of a semaphore object.
-*
-* @param semaphore_id Indicates the semaphore ID, which is obtained using osSemaphoreNew.
-* @return Returns the number of available tokens.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id);
-
-/**
-* @brief Deletes a semaphore object.
-*
-* @param semaphore_id Indicates the semaphore ID, which is obtained using osSemaphoreNew.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id);
-
-
-//  ==== Memory Pool Management Functions ====
-
-osMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr);
-
-const char *osMemoryPoolGetName (osMemoryPoolId_t mp_id);
-
-void *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout);
-
-osStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block);
-
-uint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id);
-
-uint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id);
-
-uint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id);
-
-uint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id);
-
-osStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id);
-
-
-//  ==== Message Queue Management Functions ====
-
-/**
-* @brief Creates and initializes a message queue.
-*
-* @param msg_count Indicates the number of messages in the message queue.
-* @param msg_size Indicates the size of messages in the message queue.
-* @param attr Indicates the pointer to the message queue attributes. This parameter is not used.
-* @return Returns the message queue ID; returns NULL in the case of an error.
-* @since 1.0
-* @version 1.0
-*/
-osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr);
-
-const char *osMessageQueueGetName (osMessageQueueId_t mq_id);
-
-/**
-* @brief Places a message in a message queue.
-*
-* @param mq_id Indicates the message queue ID, which is obtained using osMessageQueueNew.
-* @param msg_ptr Indicates the pointer to the buffer for storing the message to be placed in the message queue.
-* @param msg_prio Indicates the priority of the message to be placed in the message queue. This parameter is not used.
-* @param timeout Indicates the timeout duration.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout);
-
-/**
-* @brief Obtains a message in a message queue.
-*
-* @param mq_id Indicates the message queue ID, which is obtained using osMessageQueueNew.
-* @param msg_ptr Indicates the pointer to the buffer for storing the message to be retrieved from the message queue.
-* @param msg_prio Indicates the pointer to the buffer for storing the priority of the message to be retrieved from the message queue. This parameter is not used.
-* @param timeout Indicates the timeout duration.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout);
-
-/**
-* @brief Obtains the maximum number of messages that can be placed in a message queue.
-*
-* @param mq_id Indicates the message queue ID, which is obtained using osMessageQueueNew.
-* @return Returns the maximum number.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id);
-
-/**
-* @brief Obtains the maximum size of messages that can be placed in a message queue.
-*
-* @param mq_id Indicates the message queue ID, which is obtained using osMessageQueueNew.
-* @return Returns the maximum message size.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id);
-
-/**
-* @brief Obtains the number of queued messages in a message queue.
-*
-* @param mq_id Indicates the message queue ID, which is obtained using osMessageQueueNew.
-* @return Returns the number of queued messages.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id);
-
-/**
-* @brief Obtains the number of available slots for messages in a message queue.
-*
-* @param mq_id Indicates the message queue ID, which is obtained using osMessageQueueNew.
-* @return Returns the number of available slots for messages.
-* @since 1.0
-* @version 1.0
-*/
-uint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id);
-
-osStatus_t osMessageQueueReset (osMessageQueueId_t mq_id);
-
-/**
-* @brief Deletes a message queue.
-*
-* @param mq_id Indicates the message queue ID, which is obtained using osMessageQueueNew.
-* @return Returns the CMSIS-RTOS running result.
-* @since 1.0
-* @version 1.0
-*/
-osStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id);
-
-
-#ifdef  __cplusplus
-}
-#endif
-
-#endif  // CMSIS_OS2_H_
+#include "../../../../third_party/cmsis/CMSIS/RTOS2/Include/cmsis_os2.h"
diff --git a/kernel/liteos_m/kal/cmsis/hos_cmsis_adp.h b/kernel/liteos_m/kal/cmsis/hos_cmsis_adp.h
index d513d6f..a9d5553 100644
--- a/kernel/liteos_m/kal/cmsis/hos_cmsis_adp.h
+++ b/kernel/liteos_m/kal/cmsis/hos_cmsis_adp.h
@@ -1,56 +1,56 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef HOS_CMSIS_ADP_H
-#define HOS_CMSIS_ADP_H
-
-#include "cmsis_os.h"
-#include "los_compiler.h"
-
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif
-#endif /* __cplusplus */
-
-typedef struct {
-    osSemaphoreAttr_t attr;
-    UINT32 maxCount;
-    UINT32 initialCount;
-} SemaphoreEx;
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif /* __cplusplus */
-
-#endif
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef HOS_CMSIS_ADP_H
+#define HOS_CMSIS_ADP_H
+
+#include "cmsis_os.h"
+#include "los_compiler.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+typedef struct {
+    osSemaphoreAttr_t attr;
+    UINT32 maxCount;
+    UINT32 initialCount;
+} SemaphoreEx;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif
diff --git a/kernel/liteos_m/kal/kal.h b/kernel/liteos_m/kal/cmsis/kal.h
old mode 100755
new mode 100644
similarity index 100%
rename from kernel/liteos_m/kal/kal.h
rename to kernel/liteos_m/kal/cmsis/kal.h
diff --git a/kernel/liteos_m/kal/posix/BUILD.gn b/kernel/liteos_m/kal/posix/BUILD.gn
index aaacb08..c54d37c 100644
--- a/kernel/liteos_m/kal/posix/BUILD.gn
+++ b/kernel/liteos_m/kal/posix/BUILD.gn
@@ -1,49 +1,60 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-static_library("posix") {
-  sources = [
-    "src/errno.c",
-    "src/libc.c",
-    "src/malloc.c",
-    "src/pthread.c",
-    "src/pthread_attr.c",
-    "src/pthread_mutex.c",
-    "src/semaphore.c",
-    "src/time.c",
-  ]
-
-  include_dirs = [
-    "include",
-    "../../kernel/arch/include",
-    "../../kernel/include",
-    "../../utils",
-    "//third_party/bounds_checking_function/include",
-  ]
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+config("include") {
+  include_dirs = [ "include" ]
+}
+
+static_library("posix") {
+  sources = [
+    "src/errno.c",
+    "src/libc.c",
+    "src/malloc.c",
+    "src/mqueue.c",
+    "src/pthread.c",
+    "src/pthread_attr.c",
+    "src/pthread_cond.c",
+    "src/pthread_mutex.c",
+    "src/semaphore.c",
+    "src/time.c",
+  ]
+
+  include_dirs = [
+    "../../kernel/arch/include",
+    "../../kernel/include",
+    "../../utils",
+  ]
+
+  public_configs = [ ":include" ]
+
+  public_deps = [
+    "//third_party/musl/porting/liteos_m/kernel",
+    "//third_party/bounds_checking_function:libsec_static",
+  ]
+}
diff --git a/kernel/liteos_m/kal/posix/src/errno.c b/kernel/liteos_m/kal/posix/src/errno.c
index 790cc5e..59ef3cb 100644
--- a/kernel/liteos_m/kal/posix/src/errno.c
+++ b/kernel/liteos_m/kal/posix/src/errno.c
@@ -1,49 +1,49 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <errno.h>
-#include "los_interrupt.h"
-#include "los_task.h"
-
-/* the specific errno get or set in interrupt service routine */
-static int g_isrErrno;
-
-int *__errno_location(void)
-{
-    LosTaskCB *runTask = NULL;
-
-    if (OS_INT_INACTIVE) {
-        runTask = OS_TCB_FROM_TID(LOS_CurTaskIDGet());
-        return &runTask->errorNo;
-    } else {
-        return &g_isrErrno;
-    }
-}
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include "los_interrupt.h"
+#include "los_task.h"
+
+/* the specific errno get or set in interrupt service routine */
+static int g_isrErrno;
+
+int *__errno_location(void)
+{
+    LosTaskCB *runTask = NULL;
+
+    if (OS_INT_INACTIVE) {
+        runTask = OS_TCB_FROM_TID(LOS_CurTaskIDGet());
+        return &runTask->errorNo;
+    } else {
+        return &g_isrErrno;
+    }
+}
diff --git a/kernel/liteos_m/kal/posix/src/libc.c b/kernel/liteos_m/kal/posix/src/libc.c
index a4018d5..338d961 100644
--- a/kernel/liteos_m/kal/posix/src/libc.c
+++ b/kernel/liteos_m/kal/posix/src/libc.c
@@ -1,51 +1,51 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <libc.h>
-#include "libc_config.h"
-
-/**
- * get libc version string.
- * @return libc version string. the format is <major>.<minor>.<patch>[-<platform>[-<desc>]]
- */
-const char *libc_get_version_string(void)
-{
-    return LIBC_VERSION_STR;
-}
-
-/**
- * get libc version code.
- * @return libc version code. the format is 0x00XXYYZZ, XX is major version, YY is minor version and ZZ is patch version
- */
-int libc_get_version(void)
-{
-    return LIBC_VERSION_NUM;
-}
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <libc.h>
+#include "libc_config.h"
+
+/**
+ * get libc version string.
+ * @return libc version string. the format is <major>.<minor>.<patch>[-<platform>[-<desc>]]
+ */
+const char *libc_get_version_string(void)
+{
+    return LIBC_VERSION_STR;
+}
+
+/**
+ * get libc version code.
+ * @return libc version code. the format is 0x00XXYYZZ, XX is major version, YY is minor version and ZZ is patch version
+ */
+int libc_get_version(void)
+{
+    return LIBC_VERSION_NUM;
+}
diff --git a/kernel/liteos_m/kal/posix/src/malloc.c b/kernel/liteos_m/kal/posix/src/malloc.c
index 8b9a26f..c206238 100644
--- a/kernel/liteos_m/kal/posix/src/malloc.c
+++ b/kernel/liteos_m/kal/posix/src/malloc.c
@@ -33,11 +33,6 @@
 #include "los_config.h"
 #include "los_memory.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
 
 void *calloc(size_t nitems, size_t size)
 {
@@ -112,8 +107,3 @@ void *realloc(void *ptr, size_t size)
     return LOS_MemRealloc(OS_SYS_MEM_ADDR, ptr, size);
 }
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
diff --git a/kernel/liteos_m/kal/posix/src/mqueue.c b/kernel/liteos_m/kal/posix/src/mqueue.c
index 48b6667..45e2a05 100644
--- a/kernel/liteos_m/kal/posix/src/mqueue.c
+++ b/kernel/liteos_m/kal/posix/src/mqueue.c
@@ -1,606 +1,616 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "mqueue_impl.h"
-#include "time_internal.h"
-
-/* GLOBALS */
-STATIC struct mqarray g_queueTable[LOSCFG_BASE_IPC_QUEUE_LIMIT];
-STATIC pthread_mutex_t g_mqueueMutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
-
-int MapMqErrno(UINT32 err)
-{
-    if (err == LOS_OK) {
-        return ENOERR;
-    }
-    switch (err) {
-        case LOS_ERRNO_QUEUE_INVALID:
-        case LOS_ERRNO_QUEUE_WRITE_PTR_NULL:
-        case LOS_ERRNO_QUEUE_WRITESIZE_ISZERO:
-        case LOS_ERRNO_QUEUE_SIZE_TOO_BIG:
-        case LOS_ERRNO_QUEUE_CREAT_PTR_NULL:
-        case LOS_ERRNO_QUEUE_PARA_ISZERO:
-        case LOS_ERRNO_QUEUE_WRITE_SIZE_TOO_BIG:
-            errno = EINVAL;
-            break;
-        case LOS_ERRNO_QUEUE_ISFULL:
-        case LOS_ERRNO_QUEUE_ISEMPTY:
-            errno = EAGAIN;
-            break;
-        case LOS_ERRNO_QUEUE_CREATE_NO_MEMORY:
-            errno = ENOSPC;
-            break;
-        case LOS_ERRNO_QUEUE_TIMEOUT:
-            errno = ETIMEDOUT;
-            break;
-        case LOS_ERRNO_QUEUE_CB_UNAVAILABLE:
-            errno = ENFILE;
-            break;
-        case LOS_ERRNO_QUEUE_READ_IN_INTERRUPT:
-        case LOS_ERRNO_QUEUE_WRITE_IN_INTERRUPT:
-            errno = EINTR;
-            break;
-        default:
-            errno = EINVAL;
-            break;
-    }
-    return errno;
-}
-
-STATIC INLINE INT32 MqNameCheck(const CHAR *mqName)
-{
-    if (mqName == NULL) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    if (strlen(mqName) == 0) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    if (strlen(mqName) > (PATH_MAX - 1)) {
-        errno = ENAMETOOLONG;
-        return -1;
-    }
-    return 0;
-}
-
-STATIC INLINE UINT32 GetMqueueCBByID(UINT32 queueID, LosQueueCB **queueCB)
-{
-    LosQueueCB *tmpQueueCB = NULL;
-    if (queueCB == NULL) {
-        errno = EINVAL;
-        return LOS_ERRNO_QUEUE_READ_PTR_NULL;
-    }
-    tmpQueueCB = GET_QUEUE_HANDLE(queueID);
-    if ((GET_QUEUE_INDEX(queueID) >= LOSCFG_BASE_IPC_QUEUE_LIMIT) || (tmpQueueCB->queueID != queueID)) {
-        return LOS_ERRNO_QUEUE_INVALID;
-    }
-    *queueCB = tmpQueueCB;
-
-    return LOS_OK;
-}
-
-STATIC INLINE struct mqarray *GetMqueueCBByName(const CHAR *name)
-{
-    UINT32 index;
-    UINT32 mylen = strlen(name);
-
-    for (index = 0; index < LOSCFG_BASE_IPC_QUEUE_LIMIT; index++) {
-        if ((g_queueTable[index].mq_name == NULL) || (strlen(g_queueTable[index].mq_name) != mylen)) {
-            continue;
-        }
-
-        if (strncmp(name, (const CHAR *)(g_queueTable[index].mq_name), mylen) == 0) {
-            return &(g_queueTable[index]);
-        }
-    }
-
-    return NULL;
-}
-
-STATIC INT32 DoMqueueDelete(struct mqarray *mqueueCB)
-{
-    UINT32 ret;
-
-    if (mqueueCB->mq_name != NULL) {
-        LOS_MemFree(OS_SYS_MEM_ADDR, mqueueCB->mq_name);
-        mqueueCB->mq_name = NULL;
-    }
-
-    mqueueCB->mqcb = NULL;
-
-    ret = LOS_QueueDelete(mqueueCB->mq_id);
-    switch (ret) {
-        case LOS_OK:
-            return 0;
-        case LOS_ERRNO_QUEUE_NOT_FOUND:
-        case LOS_ERRNO_QUEUE_NOT_CREATE:
-        case LOS_ERRNO_QUEUE_IN_TSKUSE:
-        case LOS_ERRNO_QUEUE_IN_TSKWRITE:
-            errno = EAGAIN;
-            return -1;
-        default:
-            errno = EINVAL;
-            return -1;
-    }
-}
-
-STATIC int SaveMqueueName(const CHAR *mqName, struct mqarray *mqueueCB)
-{
-    size_t nameLen;
-
-    nameLen = strlen(mqName); /* sys_mq_open has checked name and name length */
-    mqueueCB->mq_name = (char *)LOS_MemAlloc(OS_SYS_MEM_ADDR, nameLen + 1);
-    if (mqueueCB->mq_name == NULL) {
-        errno = ENOMEM;
-        return LOS_NOK;
-    }
-
-    if (strncpy_s(mqueueCB->mq_name, (nameLen + 1), mqName, nameLen) != EOK) {
-        LOS_MemFree(OS_SYS_MEM_ADDR, mqueueCB->mq_name);
-        mqueueCB->mq_name = NULL;
-        errno = EINVAL;
-        return LOS_NOK;
-    }
-    mqueueCB->mq_name[nameLen] = '\0';
-    return LOS_OK;
-}
-
-STATIC struct mqpersonal *DoMqueueCreate(const struct mq_attr *attr, const CHAR *mqName, INT32 openFlag)
-{
-    struct mqarray *mqueueCB = NULL;
-    UINT32 mqueueID;
-
-    UINT32 err = LOS_QueueCreate(NULL, attr->mq_maxmsg, &mqueueID, 0, attr->mq_msgsize);
-    if (MapMqErrno(err) != ENOERR) {
-        goto ERROUT;
-    }
-
-    if (g_queueTable[GET_QUEUE_INDEX(mqueueID)].mqcb == NULL) {
-        mqueueCB = &(g_queueTable[GET_QUEUE_INDEX(mqueueID)]);
-        mqueueCB->mq_id = mqueueID;
-    }
-
-    if (mqueueCB == NULL) {
-        errno = EINVAL;
-        goto ERROUT;
-    }
-
-    if (SaveMqueueName(mqName, mqueueCB) != LOS_OK) {
-        goto ERROUT;
-    }
-
-    if (GetMqueueCBByID(mqueueCB->mq_id, &(mqueueCB->mqcb)) != LOS_OK) {
-        errno = ENOSPC;
-        goto ERROUT;
-    }
-
-    mqueueCB->mq_personal = (struct mqpersonal *)LOS_MemAlloc(OS_SYS_MEM_ADDR, sizeof(struct mqpersonal));
-    if (mqueueCB->mq_personal == NULL) {
-        (VOID)LOS_QueueDelete(mqueueCB->mq_id);
-        mqueueCB->mqcb->queue = NULL;
-        mqueueCB->mqcb = NULL;
-        errno = ENOSPC;
-        goto ERROUT;
-    }
-
-    mqueueCB->unlinkflag = FALSE;
-    mqueueCB->mq_personal->mq_status = MQ_USE_MAGIC;
-    mqueueCB->mq_personal->mq_next = NULL;
-    mqueueCB->mq_personal->mq_posixdes = mqueueCB;
-    mqueueCB->mq_personal->mq_flags = (INT32)((UINT32)openFlag | ((UINT32)attr->mq_flags & (UINT32)FNONBLOCK));
-
-    return mqueueCB->mq_personal;
-ERROUT:
-
-    if ((mqueueCB != NULL) && (mqueueCB->mq_name != NULL)) {
-        LOS_MemFree(OS_SYS_MEM_ADDR, mqueueCB->mq_name);
-        mqueueCB->mq_name = NULL;
-    }
-    return (struct mqpersonal *)-1;
-}
-
-STATIC struct mqpersonal *DoMqueueOpen(struct mqarray *mqueueCB, INT32 openFlag)
-{
-    struct mqpersonal *privateMqPersonal = NULL;
-
-    /* already have the same name of g_squeuetable */
-    if (mqueueCB->unlinkflag == TRUE) {
-        errno = EINVAL;
-        goto ERROUT;
-    }
-    /* alloc mqprivate and add to mqarray */
-    privateMqPersonal = (struct mqpersonal *)LOS_MemAlloc(OS_SYS_MEM_ADDR, sizeof(struct mqpersonal));
-    if (privateMqPersonal == NULL) {
-        errno = ENOSPC;
-        goto ERROUT;
-    }
-
-    privateMqPersonal->mq_next = mqueueCB->mq_personal;
-    mqueueCB->mq_personal = privateMqPersonal;
-
-    privateMqPersonal->mq_posixdes = mqueueCB;
-    privateMqPersonal->mq_flags = openFlag;
-    privateMqPersonal->mq_status = MQ_USE_MAGIC;
-
-    return privateMqPersonal;
-
-ERROUT:
-    return (struct mqpersonal *)-1;
-}
-
-mqd_t mq_open(const char *mqName, int openFlag, ...)
-{
-    struct mqarray *mqueueCB = NULL;
-    struct mqpersonal *privateMqPersonal = (struct mqpersonal *)-1;
-    struct mq_attr *attr = NULL;
-    struct mq_attr defaultAttr = { 0, MQ_MAX_MSG_NUM, MQ_MAX_MSG_LEN, 0, {0} };
-
-    va_list ap;
-
-    if (MqNameCheck(mqName) == -1) {
-        return (mqd_t)-1;
-    }
-
-    (VOID)pthread_mutex_lock(&g_mqueueMutex);
-    mqueueCB = GetMqueueCBByName(mqName);
-    if ((UINT32)openFlag & (UINT32)O_CREAT) {
-        if (mqueueCB != NULL) {
-            if (((UINT32)openFlag & (UINT32)O_EXCL)) {
-                errno = EEXIST;
-                goto OUT;
-            }
-            privateMqPersonal = DoMqueueOpen(mqueueCB, openFlag);
-        } else {
-            va_start(ap, openFlag);
-            (VOID)va_arg(ap, int);
-            attr = va_arg(ap, struct mq_attr *);
-            va_end(ap);
-
-            if (attr != NULL) {
-                (VOID)memcpy_s(&defaultAttr, sizeof(struct mq_attr), attr, sizeof(struct mq_attr));
-                if ((defaultAttr.mq_maxmsg < 0) || (defaultAttr.mq_maxmsg > (long int)USHRT_MAX) ||
-                    (defaultAttr.mq_msgsize < 0) || (defaultAttr.mq_msgsize > (long int)(USHRT_MAX - sizeof(UINT32)))) {
-                    errno = EINVAL;
-                    goto OUT;
-                }
-            }
-            privateMqPersonal = DoMqueueCreate(&defaultAttr, mqName, openFlag);
-        }
-    } else {
-        if (mqueueCB == NULL) {
-            errno = ENOENT;
-            goto OUT;
-        }
-        privateMqPersonal = DoMqueueOpen(mqueueCB, openFlag);
-    }
-
-OUT:
-    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-    return (mqd_t)privateMqPersonal;
-}
-
-int mq_close(mqd_t personal)
-{
-    INT32 ret = 0;
-    struct mqarray *mqueueCB = NULL;
-    struct mqpersonal *privateMqPersonal = NULL;
-    struct mqpersonal *tmp = NULL;
-
-    (VOID)pthread_mutex_lock(&g_mqueueMutex);
-    privateMqPersonal = (struct mqpersonal *)personal;
-    if (privateMqPersonal->mq_status != MQ_USE_MAGIC) {
-        errno = EBADF;
-        goto OUT_UNLOCK;
-    }
-
-    mqueueCB = privateMqPersonal->mq_posixdes;
-    if (mqueueCB->mq_personal == NULL) {
-        errno = EBADF;
-        goto OUT_UNLOCK;
-    }
-
-    /* find the personal and remove */
-    if (mqueueCB->mq_personal == privateMqPersonal) {
-        mqueueCB->mq_personal = privateMqPersonal->mq_next;
-    } else {
-        for (tmp = mqueueCB->mq_personal; tmp->mq_next != NULL; tmp = tmp->mq_next) {
-            if (tmp->mq_next == privateMqPersonal) {
-                break;
-            }
-        }
-        if (tmp->mq_next == NULL) {
-            errno = EBADF;
-            goto OUT_UNLOCK;
-        }
-        tmp->mq_next = privateMqPersonal->mq_next;
-    }
-    /* flag no use */
-    privateMqPersonal->mq_status = 0;
-
-    /* free the personal */
-    ret = LOS_MemFree(OS_SYS_MEM_ADDR, privateMqPersonal);
-    if (ret != LOS_OK) {
-        errno = EFAULT;
-        ret = -1;
-        goto OUT_UNLOCK;
-    }
-
-    if ((mqueueCB->unlinkflag == TRUE) && (mqueueCB->mq_personal == NULL)) {
-        ret = DoMqueueDelete(mqueueCB);
-    }
-OUT_UNLOCK:
-    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-    return ret;
-}
-
-int OsMqGetAttr(mqd_t personal, struct mq_attr *mqAttr)
-{
-    struct mqarray *mqueueCB = NULL;
-    struct mqpersonal *privateMqPersonal = NULL;
-
-    if (mqAttr == NULL) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    (VOID)pthread_mutex_lock(&g_mqueueMutex);
-    privateMqPersonal = (struct mqpersonal *)personal;
-    if (privateMqPersonal->mq_status != MQ_USE_MAGIC) {
-        errno = EBADF;
-        (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-        return -1;
-    }
-
-    mqueueCB = privateMqPersonal->mq_posixdes;
-    mqAttr->mq_maxmsg = mqueueCB->mqcb->queueLen;
-    mqAttr->mq_msgsize = mqueueCB->mqcb->queueSize - sizeof(UINT32);
-    mqAttr->mq_curmsgs = mqueueCB->mqcb->readWriteableCnt[OS_QUEUE_READ];
-    mqAttr->mq_flags = privateMqPersonal->mq_flags;
-    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-    return 0;
-}
-
-int OsMqSetAttr(mqd_t personal, const struct mq_attr *mqSetAttr, struct mq_attr *mqOldAttr)
-{
-    struct mqpersonal *privateMqPersonal = NULL;
-
-    if (mqSetAttr == NULL) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    (VOID)pthread_mutex_lock(&g_mqueueMutex);
-    privateMqPersonal = (struct mqpersonal *)personal;
-    if (privateMqPersonal->mq_status != MQ_USE_MAGIC) {
-        errno = EBADF;
-        (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-        return -1;
-    }
-
-    if (mqOldAttr != NULL) {
-        (VOID)OsMqGetAttr((mqd_t)privateMqPersonal, mqOldAttr);
-    }
-
-    privateMqPersonal->mq_flags = (INT32)((UINT32)privateMqPersonal->mq_flags & (UINT32)(~FNONBLOCK)); /* clear */
-    if (((UINT32)mqSetAttr->mq_flags & (UINT32)FNONBLOCK) == (UINT32)FNONBLOCK) {
-        privateMqPersonal->mq_flags = (INT32)((UINT32)privateMqPersonal->mq_flags | (UINT32)FNONBLOCK);
-    }
-    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-    return 0;
-}
-
-int mq_getsetattr(mqd_t mqd, const struct mq_attr *new, struct mq_attr *old)
-{
-    if (new == NULL) {
-        return OsMqGetAttr(mqd, old);
-    }
-    return OsMqSetAttr(mqd, new, old);
-}
-
-int mq_unlink(const char *mqName)
-{
-    INT32 ret = 0;
-    struct mqarray *mqueueCB = NULL;
-
-    if (MqNameCheck(mqName) == -1) {
-        return -1;
-    }
-
-    (VOID)pthread_mutex_lock(&g_mqueueMutex);
-    mqueueCB = GetMqueueCBByName(mqName);
-    if (mqueueCB == NULL) {
-        errno = ENOENT;
-        goto ERROUT_UNLOCK;
-    }
-
-    if (mqueueCB->mq_personal != NULL) {
-        mqueueCB->unlinkflag = TRUE;
-    } else {
-        ret = DoMqueueDelete(mqueueCB);
-    }
-
-    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-    return ret;
-
-ERROUT_UNLOCK:
-    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-    return -1;
-}
-
-STATIC INT32 ConvertTimeout(long flags, const struct timespec *absTimeout, UINT64 *ticks)
-{
-    if ((UINT32)flags & (UINT32)FNONBLOCK) {
-        *ticks = LOS_NO_WAIT;
-        return 0;
-    }
-
-    if (absTimeout == NULL) {
-        *ticks = LOS_WAIT_FOREVER;
-        return 0;
-    }
-
-    if (!ValidTimeSpec(absTimeout)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    *ticks = OsTimeSpec2Tick(absTimeout);
-    return 0;
-}
-
-STATIC INLINE BOOL MqParamCheck(mqd_t personal, const char *msg, size_t msgLen)
-{
-    (void)personal;
-    if ((msg == NULL) || (msgLen == 0)) {
-        errno = EINVAL;
-        return FALSE;
-    }
-    return TRUE;
-}
-
-#define OS_MQ_GOTO_ERROUT_UNLOCK_IF(expr, errcode) \
-    if (expr) {                        \
-        errno = errcode;                 \
-        goto ERROUT_UNLOCK;                     \
-    }
-#define OS_MQ_GOTO_ERROUT_IF(expr, errcode) \
-    if (expr) {                        \
-        errno = errcode;                 \
-        goto ERROUT;                     \
-    }
-int mq_timedsend(mqd_t personal, const char *msg, size_t msgLen, unsigned int msgPrio,
-                 const struct timespec *absTimeout)
-{
-    UINT32 mqueueID, err;
-    UINT64 absTicks;
-    struct mqarray *mqueueCB = NULL;
-    struct mqpersonal *privateMqPersonal = NULL;
-
-    OS_MQ_GOTO_ERROUT_IF(!MqParamCheck(personal, msg, msgLen), errno);
-
-    OS_MQ_GOTO_ERROUT_IF(msgPrio > (MQ_PRIO_MAX - 1), EINVAL);
-
-    (VOID)pthread_mutex_lock(&g_mqueueMutex);
-    privateMqPersonal = (struct mqpersonal *)personal;
-    OS_MQ_GOTO_ERROUT_UNLOCK_IF(privateMqPersonal->mq_status != MQ_USE_MAGIC, EBADF);
-
-    mqueueCB = privateMqPersonal->mq_posixdes;
-    OS_MQ_GOTO_ERROUT_UNLOCK_IF(msgLen > (size_t)(mqueueCB->mqcb->queueSize - sizeof(UINT32)), EMSGSIZE);
-
-    OS_MQ_GOTO_ERROUT_UNLOCK_IF((((UINT32)privateMqPersonal->mq_flags & (UINT32)O_WRONLY) != (UINT32)O_WRONLY) &&
-                                (((UINT32)privateMqPersonal->mq_flags & (UINT32)O_RDWR) != (UINT32)O_RDWR),
-                                EBADF);
-
-    OS_MQ_GOTO_ERROUT_UNLOCK_IF(ConvertTimeout(privateMqPersonal->mq_flags, absTimeout, &absTicks) == -1, errno);
-    mqueueID = mqueueCB->mq_id;
-    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-
-    err = LOS_QueueWriteCopy(mqueueID, (VOID *)msg, (UINT32)msgLen, (UINT32)absTicks);
-    if (MapMqErrno(err) != ENOERR) {
-        goto ERROUT;
-    }
-    return 0;
-ERROUT_UNLOCK:
-    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-ERROUT:
-    return -1;
-}
-
-ssize_t mq_timedreceive(mqd_t personal, char *msg, size_t msgLen, unsigned int *msgPrio,
-                        const struct timespec *absTimeout)
-{
-    UINT32 mqueueID, err;
-    UINT32 receiveLen;
-    UINT64 absTicks;
-    struct mqarray *mqueueCB = NULL;
-    struct mqpersonal *privateMqPersonal = NULL;
-
-    if (!MqParamCheck(personal, msg, msgLen)) {
-        goto ERROUT;
-    }
-
-    if (msgPrio != NULL) {
-        *msgPrio = 0;
-    }
-
-    (VOID)pthread_mutex_lock(&g_mqueueMutex);
-    privateMqPersonal = (struct mqpersonal *)personal;
-    if (privateMqPersonal->mq_status != MQ_USE_MAGIC) {
-        errno = EBADF;
-        goto ERROUT_UNLOCK;
-    }
-
-    mqueueCB = privateMqPersonal->mq_posixdes;
-    if (msgLen < (size_t)(mqueueCB->mqcb->queueSize - sizeof(UINT32))) {
-        errno = EMSGSIZE;
-        goto ERROUT_UNLOCK;
-    }
-
-    if (((UINT32)privateMqPersonal->mq_flags & (UINT32)O_WRONLY) == (UINT32)O_WRONLY) {
-        errno = EBADF;
-        goto ERROUT_UNLOCK;
-    }
-
-    if (ConvertTimeout(privateMqPersonal->mq_flags, absTimeout, &absTicks) == -1) {
-        goto ERROUT_UNLOCK;
-    }
-
-    receiveLen = msgLen;
-    mqueueID = mqueueCB->mq_id;
-    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-
-    err = LOS_QueueReadCopy(mqueueID, (VOID *)msg, &receiveLen, (UINT32)absTicks);
-    if (MapMqErrno(err) == ENOERR) {
-        return (ssize_t)receiveLen;
-    } else {
-        goto ERROUT;
-    }
-
-ERROUT_UNLOCK:
-    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
-ERROUT:
-    return -1;
-}
-
-/* not support the prio */
-int mq_send(mqd_t personal, const char *msg_ptr, size_t msg_len, unsigned int msg_prio)
-{
-    return mq_timedsend(personal, msg_ptr, msg_len, msg_prio, NULL);
-}
-
-ssize_t mq_receive(mqd_t personal, char *msg_ptr, size_t msg_len, unsigned int *msg_prio)
-{
-    return mq_timedreceive(personal, msg_ptr, msg_len, msg_prio, NULL);
-}
-
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "mqueue_impl.h"
+#include "time_internal.h"
+
+/* GLOBALS */
+STATIC struct mqarray g_queueTable[LOSCFG_BASE_IPC_QUEUE_LIMIT];
+STATIC pthread_mutex_t g_mqueueMutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+
+int MapMqErrno(UINT32 err)
+{
+    if (err == LOS_OK) {
+        return ENOERR;
+    }
+    switch (err) {
+        case LOS_ERRNO_QUEUE_INVALID:
+        case LOS_ERRNO_QUEUE_WRITE_PTR_NULL:
+        case LOS_ERRNO_QUEUE_WRITESIZE_ISZERO:
+        case LOS_ERRNO_QUEUE_SIZE_TOO_BIG:
+        case LOS_ERRNO_QUEUE_CREAT_PTR_NULL:
+        case LOS_ERRNO_QUEUE_PARA_ISZERO:
+        case LOS_ERRNO_QUEUE_WRITE_SIZE_TOO_BIG:
+            errno = EINVAL;
+            break;
+        case LOS_ERRNO_QUEUE_ISFULL:
+        case LOS_ERRNO_QUEUE_ISEMPTY:
+            errno = EAGAIN;
+            break;
+        case LOS_ERRNO_QUEUE_CREATE_NO_MEMORY:
+            errno = ENOSPC;
+            break;
+        case LOS_ERRNO_QUEUE_TIMEOUT:
+            errno = ETIMEDOUT;
+            break;
+        case LOS_ERRNO_QUEUE_CB_UNAVAILABLE:
+            errno = ENFILE;
+            break;
+        case LOS_ERRNO_QUEUE_READ_IN_INTERRUPT:
+        case LOS_ERRNO_QUEUE_WRITE_IN_INTERRUPT:
+            errno = EINTR;
+            break;
+        default:
+            errno = EINVAL;
+            break;
+    }
+    return errno;
+}
+
+STATIC INLINE INT32 MqNameCheck(const CHAR *mqName)
+{
+    if (mqName == NULL) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if (strlen(mqName) == 0) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if (strlen(mqName) > (PATH_MAX - 1)) {
+        errno = ENAMETOOLONG;
+        return -1;
+    }
+    return 0;
+}
+
+STATIC INLINE UINT32 GetMqueueCBByID(UINT32 queueID, LosQueueCB **queueCB)
+{
+    LosQueueCB *tmpQueueCB = NULL;
+    if (queueCB == NULL) {
+        errno = EINVAL;
+        return LOS_ERRNO_QUEUE_READ_PTR_NULL;
+    }
+    tmpQueueCB = GET_QUEUE_HANDLE(queueID);
+    if ((GET_QUEUE_INDEX(queueID) >= LOSCFG_BASE_IPC_QUEUE_LIMIT) || (tmpQueueCB->queueID != queueID)) {
+        return LOS_ERRNO_QUEUE_INVALID;
+    }
+    *queueCB = tmpQueueCB;
+
+    return LOS_OK;
+}
+
+STATIC INLINE struct mqarray *GetMqueueCBByName(const CHAR *name)
+{
+    UINT32 index;
+    UINT32 mylen = strlen(name);
+
+    for (index = 0; index < LOSCFG_BASE_IPC_QUEUE_LIMIT; index++) {
+        if ((g_queueTable[index].mq_name == NULL) || (strlen(g_queueTable[index].mq_name) != mylen)) {
+            continue;
+        }
+
+        if (strncmp(name, (const CHAR *)(g_queueTable[index].mq_name), mylen) == 0) {
+            return &(g_queueTable[index]);
+        }
+    }
+
+    return NULL;
+}
+
+STATIC INT32 DoMqueueDelete(struct mqarray *mqueueCB)
+{
+    UINT32 ret;
+
+    if (mqueueCB->mq_name != NULL) {
+        LOS_MemFree(OS_SYS_MEM_ADDR, mqueueCB->mq_name);
+        mqueueCB->mq_name = NULL;
+    }
+
+    mqueueCB->mqcb = NULL;
+
+    ret = LOS_QueueDelete(mqueueCB->mq_id);
+    switch (ret) {
+        case LOS_OK:
+            return 0;
+        case LOS_ERRNO_QUEUE_NOT_FOUND:
+        case LOS_ERRNO_QUEUE_NOT_CREATE:
+        case LOS_ERRNO_QUEUE_IN_TSKUSE:
+        case LOS_ERRNO_QUEUE_IN_TSKWRITE:
+            errno = EAGAIN;
+            return -1;
+        default:
+            errno = EINVAL;
+            return -1;
+    }
+}
+
+STATIC int SaveMqueueName(const CHAR *mqName, struct mqarray *mqueueCB)
+{
+    size_t nameLen;
+
+    nameLen = strlen(mqName); /* sys_mq_open has checked name and name length */
+    mqueueCB->mq_name = (char *)LOS_MemAlloc(OS_SYS_MEM_ADDR, nameLen + 1);
+    if (mqueueCB->mq_name == NULL) {
+        errno = ENOMEM;
+        return LOS_NOK;
+    }
+
+    if (strncpy_s(mqueueCB->mq_name, (nameLen + 1), mqName, nameLen) != EOK) {
+        LOS_MemFree(OS_SYS_MEM_ADDR, mqueueCB->mq_name);
+        mqueueCB->mq_name = NULL;
+        errno = EINVAL;
+        return LOS_NOK;
+    }
+    mqueueCB->mq_name[nameLen] = '\0';
+    return LOS_OK;
+}
+
+STATIC struct mqpersonal *DoMqueueCreate(const struct mq_attr *attr, const CHAR *mqName, INT32 openFlag)
+{
+    struct mqarray *mqueueCB = NULL;
+    UINT32 mqueueID;
+
+    UINT32 err = LOS_QueueCreate(NULL, attr->mq_maxmsg, &mqueueID, 0, attr->mq_msgsize);
+    if (MapMqErrno(err) != ENOERR) {
+        goto ERROUT;
+    }
+
+    if (g_queueTable[GET_QUEUE_INDEX(mqueueID)].mqcb == NULL) {
+        mqueueCB = &(g_queueTable[GET_QUEUE_INDEX(mqueueID)]);
+        mqueueCB->mq_id = mqueueID;
+    }
+
+    if (mqueueCB == NULL) {
+        errno = EINVAL;
+        goto ERROUT;
+    }
+
+    if (SaveMqueueName(mqName, mqueueCB) != LOS_OK) {
+        goto ERROUT;
+    }
+
+    if (GetMqueueCBByID(mqueueCB->mq_id, &(mqueueCB->mqcb)) != LOS_OK) {
+        errno = ENOSPC;
+        goto ERROUT;
+    }
+
+    mqueueCB->mq_personal = (struct mqpersonal *)LOS_MemAlloc(OS_SYS_MEM_ADDR, sizeof(struct mqpersonal));
+    if (mqueueCB->mq_personal == NULL) {
+        (VOID)LOS_QueueDelete(mqueueCB->mq_id);
+        mqueueCB->mqcb->queue = NULL;
+        mqueueCB->mqcb = NULL;
+        errno = ENOSPC;
+        goto ERROUT;
+    }
+
+    mqueueCB->unlinkflag = FALSE;
+    mqueueCB->mq_personal->mq_status = MQ_USE_MAGIC;
+    mqueueCB->mq_personal->mq_next = NULL;
+    mqueueCB->mq_personal->mq_posixdes = mqueueCB;
+    mqueueCB->mq_personal->mq_flags = (INT32)((UINT32)openFlag | ((UINT32)attr->mq_flags & (UINT32)FNONBLOCK));
+
+    return mqueueCB->mq_personal;
+ERROUT:
+
+    if ((mqueueCB != NULL) && (mqueueCB->mq_name != NULL)) {
+        LOS_MemFree(OS_SYS_MEM_ADDR, mqueueCB->mq_name);
+        mqueueCB->mq_name = NULL;
+    }
+    return (struct mqpersonal *)-1;
+}
+
+STATIC struct mqpersonal *DoMqueueOpen(struct mqarray *mqueueCB, INT32 openFlag)
+{
+    struct mqpersonal *privateMqPersonal = NULL;
+
+    /* already have the same name of g_squeuetable */
+    if (mqueueCB->unlinkflag == TRUE) {
+        errno = EINVAL;
+        goto ERROUT;
+    }
+    /* alloc mqprivate and add to mqarray */
+    privateMqPersonal = (struct mqpersonal *)LOS_MemAlloc(OS_SYS_MEM_ADDR, sizeof(struct mqpersonal));
+    if (privateMqPersonal == NULL) {
+        errno = ENOSPC;
+        goto ERROUT;
+    }
+
+    privateMqPersonal->mq_next = mqueueCB->mq_personal;
+    mqueueCB->mq_personal = privateMqPersonal;
+
+    privateMqPersonal->mq_posixdes = mqueueCB;
+    privateMqPersonal->mq_flags = openFlag;
+    privateMqPersonal->mq_status = MQ_USE_MAGIC;
+
+    return privateMqPersonal;
+
+ERROUT:
+    return (struct mqpersonal *)-1;
+}
+
+mqd_t mq_open(const char *mqName, int openFlag, ...)
+{
+    struct mqarray *mqueueCB = NULL;
+    struct mqpersonal *privateMqPersonal = (struct mqpersonal *)-1;
+    struct mq_attr *attr = NULL;
+    struct mq_attr defaultAttr = { 0, MQ_MAX_MSG_NUM, MQ_MAX_MSG_LEN, 0, {0} };
+
+    va_list ap;
+
+    if (MqNameCheck(mqName) == -1) {
+        return (mqd_t)-1;
+    }
+
+    (VOID)pthread_mutex_lock(&g_mqueueMutex);
+    mqueueCB = GetMqueueCBByName(mqName);
+    if ((UINT32)openFlag & (UINT32)O_CREAT) {
+        if (mqueueCB != NULL) {
+            if (((UINT32)openFlag & (UINT32)O_EXCL)) {
+                errno = EEXIST;
+                goto OUT;
+            }
+            privateMqPersonal = DoMqueueOpen(mqueueCB, openFlag);
+        } else {
+            va_start(ap, openFlag);
+            (VOID)va_arg(ap, int);
+            attr = va_arg(ap, struct mq_attr *);
+            va_end(ap);
+
+            if (attr != NULL) {
+                (VOID)memcpy_s(&defaultAttr, sizeof(struct mq_attr), attr, sizeof(struct mq_attr));
+                if ((defaultAttr.mq_maxmsg < 0) || (defaultAttr.mq_maxmsg > (long int)USHRT_MAX) ||
+                    (defaultAttr.mq_msgsize < 0) || (defaultAttr.mq_msgsize > (long int)(USHRT_MAX - sizeof(UINT32)))) {
+                    errno = EINVAL;
+                    goto OUT;
+                }
+            }
+            privateMqPersonal = DoMqueueCreate(&defaultAttr, mqName, openFlag);
+        }
+    } else {
+        if (mqueueCB == NULL) {
+            errno = ENOENT;
+            goto OUT;
+        }
+        privateMqPersonal = DoMqueueOpen(mqueueCB, openFlag);
+    }
+
+OUT:
+    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+    return (mqd_t)privateMqPersonal;
+}
+
+int mq_close(mqd_t personal)
+{
+    INT32 ret = 0;
+    struct mqarray *mqueueCB = NULL;
+    struct mqpersonal *privateMqPersonal = NULL;
+    struct mqpersonal *tmp = NULL;
+
+    (VOID)pthread_mutex_lock(&g_mqueueMutex);
+    privateMqPersonal = (struct mqpersonal *)personal;
+    if (privateMqPersonal->mq_status != MQ_USE_MAGIC) {
+        errno = EBADF;
+        goto OUT_UNLOCK;
+    }
+
+    mqueueCB = privateMqPersonal->mq_posixdes;
+    if (mqueueCB->mq_personal == NULL) {
+        errno = EBADF;
+        goto OUT_UNLOCK;
+    }
+
+    /* find the personal and remove */
+    if (mqueueCB->mq_personal == privateMqPersonal) {
+        mqueueCB->mq_personal = privateMqPersonal->mq_next;
+    } else {
+        for (tmp = mqueueCB->mq_personal; tmp->mq_next != NULL; tmp = tmp->mq_next) {
+            if (tmp->mq_next == privateMqPersonal) {
+                break;
+            }
+        }
+        if (tmp->mq_next == NULL) {
+            errno = EBADF;
+            goto OUT_UNLOCK;
+        }
+        tmp->mq_next = privateMqPersonal->mq_next;
+    }
+    /* flag no use */
+    privateMqPersonal->mq_status = 0;
+
+    /* free the personal */
+    ret = LOS_MemFree(OS_SYS_MEM_ADDR, privateMqPersonal);
+    if (ret != LOS_OK) {
+        errno = EFAULT;
+        ret = -1;
+        goto OUT_UNLOCK;
+    }
+
+    if ((mqueueCB->unlinkflag == TRUE) && (mqueueCB->mq_personal == NULL)) {
+        ret = DoMqueueDelete(mqueueCB);
+    }
+OUT_UNLOCK:
+    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+    return ret;
+}
+
+int OsMqGetAttr(mqd_t personal, struct mq_attr *mqAttr)
+{
+    struct mqarray *mqueueCB = NULL;
+    struct mqpersonal *privateMqPersonal = NULL;
+
+    if (mqAttr == NULL) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    (VOID)pthread_mutex_lock(&g_mqueueMutex);
+    privateMqPersonal = (struct mqpersonal *)personal;
+    if (privateMqPersonal->mq_status != MQ_USE_MAGIC) {
+        errno = EBADF;
+        (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+        return -1;
+    }
+
+    mqueueCB = privateMqPersonal->mq_posixdes;
+    mqAttr->mq_maxmsg = mqueueCB->mqcb->queueLen;
+    mqAttr->mq_msgsize = mqueueCB->mqcb->queueSize - sizeof(UINT32);
+    mqAttr->mq_curmsgs = mqueueCB->mqcb->readWriteableCnt[OS_QUEUE_READ];
+    mqAttr->mq_flags = privateMqPersonal->mq_flags;
+    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+    return 0;
+}
+
+int OsMqSetAttr(mqd_t personal, const struct mq_attr *mqSetAttr, struct mq_attr *mqOldAttr)
+{
+    struct mqpersonal *privateMqPersonal = NULL;
+
+    if (mqSetAttr == NULL) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    (VOID)pthread_mutex_lock(&g_mqueueMutex);
+    privateMqPersonal = (struct mqpersonal *)personal;
+    if (privateMqPersonal->mq_status != MQ_USE_MAGIC) {
+        errno = EBADF;
+        (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+        return -1;
+    }
+
+    if (mqOldAttr != NULL) {
+        (VOID)OsMqGetAttr((mqd_t)privateMqPersonal, mqOldAttr);
+    }
+
+    privateMqPersonal->mq_flags = (INT32)((UINT32)privateMqPersonal->mq_flags & (UINT32)(~FNONBLOCK)); /* clear */
+    if (((UINT32)mqSetAttr->mq_flags & (UINT32)FNONBLOCK) == (UINT32)FNONBLOCK) {
+        privateMqPersonal->mq_flags = (INT32)((UINT32)privateMqPersonal->mq_flags | (UINT32)FNONBLOCK);
+    }
+    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+    return 0;
+}
+
+int mq_getsetattr(mqd_t mqd, const struct mq_attr *new, struct mq_attr *old)
+{
+    if (new == NULL) {
+        return OsMqGetAttr(mqd, old);
+    }
+    return OsMqSetAttr(mqd, new, old);
+}
+
+int mq_getattr(mqd_t mqd, struct mq_attr *attr)
+{
+    return mq_getsetattr(mqd, 0, attr);
+}
+
+int mq_setattr(mqd_t mqd, const struct mq_attr *new, struct mq_attr *old)
+{
+    return mq_getsetattr(mqd, new, old);
+}
+
+int mq_unlink(const char *mqName)
+{
+    INT32 ret = 0;
+    struct mqarray *mqueueCB = NULL;
+
+    if (MqNameCheck(mqName) == -1) {
+        return -1;
+    }
+
+    (VOID)pthread_mutex_lock(&g_mqueueMutex);
+    mqueueCB = GetMqueueCBByName(mqName);
+    if (mqueueCB == NULL) {
+        errno = ENOENT;
+        goto ERROUT_UNLOCK;
+    }
+
+    if (mqueueCB->mq_personal != NULL) {
+        mqueueCB->unlinkflag = TRUE;
+    } else {
+        ret = DoMqueueDelete(mqueueCB);
+    }
+
+    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+    return ret;
+
+ERROUT_UNLOCK:
+    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+    return -1;
+}
+
+STATIC INT32 ConvertTimeout(long flags, const struct timespec *absTimeout, UINT64 *ticks)
+{
+    if ((UINT32)flags & (UINT32)FNONBLOCK) {
+        *ticks = LOS_NO_WAIT;
+        return 0;
+    }
+
+    if (absTimeout == NULL) {
+        *ticks = LOS_WAIT_FOREVER;
+        return 0;
+    }
+
+    if (!ValidTimeSpec(absTimeout)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    *ticks = OsTimeSpec2Tick(absTimeout);
+    return 0;
+}
+
+STATIC INLINE BOOL MqParamCheck(mqd_t personal, const char *msg, size_t msgLen)
+{
+    (void)personal;
+    if ((msg == NULL) || (msgLen == 0)) {
+        errno = EINVAL;
+        return FALSE;
+    }
+    return TRUE;
+}
+
+#define OS_MQ_GOTO_ERROUT_UNLOCK_IF(expr, errcode) \
+    if (expr) {                        \
+        errno = errcode;                 \
+        goto ERROUT_UNLOCK;                     \
+    }
+#define OS_MQ_GOTO_ERROUT_IF(expr, errcode) \
+    if (expr) {                        \
+        errno = errcode;                 \
+        goto ERROUT;                     \
+    }
+int mq_timedsend(mqd_t personal, const char *msg, size_t msgLen, unsigned int msgPrio,
+                 const struct timespec *absTimeout)
+{
+    UINT32 mqueueID, err;
+    UINT64 absTicks;
+    struct mqarray *mqueueCB = NULL;
+    struct mqpersonal *privateMqPersonal = NULL;
+
+    OS_MQ_GOTO_ERROUT_IF(!MqParamCheck(personal, msg, msgLen), errno);
+
+    OS_MQ_GOTO_ERROUT_IF(msgPrio > (MQ_PRIO_MAX - 1), EINVAL);
+
+    (VOID)pthread_mutex_lock(&g_mqueueMutex);
+    privateMqPersonal = (struct mqpersonal *)personal;
+    OS_MQ_GOTO_ERROUT_UNLOCK_IF(privateMqPersonal->mq_status != MQ_USE_MAGIC, EBADF);
+
+    mqueueCB = privateMqPersonal->mq_posixdes;
+    OS_MQ_GOTO_ERROUT_UNLOCK_IF(msgLen > (size_t)(mqueueCB->mqcb->queueSize - sizeof(UINT32)), EMSGSIZE);
+
+    OS_MQ_GOTO_ERROUT_UNLOCK_IF((((UINT32)privateMqPersonal->mq_flags & (UINT32)O_WRONLY) != (UINT32)O_WRONLY) &&
+                                (((UINT32)privateMqPersonal->mq_flags & (UINT32)O_RDWR) != (UINT32)O_RDWR),
+                                EBADF);
+
+    OS_MQ_GOTO_ERROUT_UNLOCK_IF(ConvertTimeout(privateMqPersonal->mq_flags, absTimeout, &absTicks) == -1, errno);
+    mqueueID = mqueueCB->mq_id;
+    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+
+    err = LOS_QueueWriteCopy(mqueueID, (VOID *)msg, (UINT32)msgLen, (UINT32)absTicks);
+    if (MapMqErrno(err) != ENOERR) {
+        goto ERROUT;
+    }
+    return 0;
+ERROUT_UNLOCK:
+    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+ERROUT:
+    return -1;
+}
+
+ssize_t mq_timedreceive(mqd_t personal, char *msg, size_t msgLen, unsigned int *msgPrio,
+                        const struct timespec *absTimeout)
+{
+    UINT32 mqueueID, err;
+    UINT32 receiveLen;
+    UINT64 absTicks;
+    struct mqarray *mqueueCB = NULL;
+    struct mqpersonal *privateMqPersonal = NULL;
+
+    if (!MqParamCheck(personal, msg, msgLen)) {
+        goto ERROUT;
+    }
+
+    if (msgPrio != NULL) {
+        *msgPrio = 0;
+    }
+
+    (VOID)pthread_mutex_lock(&g_mqueueMutex);
+    privateMqPersonal = (struct mqpersonal *)personal;
+    if (privateMqPersonal->mq_status != MQ_USE_MAGIC) {
+        errno = EBADF;
+        goto ERROUT_UNLOCK;
+    }
+
+    mqueueCB = privateMqPersonal->mq_posixdes;
+    if (msgLen < (size_t)(mqueueCB->mqcb->queueSize - sizeof(UINT32))) {
+        errno = EMSGSIZE;
+        goto ERROUT_UNLOCK;
+    }
+
+    if (((UINT32)privateMqPersonal->mq_flags & (UINT32)O_WRONLY) == (UINT32)O_WRONLY) {
+        errno = EBADF;
+        goto ERROUT_UNLOCK;
+    }
+
+    if (ConvertTimeout(privateMqPersonal->mq_flags, absTimeout, &absTicks) == -1) {
+        goto ERROUT_UNLOCK;
+    }
+
+    receiveLen = msgLen;
+    mqueueID = mqueueCB->mq_id;
+    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+
+    err = LOS_QueueReadCopy(mqueueID, (VOID *)msg, &receiveLen, (UINT32)absTicks);
+    if (MapMqErrno(err) == ENOERR) {
+        return (ssize_t)receiveLen;
+    } else {
+        goto ERROUT;
+    }
+
+ERROUT_UNLOCK:
+    (VOID)pthread_mutex_unlock(&g_mqueueMutex);
+ERROUT:
+    return -1;
+}
+
+/* not support the prio */
+int mq_send(mqd_t personal, const char *msg_ptr, size_t msg_len, unsigned int msg_prio)
+{
+    return mq_timedsend(personal, msg_ptr, msg_len, msg_prio, NULL);
+}
+
+ssize_t mq_receive(mqd_t personal, char *msg_ptr, size_t msg_len, unsigned int *msg_prio)
+{
+    return mq_timedreceive(personal, msg_ptr, msg_len, msg_prio, NULL);
+}
+
diff --git a/kernel/liteos_m/kal/posix/src/mqueue_impl.h b/kernel/liteos_m/kal/posix/src/mqueue_impl.h
index 3f824fd..670b814 100644
--- a/kernel/liteos_m/kal/posix/src/mqueue_impl.h
+++ b/kernel/liteos_m/kal/posix/src/mqueue_impl.h
@@ -1,145 +1,141 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _MQUEUE_IMPL_H
-#define _MQUEUE_IMPL_H
-
-#define _GNU_SOURCE
-
-#include <mqueue.h>
-#include <errno.h>
-#include <pthread.h>
-#include <unistd.h>
-#include <securec.h>
-#include <fcntl.h>
-#include <limits.h>
-#include <sys/select.h>
-#include "los_queue.h"
-#include "los_memory.h"
-#include "los_task.h"
-#include "los_compiler.h"
-
-#define OS_QUEUE_OPERATE_TYPE(ReadOrWrite, HeadOrTail, PointOrNot)  \
-                (((UINT32)(PointOrNot) << 2) | ((UINT32)(HeadOrTail) << 1) | (ReadOrWrite))
-#define OS_QUEUE_READ_WRITE_GET(type) ((type) & (0x01))
-#define OS_QUEUE_READ_HEAD     (OS_QUEUE_READ | (OS_QUEUE_HEAD << 1))
-#define OS_QUEUE_READ_TAIL     (OS_QUEUE_READ | (OS_QUEUE_TAIL << 1))
-#define OS_QUEUE_WRITE_HEAD    (OS_QUEUE_WRITE | (OS_QUEUE_HEAD << 1))
-#define OS_QUEUE_WRITE_TAIL    (OS_QUEUE_WRITE | (OS_QUEUE_TAIL << 1))
-#define OS_QUEUE_OPERATE_GET(type) ((type) & (0x03))
-#define OS_QUEUE_IS_POINT(type)    ((type) & (0x04))
-#define OS_QUEUE_IS_READ(type)     (OS_QUEUE_READ_WRITE_GET(type) == OS_QUEUE_READ)
-#define OS_QUEUE_IS_WRITE(type)    (OS_QUEUE_READ_WRITE_GET(type) == OS_QUEUE_WRITE)
-#define OS_READWRITE_LEN           2
-
-/**
- * @ingroup mqueue
- * Maximum number of messages in a message queue
- */
-#define MQ_MAX_MSG_NUM    16
-
-/**
- * @ingroup mqueue
- * Maximum size of a single message in a message queue
- */
-#define MQ_MAX_MSG_LEN    64
-
-#define ENOERR 0
-
-/* CONSTANTS */
-
-#define MQ_USE_MAGIC  0x89abcdef
-#define MQ_PRIO_MAX 1
-
-
-#define FNONBLOCK   O_NONBLOCK
-
-#define QUEUE_SPLIT_BIT        16
-
-#define SET_QUEUE_ID(count, queueID)    (((count) << QUEUE_SPLIT_BIT) | (queueID))
-
-/**
- * @ingroup los_queue
- * get the queue index
- */
-#define GET_QUEUE_INDEX(queueID)        ((queueID) & ((1U << QUEUE_SPLIT_BIT) - 1))
-
-/**
- * @ingroup los_queue
- * get the queue count
- */
-#define GET_QUEUE_COUNT(queueID)        ((queueID) >> QUEUE_SPLIT_BIT)
-
-
-/**
- * @ingroup los_queue
- * Obtain the head node in a queue doubly linked list.
- */
-#define GET_QUEUE_LIST(ptr) LOS_DL_LIST_ENTRY(ptr, LosQueueCB, readWriteList[OS_QUEUE_WRITE])
-
-#define STATIC static
-#define INLNIE inline
-
-typedef union send_receive_t {
-    unsigned oth : 3;
-    unsigned grp : 6;
-    unsigned usr : 9;
-    short data;
-} mode_s;
-
-/* TYPE DEFINITIONS */
-struct mqarray {
-    UINT32 mq_id : 31;
-    UINT32 unlinkflag : 1;
-    char *mq_name;
-    UINT32 unlink_ref;
-    mode_s mode_data; /* mode data of mqueue */
-    uid_t euid; /* euid of mqueue */
-    gid_t egid; /* egid of mqueue */
-    fd_set mq_fdset; /* mqueue sysFd bit map */
-    LosQueueCB *mqcb;
-    struct mqpersonal *mq_personal;
-};
-
-struct mqpersonal {
-    struct mqarray *mq_posixdes;
-    struct mqpersonal *mq_next;
-    int mq_flags;
-    int mq_mode;  /* Mode of mqueue */
-    UINT32 mq_status;
-    UINT32 mq_refcount;
-};
-#ifdef LOSCFG_BASE_IPC_QUEUE_LIMIT
-#undef LOSCFG_BASE_IPC_QUEUE_LIMIT
-#define LOSCFG_BASE_IPC_QUEUE_LIMIT 20
-#endif
-
-#endif
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _MQUEUE_IMPL_H
+#define _MQUEUE_IMPL_H
+
+#define _GNU_SOURCE
+
+#include <mqueue.h>
+#include <errno.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <securec.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <sys/select.h>
+#include "los_queue.h"
+#include "los_memory.h"
+#include "los_task.h"
+#include "los_compiler.h"
+
+#define OS_QUEUE_OPERATE_TYPE(ReadOrWrite, HeadOrTail, PointOrNot)  \
+                (((UINT32)(PointOrNot) << 2) | ((UINT32)(HeadOrTail) << 1) | (ReadOrWrite))
+#define OS_QUEUE_READ_WRITE_GET(type) ((type) & (0x01))
+#define OS_QUEUE_READ_HEAD     (OS_QUEUE_READ | (OS_QUEUE_HEAD << 1))
+#define OS_QUEUE_READ_TAIL     (OS_QUEUE_READ | (OS_QUEUE_TAIL << 1))
+#define OS_QUEUE_WRITE_HEAD    (OS_QUEUE_WRITE | (OS_QUEUE_HEAD << 1))
+#define OS_QUEUE_WRITE_TAIL    (OS_QUEUE_WRITE | (OS_QUEUE_TAIL << 1))
+#define OS_QUEUE_OPERATE_GET(type) ((type) & (0x03))
+#define OS_QUEUE_IS_POINT(type)    ((type) & (0x04))
+#define OS_QUEUE_IS_READ(type)     (OS_QUEUE_READ_WRITE_GET(type) == OS_QUEUE_READ)
+#define OS_QUEUE_IS_WRITE(type)    (OS_QUEUE_READ_WRITE_GET(type) == OS_QUEUE_WRITE)
+#define OS_READWRITE_LEN           2
+
+/**
+ * @ingroup mqueue
+ * Maximum number of messages in a message queue
+ */
+#define MQ_MAX_MSG_NUM    16
+
+/**
+ * @ingroup mqueue
+ * Maximum size of a single message in a message queue
+ */
+#define MQ_MAX_MSG_LEN    64
+
+#define ENOERR 0
+
+/* CONSTANTS */
+
+#define MQ_USE_MAGIC  0x89abcdef
+#define MQ_PRIO_MAX 1
+
+
+#define FNONBLOCK   O_NONBLOCK
+
+#define QUEUE_SPLIT_BIT        16
+
+#define SET_QUEUE_ID(count, queueID)    (((count) << QUEUE_SPLIT_BIT) | (queueID))
+
+/**
+ * @ingroup los_queue
+ * get the queue index
+ */
+#define GET_QUEUE_INDEX(queueID)        ((queueID) & ((1U << QUEUE_SPLIT_BIT) - 1))
+
+/**
+ * @ingroup los_queue
+ * get the queue count
+ */
+#define GET_QUEUE_COUNT(queueID)        ((queueID) >> QUEUE_SPLIT_BIT)
+
+
+/**
+ * @ingroup los_queue
+ * Obtain the head node in a queue doubly linked list.
+ */
+#define GET_QUEUE_LIST(ptr) LOS_DL_LIST_ENTRY(ptr, LosQueueCB, readWriteList[OS_QUEUE_WRITE])
+
+#define STATIC static
+#define INLINE inline
+
+typedef union send_receive_t {
+    unsigned oth : 3;
+    unsigned grp : 6;
+    unsigned usr : 9;
+    short data;
+} mode_s;
+
+/* TYPE DEFINITIONS */
+struct mqarray {
+    UINT32 mq_id : 31;
+    UINT32 unlinkflag : 1;
+    char *mq_name;
+    UINT32 unlink_ref;
+    mode_s mode_data; /* mode data of mqueue */
+    uid_t euid; /* euid of mqueue */
+    gid_t egid; /* egid of mqueue */
+    fd_set mq_fdset; /* mqueue sysFd bit map */
+    LosQueueCB *mqcb;
+    struct mqpersonal *mq_personal;
+};
+
+struct mqpersonal {
+    struct mqarray *mq_posixdes;
+    struct mqpersonal *mq_next;
+    int mq_flags;
+    int mq_mode;  /* Mode of mqueue */
+    UINT32 mq_status;
+    UINT32 mq_refcount;
+};
+
+#endif
diff --git a/kernel/liteos_m/kal/posix/src/pthread.c b/kernel/liteos_m/kal/posix/src/pthread.c
index a7e8893..333767f 100644
--- a/kernel/liteos_m/kal/posix/src/pthread.c
+++ b/kernel/liteos_m/kal/posix/src/pthread.c
@@ -1,232 +1,234 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "pthread.h"
-#include <errno.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <securec.h>
-#include "los_config.h"
-#include "los_task.h"
-
-#define PTHREAD_NAMELEN 16
-
-typedef struct {
-    void *(*startRoutine)(void *);
-    void *param;
-    char name[PTHREAD_NAMELEN];
-}PthreadData;
-
-static void *PthreadEntry(UINT32 param)
-{
-    PthreadData *pthreadData = (PthreadData *)(UINTPTR)param;
-    void *(*startRoutine)(void *) = pthreadData->startRoutine;
-    void *ret = startRoutine(pthreadData->param);
-    free(pthreadData);
-    return ret;
-}
-
-static inline int IsPthread(pthread_t thread)
-{
-    return ((UINT32)thread <= LOSCFG_BASE_CORE_TSK_LIMIT) &&
-           (OS_TCB_FROM_TID((UINT32)thread)->taskEntry == PthreadEntry);
-}
-
-int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
-                   void *(*startRoutine)(void *), void *arg)
-{
-    TSK_INIT_PARAM_S taskInitParam = {0};
-    PthreadData *pthreadData = NULL;
-    UINT32 taskID;
-
-    if ((thread == NULL) || (startRoutine == NULL)) {
-        return EINVAL;
-    }
-
-    taskInitParam.usTaskPrio = LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO;
-    taskInitParam.uwStackSize = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
-    if (attr) {
-        if (attr->detachstate == PTHREAD_CREATE_DETACHED) {
-            return ENOTSUP;
-        }
-        if (attr->stackaddr_set) {
-            return ENOTSUP;
-        }
-        if (attr->stacksize_set) {
-            taskInitParam.uwStackSize = attr->stacksize;
-        }
-        taskInitParam.usTaskPrio = (UINT16)attr->schedparam.sched_priority;
-    }
-
-    pthreadData = (PthreadData *)malloc(sizeof(PthreadData));
-    if (pthreadData == NULL) {
-        return ENOMEM;
-    }
-
-    pthreadData->startRoutine  = startRoutine;
-    pthreadData->param         = arg;
-    taskInitParam.pcName       = pthreadData->name;
-    taskInitParam.pfnTaskEntry = PthreadEntry;
-    taskInitParam.uwArg   = (UINT32)(UINTPTR)pthreadData;
-
-    if (LOS_TaskCreate(&taskID, &taskInitParam) != LOS_OK) {
-        free(pthreadData);
-        return EINVAL;
-    }
-
-    /* set pthread default name */
-    (void)sprintf_s(taskInitParam.pcName, PTHREAD_NAMELEN, "pthread%u", taskID);
-
-    *thread = (pthread_t)taskID;
-    return 0;
-}
-
-int pthread_setschedparam(pthread_t thread, int policy, const struct sched_param *param)
-{
-    if ((param == NULL) || (param->sched_priority < OS_TASK_PRIORITY_HIGHEST) ||
-        (param->sched_priority >= OS_TASK_PRIORITY_LOWEST) || !IsPthread(thread)) {
-        return EINVAL;
-    }
-
-    /* Only support SCHED_RR policy now */
-    if (policy != SCHED_RR) {
-        return ENOTSUP;
-    }
-
-    if (LOS_TaskPriSet((UINT32)thread, (UINT16)param->sched_priority) != LOS_OK) {
-        return EINVAL;
-    }
-
-    return 0;
-}
-
-int pthread_getschedparam(pthread_t thread, int *policy, struct sched_param *param)
-{
-    UINT32 prio;
-
-    if ((policy == NULL) || (param == NULL) || !IsPthread(thread)) {
-        return EINVAL;
-    }
-
-    prio = LOS_TaskPriGet((UINT32)thread);
-    if (prio == OS_INVALID) {
-        return EINVAL;
-    }
-
-    *policy = SCHED_RR;
-    param->sched_priority = prio;
-    return 0;
-}
-
-pthread_t pthread_self(void)
-{
-    return (pthread_t)LOS_CurTaskIDGet();
-}
-
-int pthread_cancel(pthread_t thread)
-{
-    if (!IsPthread(thread)) {
-        return EINVAL;
-    }
-
-    return ENOSYS;
-}
-
-int pthread_join(pthread_t thread, void **retval)
-{
-    UINT32 taskStatus;
-
-    if (!IsPthread(thread)) {
-        return EINVAL;
-    }
-
-    if (retval) {
-        /* retrieve thread exit code is not supported currently */
-        return ENOTSUP;
-    }
-
-    if (thread == pthread_self()) {
-        return EDEADLK;
-    }
-
-    while (LOS_TaskStatusGet((UINT32)thread, &taskStatus) == LOS_OK) {
-        (void)LOS_TaskDelay(10); /* 10: Waiting for the end of thread execution. */
-    }
-
-    return 0;
-}
-
-int pthread_detach(pthread_t thread)
-{
-    if (!IsPthread(thread)) {
-        return EINVAL;
-    }
-
-    return ENOSYS;
-}
-
-void pthread_exit(void *retVal)
-{
-    (void)retVal;
-    LosTaskCB *tcb = OS_TCB_FROM_TID(LOS_CurTaskIDGet());
-    free((PthreadData *)(UINTPTR)tcb->arg);
-    (void)LOS_TaskDelete(LOS_CurTaskIDGet());
-}
-
-int pthread_setname_np(pthread_t thread, const char *name)
-{
-    char *taskName = LOS_TaskNameGet((UINT32)thread);
-    if (taskName == NULL || !IsPthread(thread)) {
-        return EINVAL;
-    }
-    if (strnlen(name, PTHREAD_NAMELEN) >= PTHREAD_NAMELEN) {
-        return ERANGE;
-    }
-    (void)strcpy_s(taskName, PTHREAD_NAMELEN, name);
-    return 0;
-}
-
-int pthread_getname_np(pthread_t thread, char *buf, size_t buflen)
-{
-    int ret;
-
-    const char *name = LOS_TaskNameGet((UINT32)thread);
-    if (name == NULL || !IsPthread(thread)) {
-        return EINVAL;
-    }
-    if (buflen > strlen(name)) {
-        ret = strcpy_s(buf, buflen, name);
-        if (ret == 0) {
-            return 0;
-        }
-    }
-    return ERANGE;
-}
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "pthread.h"
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <securec.h>
+#include "los_config.h"
+#include "los_task.h"
+
+#define PTHREAD_NAMELEN 16
+
+typedef struct {
+    void *(*startRoutine)(void *);
+    void *param;
+    char name[PTHREAD_NAMELEN];
+}PthreadData;
+
+static void *PthreadEntry(UINT32 param)
+{
+    PthreadData *pthreadData = (PthreadData *)(UINTPTR)param;
+    void *(*startRoutine)(void *) = pthreadData->startRoutine;
+    void *ret = startRoutine(pthreadData->param);
+    free(pthreadData);
+    return ret;
+}
+
+static inline int IsPthread(pthread_t thread)
+{
+    return ((UINT32)thread <= LOSCFG_BASE_CORE_TSK_LIMIT) &&
+           (OS_TCB_FROM_TID((UINT32)thread)->taskEntry == PthreadEntry);
+}
+
+int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
+                   void *(*startRoutine)(void *), void *arg)
+{
+    TSK_INIT_PARAM_S taskInitParam = {0};
+    PthreadData *pthreadData = NULL;
+    UINT32 taskID;
+
+    if ((thread == NULL) || (startRoutine == NULL)) {
+        return EINVAL;
+    }
+
+    taskInitParam.usTaskPrio = LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO;
+    taskInitParam.uwStackSize = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
+    if (attr) {
+        if (attr->detachstate == PTHREAD_CREATE_DETACHED) {
+            return ENOTSUP;
+        }
+        if (attr->stackaddr_set) {
+            return ENOTSUP;
+        }
+        if (attr->stacksize_set) {
+            taskInitParam.uwStackSize = attr->stacksize;
+        }
+        taskInitParam.usTaskPrio = (UINT16)attr->schedparam.sched_priority;
+    }
+
+    pthreadData = (PthreadData *)malloc(sizeof(PthreadData));
+    if (pthreadData == NULL) {
+        return ENOMEM;
+    }
+
+    pthreadData->startRoutine  = startRoutine;
+    pthreadData->param         = arg;
+    taskInitParam.pcName       = pthreadData->name;
+    taskInitParam.pfnTaskEntry = PthreadEntry;
+    taskInitParam.uwArg   = (UINT32)(UINTPTR)pthreadData;
+
+    if (LOS_TaskCreateOnly(&taskID, &taskInitParam) != LOS_OK) {
+        free(pthreadData);
+        return EINVAL;
+    }
+
+    /* set pthread default name */
+    (void)sprintf_s(taskInitParam.pcName, PTHREAD_NAMELEN, "pthread%u", taskID);
+
+    (void)LOS_TaskResume(taskID);
+
+    *thread = (pthread_t)taskID;
+    return 0;
+}
+
+int pthread_setschedparam(pthread_t thread, int policy, const struct sched_param *param)
+{
+    if ((param == NULL) || (param->sched_priority < OS_TASK_PRIORITY_HIGHEST) ||
+        (param->sched_priority >= OS_TASK_PRIORITY_LOWEST) || !IsPthread(thread)) {
+        return EINVAL;
+    }
+
+    /* Only support SCHED_RR policy now */
+    if (policy != SCHED_RR) {
+        return ENOTSUP;
+    }
+
+    if (LOS_TaskPriSet((UINT32)thread, (UINT16)param->sched_priority) != LOS_OK) {
+        return EINVAL;
+    }
+
+    return 0;
+}
+
+int pthread_getschedparam(pthread_t thread, int *policy, struct sched_param *param)
+{
+    UINT32 prio;
+
+    if ((policy == NULL) || (param == NULL) || !IsPthread(thread)) {
+        return EINVAL;
+    }
+
+    prio = LOS_TaskPriGet((UINT32)thread);
+    if (prio == OS_INVALID) {
+        return EINVAL;
+    }
+
+    *policy = SCHED_RR;
+    param->sched_priority = prio;
+    return 0;
+}
+
+pthread_t pthread_self(void)
+{
+    return (pthread_t)LOS_CurTaskIDGet();
+}
+
+int pthread_cancel(pthread_t thread)
+{
+    if (!IsPthread(thread)) {
+        return EINVAL;
+    }
+
+    return ENOSYS;
+}
+
+int pthread_join(pthread_t thread, void **retval)
+{
+    UINT32 taskStatus;
+
+    if (!IsPthread(thread)) {
+        return EINVAL;
+    }
+
+    if (retval) {
+        /* retrieve thread exit code is not supported currently */
+        return ENOTSUP;
+    }
+
+    if (thread == pthread_self()) {
+        return EDEADLK;
+    }
+
+    while (LOS_TaskStatusGet((UINT32)thread, &taskStatus) == LOS_OK) {
+        (void)LOS_TaskDelay(10); /* 10: Waiting for the end of thread execution. */
+    }
+
+    return 0;
+}
+
+int pthread_detach(pthread_t thread)
+{
+    if (!IsPthread(thread)) {
+        return EINVAL;
+    }
+
+    return ENOSYS;
+}
+
+void pthread_exit(void *retVal)
+{
+    (void)retVal;
+    LosTaskCB *tcb = OS_TCB_FROM_TID(LOS_CurTaskIDGet());
+    free((PthreadData *)(UINTPTR)tcb->arg);
+    (void)LOS_TaskDelete(LOS_CurTaskIDGet());
+}
+
+int pthread_setname_np(pthread_t thread, const char *name)
+{
+    char *taskName = LOS_TaskNameGet((UINT32)thread);
+    if (taskName == NULL || !IsPthread(thread)) {
+        return EINVAL;
+    }
+    if (strnlen(name, PTHREAD_NAMELEN) >= PTHREAD_NAMELEN) {
+        return ERANGE;
+    }
+    (void)strcpy_s(taskName, PTHREAD_NAMELEN, name);
+    return 0;
+}
+
+int pthread_getname_np(pthread_t thread, char *buf, size_t buflen)
+{
+    int ret;
+
+    const char *name = LOS_TaskNameGet((UINT32)thread);
+    if (name == NULL || !IsPthread(thread)) {
+        return EINVAL;
+    }
+    if (buflen > strlen(name)) {
+        ret = strcpy_s(buf, buflen, name);
+        if (ret == 0) {
+            return 0;
+        }
+    }
+    return ERANGE;
+}
diff --git a/kernel/liteos_m/kal/posix/src/pthread_attr.c b/kernel/liteos_m/kal/posix/src/pthread_attr.c
index d5e6d7b..ff2e947 100644
--- a/kernel/liteos_m/kal/posix/src/pthread_attr.c
+++ b/kernel/liteos_m/kal/posix/src/pthread_attr.c
@@ -1,233 +1,253 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "pthread.h"
-#include <errno.h>
-#include <limits.h>
-#include "los_config.h"
-
-int pthread_attr_init(pthread_attr_t *attr)
-{
-    if (attr == NULL) {
-        return EINVAL;
-    }
-
-    attr->detachstate                 = PTHREAD_CREATE_JOINABLE;
-    attr->schedpolicy                 = SCHED_RR;
-    attr->schedparam.sched_priority   = LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO;
-    attr->inheritsched                = PTHREAD_INHERIT_SCHED;
-    attr->scope                       = PTHREAD_SCOPE_PROCESS;
-    attr->stackaddr_set               = 0;
-    attr->stackaddr                   = NULL;
-    attr->stacksize_set               = 1;
-    attr->stacksize                   = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
-
-    return 0;
-}
-
-int pthread_attr_destroy(pthread_attr_t *attr)
-{
-    if (attr == NULL) {
-        return EINVAL;
-    }
-
-    /* Nothing to do here... */
-    return 0;
-}
-
-int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachState)
-{
-    if ((attr != NULL) && ((detachState == PTHREAD_CREATE_JOINABLE) || (detachState == PTHREAD_CREATE_DETACHED))) {
-        attr->detachstate = (UINT32)detachState;
-        return 0;
-    }
-
-    return EINVAL;
-}
-
-int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachState)
-{
-    if ((attr == NULL) || (detachState == NULL)) {
-        return EINVAL;
-    }
-
-    *detachState = (int)attr->detachstate;
-
-    return 0;
-}
-
-int pthread_attr_setscope(pthread_attr_t *attr, int scope)
-{
-    if (attr == NULL) {
-        return EINVAL;
-    }
-
-    if (scope == PTHREAD_SCOPE_PROCESS) {
-        attr->scope = (unsigned int)scope;
-        return 0;
-    }
-
-    if (scope == PTHREAD_SCOPE_SYSTEM) {
-        return ENOTSUP;
-    }
-
-    return EINVAL;
-}
-
-int pthread_attr_getscope(const pthread_attr_t *attr, int *scope)
-{
-    if ((attr == NULL) || (scope == NULL)) {
-        return EINVAL;
-    }
-
-    *scope = (int)attr->scope;
-
-    return 0;
-}
-
-int pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit)
-{
-    if ((attr != NULL) && ((inherit == PTHREAD_INHERIT_SCHED) || (inherit == PTHREAD_EXPLICIT_SCHED))) {
-        attr->inheritsched = (UINT32)inherit;
-        return 0;
-    }
-
-    return EINVAL;
-}
-
-int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit)
-{
-    if ((attr == NULL) || (inherit == NULL)) {
-        return EINVAL;
-    }
-
-    *inherit = (int)attr->inheritsched;
-
-    return 0;
-}
-
-int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
-{
-    if ((attr != NULL) && (policy == SCHED_RR)) {
-        attr->schedpolicy = SCHED_RR;
-        return 0;
-    }
-
-    return EINVAL;
-}
-
-int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
-{
-    if ((attr == NULL) || (policy == NULL)) {
-        return EINVAL;
-    }
-
-    *policy = (int)attr->schedpolicy;
-
-    return 0;
-}
-
-int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param)
-{
-    if ((attr == NULL) || (param == NULL)) {
-        return EINVAL;
-    } else if ((param->sched_priority < LOS_TASK_PRIORITY_HIGHEST) ||
-               (param->sched_priority >= LOS_TASK_PRIORITY_LOWEST)) {
-        return ENOTSUP;
-    }
-
-    attr->schedparam = *param;
-
-    return 0;
-}
-
-int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param)
-{
-    if ((attr == NULL) || (param == NULL)) {
-        return EINVAL;
-    }
-
-    *param = attr->schedparam;
-
-    return 0;
-}
-
-/*
- * Set starting address of stack. Whether this is at the start or end of
- * the memory block allocated for the stack depends on whether the stack
- * grows up or down.
- */
-int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackAddr)
-{
-    if (attr == NULL) {
-        return EINVAL;
-    }
-
-    attr->stackaddr_set = 1;
-    attr->stackaddr     = stackAddr;
-
-    return 0;
-}
-
-int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackAddr)
-{
-    if (((attr != NULL) && (stackAddr != NULL)) && attr->stackaddr_set) {
-        *stackAddr = attr->stackaddr;
-        return 0;
-    }
-
-    return EINVAL; /* Stack address not set, return EINVAL. */
-}
-
-int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stackSize)
-{
-    /* Reject inadequate stack sizes */
-    if ((attr == NULL) || (stackSize < PTHREAD_STACK_MIN)) {
-        return EINVAL;
-    }
-
-    attr->stacksize_set = 1;
-    attr->stacksize     = stackSize;
-
-    return 0;
-}
-
-int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stackSize)
-{
-    /* Reject attempts to get a stack size when one has not been set. */
-    if ((attr == NULL) || (stackSize == NULL) || (!attr->stacksize_set)) {
-        return EINVAL;
-    }
-
-    *stackSize = attr->stacksize;
-
-    return 0;
-}
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "pthread.h"
+#include <errno.h>
+#include <limits.h>
+#include "los_config.h"
+
+int pthread_attr_init(pthread_attr_t *attr)
+{
+    if (attr == NULL) {
+        return EINVAL;
+    }
+
+    attr->detachstate                 = PTHREAD_CREATE_JOINABLE;
+    attr->schedpolicy                 = SCHED_RR;
+    attr->schedparam.sched_priority   = LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO;
+    attr->inheritsched                = PTHREAD_INHERIT_SCHED;
+    attr->scope                       = PTHREAD_SCOPE_PROCESS;
+    attr->stackaddr_set               = 0;
+    attr->stackaddr                   = NULL;
+    attr->stacksize_set               = 1;
+    attr->stacksize                   = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
+
+    return 0;
+}
+
+int pthread_attr_destroy(pthread_attr_t *attr)
+{
+    if (attr == NULL) {
+        return EINVAL;
+    }
+
+    /* Nothing to do here... */
+    return 0;
+}
+
+int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachState)
+{
+    if ((attr != NULL) && ((detachState == PTHREAD_CREATE_JOINABLE) || (detachState == PTHREAD_CREATE_DETACHED))) {
+        attr->detachstate = (UINT32)detachState;
+        return 0;
+    }
+
+    return EINVAL;
+}
+
+int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachState)
+{
+    if ((attr == NULL) || (detachState == NULL)) {
+        return EINVAL;
+    }
+
+    *detachState = (int)attr->detachstate;
+
+    return 0;
+}
+
+int pthread_attr_setscope(pthread_attr_t *attr, int scope)
+{
+    if (attr == NULL) {
+        return EINVAL;
+    }
+
+    if (scope == PTHREAD_SCOPE_PROCESS) {
+        attr->scope = (unsigned int)scope;
+        return 0;
+    }
+
+    if (scope == PTHREAD_SCOPE_SYSTEM) {
+        return ENOTSUP;
+    }
+
+    return EINVAL;
+}
+
+int pthread_attr_getscope(const pthread_attr_t *attr, int *scope)
+{
+    if ((attr == NULL) || (scope == NULL)) {
+        return EINVAL;
+    }
+
+    *scope = (int)attr->scope;
+
+    return 0;
+}
+
+int pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit)
+{
+    if ((attr != NULL) && ((inherit == PTHREAD_INHERIT_SCHED) || (inherit == PTHREAD_EXPLICIT_SCHED))) {
+        attr->inheritsched = (UINT32)inherit;
+        return 0;
+    }
+
+    return EINVAL;
+}
+
+int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit)
+{
+    if ((attr == NULL) || (inherit == NULL)) {
+        return EINVAL;
+    }
+
+    *inherit = (int)attr->inheritsched;
+
+    return 0;
+}
+
+int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
+{
+    if ((attr != NULL) && (policy == SCHED_RR)) {
+        attr->schedpolicy = SCHED_RR;
+        return 0;
+    }
+
+    return EINVAL;
+}
+
+int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
+{
+    if ((attr == NULL) || (policy == NULL)) {
+        return EINVAL;
+    }
+
+    *policy = (int)attr->schedpolicy;
+
+    return 0;
+}
+
+int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param)
+{
+    if ((attr == NULL) || (param == NULL)) {
+        return EINVAL;
+    } else if ((param->sched_priority < LOS_TASK_PRIORITY_HIGHEST) ||
+               (param->sched_priority >= LOS_TASK_PRIORITY_LOWEST)) {
+        return ENOTSUP;
+    }
+
+    attr->schedparam = *param;
+
+    return 0;
+}
+
+int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param)
+{
+    if ((attr == NULL) || (param == NULL)) {
+        return EINVAL;
+    }
+
+    *param = attr->schedparam;
+
+    return 0;
+}
+
+/*
+ * Set starting address of stack. Whether this is at the start or end of
+ * the memory block allocated for the stack depends on whether the stack
+ * grows up or down.
+ */
+int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackAddr)
+{
+    if (attr == NULL) {
+        return EINVAL;
+    }
+
+    attr->stackaddr_set = 1;
+    attr->stackaddr     = stackAddr;
+
+    return 0;
+}
+
+int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackAddr)
+{
+    if (((attr != NULL) && (stackAddr != NULL)) && attr->stackaddr_set) {
+        *stackAddr = attr->stackaddr;
+        return 0;
+    }
+
+    return EINVAL; /* Stack address not set, return EINVAL. */
+}
+
+int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stackSize)
+{
+    /* Reject inadequate stack sizes */
+    if ((attr == NULL) || (stackSize < PTHREAD_STACK_MIN)) {
+        return EINVAL;
+    }
+
+    attr->stacksize_set = 1;
+    attr->stacksize     = stackSize;
+
+    return 0;
+}
+
+int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stackSize)
+{
+    /* Reject attempts to get a stack size when one has not been set. */
+    if ((attr == NULL) || (stackSize == NULL) || (!attr->stacksize_set)) {
+        return EINVAL;
+    }
+
+    *stackSize = attr->stacksize;
+
+    return 0;
+}
+
+int sched_get_priority_min(int policy)
+{
+    if (policy != SCHED_RR) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    return LOS_TASK_PRIORITY_LOWEST;
+}
+
+int sched_get_priority_max(int policy)
+{
+    if (policy != SCHED_RR) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    return LOS_TASK_PRIORITY_HIGHEST;
+}
diff --git a/kernel/liteos_m/kal/posix/src/pthread_cond.c b/kernel/liteos_m/kal/posix/src/pthread_cond.c
index 9c89a68..c07ded9 100644
--- a/kernel/liteos_m/kal/posix/src/pthread_cond.c
+++ b/kernel/liteos_m/kal/posix/src/pthread_cond.c
@@ -1,288 +1,288 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "time_internal.h"
-#include <errno.h>
-#include <pthread.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <securec.h>
-#include "los_config.h"
-#include "los_task.h"
-#include <los_swtmr.h>
-#include "los_atomic.h"
-#include "los_event.h"
-
-typedef struct {
-    volatile INT32 *realValue;
-    INT32 value;
-    UINT32 clearEvent;
-} EventCond;
-
-#define INLNIE inline
-
-#define BROADCAST_EVENT     1
-#define COND_COUNTER_STEP   0x0004U
-#define COND_FLAGS_MASK     0x0003U
-#define COND_COUNTER_MASK   (~COND_FLAGS_MASK)
-
-int pthread_condattr_destroy(pthread_condattr_t *attr)
-{
-    if (attr == NULL) {
-        return EINVAL;
-    }
-
-    return 0;
-}
-
-int pthread_condattr_init(pthread_condattr_t *attr)
-{
-    if (attr == NULL) {
-        return EINVAL;
-    }
-
-    return 0;
-}
-
-STATIC INLINE INT32 CondInitCheck(const pthread_cond_t *cond)
-{
-    if ((cond->event.stEventList.pstPrev == NULL) &&
-        (cond->event.stEventList.pstNext == NULL)) {
-        return 1;
-    }
-    return 0;
-}
-
-int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr)
-{
-    int ret = ENOERR;
-
-    if (cond == NULL) {
-        return EINVAL;
-    }
-    (VOID)attr;
-    (VOID)LOS_EventInit(&(cond->event));
-
-    cond->mutex = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t));
-    if (cond->mutex == NULL) {
-        return ENOMEM;
-    }
-
-    (VOID)pthread_mutex_init(cond->mutex, NULL);
-
-    cond->value = 0;
-    (VOID)pthread_mutex_lock(cond->mutex);
-    cond->count = 0;
-    (VOID)pthread_mutex_unlock(cond->mutex);
-
-    return ret;
-}
-
-int pthread_cond_destroy(pthread_cond_t *cond)
-{
-    if (cond == NULL) {
-        return EINVAL;
-    }
-
-    if (CondInitCheck(cond)) {
-        return ENOERR;
-    }
-
-    if (LOS_EventDestroy(&cond->event) != LOS_OK) {
-        return EBUSY;
-    }
-    if (pthread_mutex_destroy(cond->mutex) != ENOERR) {
-        PRINT_ERR("%s mutex destroy fail!\n", __FUNCTION__);
-        return EINVAL;
-    }
-    free(cond->mutex);
-    cond->mutex = NULL;
-    return ENOERR;
-}
-
-STATIC VOID PthreadCountSub(pthread_cond_t *cond)
-{
-    (VOID)pthread_mutex_lock(cond->mutex);
-    if (cond->count > 0) {
-        cond->count--;
-    }
-    (VOID)pthread_mutex_unlock(cond->mutex);
-}
-
-
-int pthread_cond_broadcast(pthread_cond_t *cond)
-{
-    int ret = ENOERR;
-
-    if (cond == NULL) {
-        return EINVAL;
-    }
-
-    (VOID)pthread_mutex_lock(cond->mutex);
-    if (cond->count > 0) {
-        cond->count = 0;
-        (VOID)pthread_mutex_unlock(cond->mutex);
-        (VOID)LOS_EventWrite(&(cond->event), BROADCAST_EVENT);
-        return ret;
-    }
-    (VOID)pthread_mutex_unlock(cond->mutex);
-
-    return ret;
-}
-
-int pthread_cond_signal(pthread_cond_t *cond)
-{
-    int ret = ENOERR;
-
-    if (cond == NULL) {
-        return EINVAL;
-    }
-
-    (VOID)pthread_mutex_lock(cond->mutex);
-    if (cond->count > 0) {
-        cond->count--;
-        (VOID)pthread_mutex_unlock(cond->mutex);
-        // This should modify to once.
-        (VOID)LOS_EventWrite(&(cond->event), BROADCAST_EVENT);
-
-        return ret;
-    }
-    (VOID)pthread_mutex_unlock(cond->mutex);
-
-    return ret;
-}
-
-STATIC INT32 ProcessReturnVal(pthread_cond_t *cond, INT32 val)
-{
-    INT32 ret;
-    switch (val) {
-        /* 0: event does not occur */
-        case 0:
-        case BROADCAST_EVENT:
-            ret = ENOERR;
-            break;
-        case LOS_ERRNO_EVENT_READ_TIMEOUT:
-            PthreadCountSub(cond);
-            ret = ETIMEDOUT;
-            break;
-        default:
-            PthreadCountSub(cond);
-            ret = EINVAL;
-            break;
-    }
-    return ret;
-}
-
-int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
-                           const struct timespec *absTime)
-{
-    UINT32 absTicks;
-    INT32 ret;
-
-    if ((cond == NULL) || (mutex == NULL) || (absTime == NULL)) {
-        return EINVAL;
-    }
-
-    if (CondInitCheck(cond)) {
-        ret = pthread_cond_init(cond, NULL);
-        if (ret != ENOERR) {
-            return ret;
-        }
-    }
-
-    (VOID)pthread_mutex_lock(cond->mutex);
-    cond->count++;
-    (VOID)pthread_mutex_unlock(cond->mutex);
-
-    if ((absTime->tv_sec == 0) && (absTime->tv_nsec == 0)) {
-        return ETIMEDOUT;
-    }
-
-    if (!ValidTimeSpec(absTime)) {
-        return EINVAL;
-    }
-
-    absTicks = OsTimeSpec2Tick(absTime);
-    if (pthread_mutex_unlock(mutex) != ENOERR) {
-        PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
-    }
-
-    ret = (INT32)LOS_EventRead(&(cond->event), 0x0f, LOS_WAITMODE_OR | LOS_WAITMODE_CLR, absTicks);
-
-    if (pthread_mutex_lock(mutex) != ENOERR) {
-        PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
-    }
-
-    ret = ProcessReturnVal(cond, ret);
-    return ret;
-}
-
-int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
-{
-    int ret;
-
-    if ((cond == NULL) || (mutex == NULL)) {
-        return EINVAL;
-    }
-
-    if (CondInitCheck(cond)) {
-        ret = pthread_cond_init(cond, NULL);
-        if (ret != ENOERR) {
-            return ret;
-        }
-    }
-
-    (VOID)pthread_mutex_lock(cond->mutex);
-    cond->count++;
-    (VOID)pthread_mutex_unlock(cond->mutex);
-
-    if (pthread_mutex_unlock(mutex) != ENOERR) {
-        PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
-    }
-    ret = (INT32)LOS_EventRead(&(cond->event), 0x0f, LOS_WAITMODE_OR | LOS_WAITMODE_CLR, LOS_WAIT_FOREVER);
-    if (pthread_mutex_lock(mutex) != ENOERR) {
-        PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
-    }
-
-    switch (ret) {
-        /* 0: event does not occur */
-        case 0:
-        case BROADCAST_EVENT:
-            ret = ENOERR;
-            break;
-        default:
-            PthreadCountSub(cond);
-            ret = EINVAL;
-            break;
-    }
-
-    return ret;
-}
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "time_internal.h"
+#include <errno.h>
+#include <pthread.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <securec.h>
+#include "los_config.h"
+#include "los_task.h"
+#include <los_swtmr.h>
+#include "los_atomic.h"
+#include "los_event.h"
+
+typedef struct {
+    volatile INT32 *realValue;
+    INT32 value;
+    UINT32 clearEvent;
+} EventCond;
+
+#define INLINE inline
+
+#define BROADCAST_EVENT     1
+#define COND_COUNTER_STEP   0x0004U
+#define COND_FLAGS_MASK     0x0003U
+#define COND_COUNTER_MASK   (~COND_FLAGS_MASK)
+
+int pthread_condattr_destroy(pthread_condattr_t *attr)
+{
+    if (attr == NULL) {
+        return EINVAL;
+    }
+
+    return 0;
+}
+
+int pthread_condattr_init(pthread_condattr_t *attr)
+{
+    if (attr == NULL) {
+        return EINVAL;
+    }
+
+    return 0;
+}
+
+STATIC INLINE INT32 CondInitCheck(const pthread_cond_t *cond)
+{
+    if ((cond->event.stEventList.pstPrev == NULL) &&
+        (cond->event.stEventList.pstNext == NULL)) {
+        return 1;
+    }
+    return 0;
+}
+
+int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr)
+{
+    int ret = ENOERR;
+
+    if (cond == NULL) {
+        return EINVAL;
+    }
+    (VOID)attr;
+    (VOID)LOS_EventInit(&(cond->event));
+
+    cond->mutex = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t));
+    if (cond->mutex == NULL) {
+        return ENOMEM;
+    }
+
+    (VOID)pthread_mutex_init(cond->mutex, NULL);
+
+    cond->value = 0;
+    (VOID)pthread_mutex_lock(cond->mutex);
+    cond->count = 0;
+    (VOID)pthread_mutex_unlock(cond->mutex);
+
+    return ret;
+}
+
+int pthread_cond_destroy(pthread_cond_t *cond)
+{
+    if (cond == NULL) {
+        return EINVAL;
+    }
+
+    if (CondInitCheck(cond)) {
+        return ENOERR;
+    }
+
+    if (LOS_EventDestroy(&cond->event) != LOS_OK) {
+        return EBUSY;
+    }
+    if (pthread_mutex_destroy(cond->mutex) != ENOERR) {
+        PRINT_ERR("%s mutex destroy fail!\n", __FUNCTION__);
+        return EINVAL;
+    }
+    free(cond->mutex);
+    cond->mutex = NULL;
+    return ENOERR;
+}
+
+STATIC VOID PthreadCountSub(pthread_cond_t *cond)
+{
+    (VOID)pthread_mutex_lock(cond->mutex);
+    if (cond->count > 0) {
+        cond->count--;
+    }
+    (VOID)pthread_mutex_unlock(cond->mutex);
+}
+
+
+int pthread_cond_broadcast(pthread_cond_t *cond)
+{
+    int ret = ENOERR;
+
+    if (cond == NULL) {
+        return EINVAL;
+    }
+
+    (VOID)pthread_mutex_lock(cond->mutex);
+    if (cond->count > 0) {
+        cond->count = 0;
+        (VOID)pthread_mutex_unlock(cond->mutex);
+        (VOID)LOS_EventWrite(&(cond->event), BROADCAST_EVENT);
+        return ret;
+    }
+    (VOID)pthread_mutex_unlock(cond->mutex);
+
+    return ret;
+}
+
+int pthread_cond_signal(pthread_cond_t *cond)
+{
+    int ret = ENOERR;
+
+    if (cond == NULL) {
+        return EINVAL;
+    }
+
+    (VOID)pthread_mutex_lock(cond->mutex);
+    if (cond->count > 0) {
+        cond->count--;
+        (VOID)pthread_mutex_unlock(cond->mutex);
+        // This should modify to once.
+        (VOID)LOS_EventWrite(&(cond->event), BROADCAST_EVENT);
+
+        return ret;
+    }
+    (VOID)pthread_mutex_unlock(cond->mutex);
+
+    return ret;
+}
+
+STATIC INT32 ProcessReturnVal(pthread_cond_t *cond, INT32 val)
+{
+    INT32 ret;
+    switch (val) {
+        /* 0: event does not occur */
+        case 0:
+        case BROADCAST_EVENT:
+            ret = ENOERR;
+            break;
+        case LOS_ERRNO_EVENT_READ_TIMEOUT:
+            PthreadCountSub(cond);
+            ret = ETIMEDOUT;
+            break;
+        default:
+            PthreadCountSub(cond);
+            ret = EINVAL;
+            break;
+    }
+    return ret;
+}
+
+int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
+                           const struct timespec *absTime)
+{
+    UINT32 absTicks;
+    INT32 ret;
+
+    if ((cond == NULL) || (mutex == NULL) || (absTime == NULL)) {
+        return EINVAL;
+    }
+
+    if (CondInitCheck(cond)) {
+        ret = pthread_cond_init(cond, NULL);
+        if (ret != ENOERR) {
+            return ret;
+        }
+    }
+
+    (VOID)pthread_mutex_lock(cond->mutex);
+    cond->count++;
+    (VOID)pthread_mutex_unlock(cond->mutex);
+
+    if ((absTime->tv_sec == 0) && (absTime->tv_nsec == 0)) {
+        return ETIMEDOUT;
+    }
+
+    if (!ValidTimeSpec(absTime)) {
+        return EINVAL;
+    }
+
+    absTicks = OsTimeSpec2Tick(absTime);
+    if (pthread_mutex_unlock(mutex) != ENOERR) {
+        PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
+    }
+
+    ret = (INT32)LOS_EventRead(&(cond->event), 0x0f, LOS_WAITMODE_OR | LOS_WAITMODE_CLR, absTicks);
+
+    if (pthread_mutex_lock(mutex) != ENOERR) {
+        PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
+    }
+
+    ret = ProcessReturnVal(cond, ret);
+    return ret;
+}
+
+int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
+{
+    int ret;
+
+    if ((cond == NULL) || (mutex == NULL)) {
+        return EINVAL;
+    }
+
+    if (CondInitCheck(cond)) {
+        ret = pthread_cond_init(cond, NULL);
+        if (ret != ENOERR) {
+            return ret;
+        }
+    }
+
+    (VOID)pthread_mutex_lock(cond->mutex);
+    cond->count++;
+    (VOID)pthread_mutex_unlock(cond->mutex);
+
+    if (pthread_mutex_unlock(mutex) != ENOERR) {
+        PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
+    }
+    ret = (INT32)LOS_EventRead(&(cond->event), 0x0f, LOS_WAITMODE_OR | LOS_WAITMODE_CLR, LOS_WAIT_FOREVER);
+    if (pthread_mutex_lock(mutex) != ENOERR) {
+        PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
+    }
+
+    switch (ret) {
+        /* 0: event does not occur */
+        case 0:
+        case BROADCAST_EVENT:
+            ret = ENOERR;
+            break;
+        default:
+            PthreadCountSub(cond);
+            ret = EINVAL;
+            break;
+    }
+
+    return ret;
+}
diff --git a/kernel/liteos_m/kal/posix/src/pthread_mutex.c b/kernel/liteos_m/kal/posix/src/pthread_mutex.c
old mode 100755
new mode 100644
index 1b71d9a..94e9472
--- a/kernel/liteos_m/kal/posix/src/pthread_mutex.c
+++ b/kernel/liteos_m/kal/posix/src/pthread_mutex.c
@@ -1,179 +1,169 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <pthread.h>
-#include <time.h>
-#include "los_compiler.h"
-#include "los_mux.h"
-#include "errno.h"
-
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
-
-#define OS_SYS_NS_PER_MSECOND 1000000
-#define OS_SYS_NS_PER_SECOND  1000000000
-
-static inline int MapError(UINT32 err)
-{
-    switch (err) {
-        case LOS_OK:
-            return 0;
-        case LOS_ERRNO_MUX_PEND_INTERR:
-            return EPERM;
-        case LOS_ERRNO_MUX_PEND_IN_LOCK:
-            return EDEADLK;
-        case LOS_ERRNO_MUX_PENDED:
-        case LOS_ERRNO_MUX_UNAVAILABLE:
-            return EBUSY;
-        case LOS_ERRNO_MUX_TIMEOUT:
-            return ETIMEDOUT;
-        case LOS_ERRNO_MUX_ALL_BUSY:
-            return EAGAIN;
-        case LOS_ERRNO_MUX_INVALID:
-        default:
-            return EINVAL;
-    }
-}
-
-/* Initialize mutex. If mutexAttr is NULL, use default attributes. */
-int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexAttr)
-{
-    UINT32 muxHandle;
-    UINT32 ret;
-
-    if (mutexAttr != NULL) {
-        return EOPNOTSUPP;
-    }
-
-    ret = LOS_MuxCreate(&muxHandle);
-    if (ret != LOS_OK) {
-        return MapError(ret);
-    }
-
-    mutex->magic = _MUX_MAGIC;
-    mutex->handle = muxHandle;
-
-    return 0;
-}
-
-int pthread_mutex_destroy(pthread_mutex_t *mutex)
-{
-    UINT32 ret;
-    if (mutex->magic != _MUX_MAGIC) {
-        return EINVAL;
-    }
-    ret = LOS_MuxDelete(mutex->handle);
-    if (ret != LOS_OK) {
-        return MapError(ret);
-    }
-    mutex->handle = _MUX_INVALID_HANDLE;
-    return 0;
-}
-
-int pthread_mutex_timedlock(pthread_mutex_t *mutex, const struct timespec *absTimeout)
-{
-    UINT32 ret;
-    UINT32 timeout;
-    UINT64 timeoutNs;
-    struct timespec curTime = {0};
-    if ((mutex->magic != _MUX_MAGIC) || (absTimeout->tv_nsec < 0) || (absTimeout->tv_nsec >= OS_SYS_NS_PER_SECOND)) {
-        return EINVAL;
-    }
-    if (mutex->handle == _MUX_INVALID_HANDLE) {
-        ret = LOS_MuxCreate(&mutex->handle);
-        if (ret != LOS_OK) {
-            return MapError(ret);
-        }
-    }
-    ret = clock_gettime(CLOCK_REALTIME, &curTime);
-    if (ret != LOS_OK) {
-        return EINVAL;
-    }
-    timeoutNs = (absTimeout->tv_sec - curTime.tv_sec) * OS_SYS_NS_PER_SECOND + (absTimeout->tv_nsec - curTime.tv_nsec);
-    if (timeoutNs <= 0) {
-        return ETIMEDOUT;
-    }
-    timeout = (timeoutNs + (OS_SYS_NS_PER_MSECOND - 1)) / OS_SYS_NS_PER_MSECOND;
-    ret = LOS_MuxPend(mutex->handle, timeout);
-    return MapError(ret);
-}
-
-/* Lock mutex, waiting for it if necessary. */
-int pthread_mutex_lock(pthread_mutex_t *mutex)
-{
-    UINT32 ret;
-    if (mutex->magic != _MUX_MAGIC) {
-        return EINVAL;
-    }
-    if (mutex->handle == _MUX_INVALID_HANDLE) {
-        ret = LOS_MuxCreate(&mutex->handle);
-        if (ret != LOS_OK) {
-            return MapError(ret);
-        }
-    }
-    ret = LOS_MuxPend(mutex->handle, LOS_WAIT_FOREVER);
-    return MapError(ret);
-}
-
-int pthread_mutex_trylock(pthread_mutex_t *mutex)
-{
-    UINT32 ret;
-    if (mutex->magic != _MUX_MAGIC) {
-        return EINVAL;
-    }
-    if (mutex->handle == _MUX_INVALID_HANDLE) {
-        ret = LOS_MuxCreate(&mutex->handle);
-        if (ret != LOS_OK) {
-            return MapError(ret);
-        }
-    }
-    ret = LOS_MuxPend(mutex->handle, 0);
-    return MapError(ret);
-}
-
-int pthread_mutex_unlock(pthread_mutex_t *mutex)
-{
-    UINT32 ret;
-    if (mutex->magic != _MUX_MAGIC) {
-        return EINVAL;
-    }
-    ret = LOS_MuxPost(mutex->handle);
-    return MapError(ret);
-}
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <pthread.h>
+#include <time.h>
+#include "los_compiler.h"
+#include "los_mux.h"
+#include "errno.h"
+
+
+#define OS_SYS_NS_PER_MSECOND 1000000
+#define OS_SYS_NS_PER_SECOND  1000000000
+
+static inline int MapError(UINT32 err)
+{
+    switch (err) {
+        case LOS_OK:
+            return 0;
+        case LOS_ERRNO_MUX_PEND_INTERR:
+            return EPERM;
+        case LOS_ERRNO_MUX_PEND_IN_LOCK:
+            return EDEADLK;
+        case LOS_ERRNO_MUX_PENDED:
+        case LOS_ERRNO_MUX_UNAVAILABLE:
+            return EBUSY;
+        case LOS_ERRNO_MUX_TIMEOUT:
+            return ETIMEDOUT;
+        case LOS_ERRNO_MUX_ALL_BUSY:
+            return EAGAIN;
+        case LOS_ERRNO_MUX_INVALID:
+        default:
+            return EINVAL;
+    }
+}
+
+/* Initialize mutex. If mutexAttr is NULL, use default attributes. */
+int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexAttr)
+{
+    UINT32 muxHandle;
+    UINT32 ret;
+
+    if (mutexAttr != NULL) {
+        return EOPNOTSUPP;
+    }
+
+    ret = LOS_MuxCreate(&muxHandle);
+    if (ret != LOS_OK) {
+        return MapError(ret);
+    }
+
+    mutex->magic = _MUX_MAGIC;
+    mutex->handle = muxHandle;
+
+    return 0;
+}
+
+int pthread_mutex_destroy(pthread_mutex_t *mutex)
+{
+    UINT32 ret;
+    if (mutex->magic != _MUX_MAGIC) {
+        return EINVAL;
+    }
+    ret = LOS_MuxDelete(mutex->handle);
+    if (ret != LOS_OK) {
+        return MapError(ret);
+    }
+    mutex->handle = _MUX_INVALID_HANDLE;
+    return 0;
+}
+
+int pthread_mutex_timedlock(pthread_mutex_t *mutex, const struct timespec *absTimeout)
+{
+    UINT32 ret;
+    UINT32 timeout;
+    UINT64 timeoutNs;
+    struct timespec curTime = {0};
+    if ((mutex->magic != _MUX_MAGIC) || (absTimeout->tv_nsec < 0) || (absTimeout->tv_nsec >= OS_SYS_NS_PER_SECOND)) {
+        return EINVAL;
+    }
+    if (mutex->handle == _MUX_INVALID_HANDLE) {
+        ret = LOS_MuxCreate(&mutex->handle);
+        if (ret != LOS_OK) {
+            return MapError(ret);
+        }
+    }
+    ret = clock_gettime(CLOCK_REALTIME, &curTime);
+    if (ret != LOS_OK) {
+        return EINVAL;
+    }
+    timeoutNs = (absTimeout->tv_sec - curTime.tv_sec) * OS_SYS_NS_PER_SECOND + (absTimeout->tv_nsec - curTime.tv_nsec);
+    if (timeoutNs <= 0) {
+        return ETIMEDOUT;
+    }
+    timeout = (timeoutNs + (OS_SYS_NS_PER_MSECOND - 1)) / OS_SYS_NS_PER_MSECOND;
+    ret = LOS_MuxPend(mutex->handle, timeout);
+    return MapError(ret);
+}
+
+/* Lock mutex, waiting for it if necessary. */
+int pthread_mutex_lock(pthread_mutex_t *mutex)
+{
+    UINT32 ret;
+    if (mutex->magic != _MUX_MAGIC) {
+        return EINVAL;
+    }
+    if (mutex->handle == _MUX_INVALID_HANDLE) {
+        ret = LOS_MuxCreate(&mutex->handle);
+        if (ret != LOS_OK) {
+            return MapError(ret);
+        }
+    }
+    ret = LOS_MuxPend(mutex->handle, LOS_WAIT_FOREVER);
+    return MapError(ret);
+}
+
+int pthread_mutex_trylock(pthread_mutex_t *mutex)
+{
+    UINT32 ret;
+    if (mutex->magic != _MUX_MAGIC) {
+        return EINVAL;
+    }
+    if (mutex->handle == _MUX_INVALID_HANDLE) {
+        ret = LOS_MuxCreate(&mutex->handle);
+        if (ret != LOS_OK) {
+            return MapError(ret);
+        }
+    }
+    ret = LOS_MuxPend(mutex->handle, 0);
+    return MapError(ret);
+}
+
+int pthread_mutex_unlock(pthread_mutex_t *mutex)
+{
+    UINT32 ret;
+    if (mutex->magic != _MUX_MAGIC) {
+        return EINVAL;
+    }
+    ret = LOS_MuxPost(mutex->handle);
+    return MapError(ret);
+}
+
diff --git a/kernel/liteos_m/kal/posix/src/semaphore.c b/kernel/liteos_m/kal/posix/src/semaphore.c
index 2c9535f..45d8a1e 100644
--- a/kernel/liteos_m/kal/posix/src/semaphore.c
+++ b/kernel/liteos_m/kal/posix/src/semaphore.c
@@ -1,189 +1,206 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <semaphore.h>
-#include <errno.h>
-#include "los_sem.h"
-#include "time_internal.h"
-
-#define _SEM_MAGIC 0xEBCFDEA1
-
-#define s_magic __val[0]
-#define s_handle __val[1]
-
-static inline int MapError(UINT32 err)
-{
-    switch (err) {
-        case LOS_OK:
-            return 0;
-        case LOS_ERRNO_SEM_INVALID:
-        case LOS_ERRNO_SEM_UNAVAILABLE:
-            return EINVAL;
-        case LOS_ERRNO_SEM_ALL_BUSY:
-            return ENOSPC;
-        case LOS_ERRNO_SEM_OVERFLOW:
-            return ENOMEM;
-        case LOS_ERRNO_SEM_PENDED:
-            return EBUSY;
-        case LOS_ERRNO_SEM_PEND_IN_LOCK:
-            return EPERM;
-        case LOS_ERRNO_SEM_PEND_INTERR:
-            return EINTR;
-        case LOS_ERRNO_SEM_TIMEOUT:
-            return ETIMEDOUT;
-        default:
-            return EINVAL;
-    }
-}
-
-int sem_init(sem_t *sem, int shared, unsigned int value)
-{
-    UINT32 semHandle = 0;
-    UINT32 ret;
-
-    (VOID)shared;
-    if ((sem == NULL) || (value >= OS_SEM_COUNTING_MAX_COUNT)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    ret = LOS_SemCreate(value, &semHandle);
-    if (ret != LOS_OK) {
-        errno = MapError(ret);
-        return -1;
-    }
-
-    sem->s_magic = _SEM_MAGIC;
-    sem->s_handle = (int)semHandle;
-
-    return 0;
-}
-
-int sem_destroy(sem_t *sem)
-{
-    UINT32 ret;
-
-    if ((sem == NULL) || (sem->s_magic != _SEM_MAGIC)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    ret = LOS_SemDelete((UINT32)sem->s_handle);
-    if (ret != LOS_OK) {
-        errno = MapError(ret);
-        return -1;
-    }
-    return 0;
-}
-
-int sem_wait(sem_t *sem)
-{
-    UINT32 ret;
-
-    if ((sem == NULL) || (sem->s_magic != _SEM_MAGIC)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    ret = LOS_SemPend((UINT32)sem->s_handle, LOS_WAIT_FOREVER);
-    if (ret != LOS_OK) {
-        errno = MapError(ret);
-        return -1;
-    }
-    return 0;
-}
-
-int sem_post(sem_t *sem)
-{
-    UINT32 ret;
-
-    if ((sem == NULL) || (sem->s_magic != _SEM_MAGIC)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    ret = LOS_SemPost((UINT32)sem->s_handle);
-    if (ret != LOS_OK) {
-        errno = MapError(ret);
-        return -1;
-    }
-
-    return 0;
-}
-
-static long long GetTickTimeFromNow(const struct timespec *absTimeSpec)
-{
-    struct timespec tsNow = { 0 };
-    long long ns;
-    long long tick;
-
-    clock_gettime(CLOCK_REALTIME, &tsNow);
-    ns = (absTimeSpec->tv_sec - tsNow.tv_sec) * OS_SYS_NS_PER_SECOND + (absTimeSpec->tv_nsec - tsNow.tv_nsec);
-
-    /* Round up for ticks */
-    tick = (ns * LOSCFG_BASE_CORE_TICK_PER_SECOND + (OS_SYS_NS_PER_SECOND - 1)) / OS_SYS_NS_PER_SECOND;
-    return tick;
-}
-
-int sem_timedwait(sem_t *sem, const struct timespec *timeout)
-{
-    UINT32 ret;
-    long long tickCnt;
-    struct timespec tsNow = { 0 };
-
-    if ((sem == NULL) || (sem->s_magic != _SEM_MAGIC)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    if (!ValidTimeSpec(timeout)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    tickCnt = GetTickTimeFromNow(timeout);
-    if (tickCnt < 0) {
-        errno = ETIMEDOUT;
-        return -1;
-    }
-
-    if (tickCnt > LOS_WAIT_FOREVER) {
-        tickCnt = LOS_WAIT_FOREVER;
-    }
-
-    ret = LOS_SemPend((UINT32)sem->s_handle, (UINT32)tickCnt);
-    if (ret != LOS_OK) {
-        errno = MapError(ret);
-        return -1;
-    }
-
-    return 0;
-}
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <semaphore.h>
+#include <errno.h>
+#include "los_sem.h"
+#include "time_internal.h"
+
+#define _SEM_MAGIC 0xEBCFDEA1
+
+#define s_magic __val[0]
+#define s_handle __val[1]
+
+static inline int MapError(UINT32 err)
+{
+    switch (err) {
+        case LOS_OK:
+            return 0;
+        case LOS_ERRNO_SEM_INVALID:
+        case LOS_ERRNO_SEM_UNAVAILABLE:
+            return EINVAL;
+        case LOS_ERRNO_SEM_ALL_BUSY:
+            return ENOSPC;
+        case LOS_ERRNO_SEM_OVERFLOW:
+            return ENOMEM;
+        case LOS_ERRNO_SEM_PENDED:
+            return EBUSY;
+        case LOS_ERRNO_SEM_PEND_IN_LOCK:
+            return EPERM;
+        case LOS_ERRNO_SEM_PEND_INTERR:
+            return EINTR;
+        case LOS_ERRNO_SEM_TIMEOUT:
+            return ETIMEDOUT;
+        default:
+            return EINVAL;
+    }
+}
+
+int sem_init(sem_t *sem, int shared, unsigned int value)
+{
+    UINT32 semHandle = 0;
+    UINT32 ret;
+
+    (VOID)shared;
+    if ((sem == NULL) || (value >= OS_SEM_COUNTING_MAX_COUNT)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ret = LOS_SemCreate(value, &semHandle);
+    if (ret != LOS_OK) {
+        errno = MapError(ret);
+        return -1;
+    }
+
+    sem->s_magic = _SEM_MAGIC;
+    sem->s_handle = (int)semHandle;
+
+    return 0;
+}
+
+int sem_destroy(sem_t *sem)
+{
+    UINT32 ret;
+
+    if ((sem == NULL) || (sem->s_magic != _SEM_MAGIC)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ret = LOS_SemDelete((UINT32)sem->s_handle);
+    if (ret != LOS_OK) {
+        errno = MapError(ret);
+        return -1;
+    }
+    return 0;
+}
+
+int sem_wait(sem_t *sem)
+{
+    UINT32 ret;
+
+    if ((sem == NULL) || (sem->s_magic != _SEM_MAGIC)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ret = LOS_SemPend((UINT32)sem->s_handle, LOS_WAIT_FOREVER);
+    if (ret != LOS_OK) {
+        errno = MapError(ret);
+        return -1;
+    }
+    return 0;
+}
+
+int sem_post(sem_t *sem)
+{
+    UINT32 ret;
+
+    if ((sem == NULL) || (sem->s_magic != _SEM_MAGIC)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ret = LOS_SemPost((UINT32)sem->s_handle);
+    if (ret != LOS_OK) {
+        errno = MapError(ret);
+        return -1;
+    }
+
+    return 0;
+}
+
+static long long GetTickTimeFromNow(const struct timespec *absTimeSpec)
+{
+    struct timespec tsNow = { 0 };
+    long long ns;
+    long long tick;
+
+    clock_gettime(CLOCK_REALTIME, &tsNow);
+    ns = (absTimeSpec->tv_sec - tsNow.tv_sec) * OS_SYS_NS_PER_SECOND + (absTimeSpec->tv_nsec - tsNow.tv_nsec);
+
+    /* Round up for ticks */
+    tick = (ns * LOSCFG_BASE_CORE_TICK_PER_SECOND + (OS_SYS_NS_PER_SECOND - 1)) / OS_SYS_NS_PER_SECOND;
+    return tick;
+}
+
+int sem_timedwait(sem_t *sem, const struct timespec *timeout)
+{
+    UINT32 ret;
+    long long tickCnt;
+
+    if ((sem == NULL) || (sem->s_magic != _SEM_MAGIC)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if (!ValidTimeSpec(timeout)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    tickCnt = GetTickTimeFromNow(timeout);
+    if (tickCnt < 0) {
+        errno = ETIMEDOUT;
+        return -1;
+    }
+
+    if (tickCnt > LOS_WAIT_FOREVER) {
+        tickCnt = LOS_WAIT_FOREVER;
+    }
+
+    ret = LOS_SemPend((UINT32)sem->s_handle, (UINT32)tickCnt);
+    if (ret != LOS_OK) {
+        errno = MapError(ret);
+        return -1;
+    }
+
+    return 0;
+}
+
+int sem_getvalue(sem_t *sem, int *currVal)
+{
+    UINT32 ret;
+
+    if ((sem == NULL) || (currVal == NULL)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ret = LOS_SemGetValue(sem->s_handle, currVal);
+    if (ret) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    return LOS_OK;
+}
\ No newline at end of file
diff --git a/kernel/liteos_m/kal/posix/src/time.c b/kernel/liteos_m/kal/posix/src/time.c
old mode 100755
new mode 100644
index e11c01f..fe4c671
--- a/kernel/liteos_m/kal/posix/src/time.c
+++ b/kernel/liteos_m/kal/posix/src/time.c
@@ -1,655 +1,665 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#define _GNU_SOURCE
-#include <time.h>
-#include <sys/time.h>
-#include <stdint.h>
-#include <errno.h>
-#include <signal.h>
-#include <unistd.h>
-#include "time_internal.h"
-#include "los_debug.h"
-#include "los_task.h"
-#include "los_swtmr.h"
-#include "los_timer.h"
-#include "los_context.h"
-
-/* accumulative time delta from discontinuous modify */
-STATIC struct timespec g_accDeltaFromSet;
-
-STATIC const UINT16 g_daysInMonth[2][13] = {
-    /* Normal years.  */
-    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
-    /* Leap years.  */
-    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
-};
-
-STATIC const UINT8 g_montbl[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
-
-static UINT64 g_rtcTimeBase = 0;
-static UINT64 g_systickBase = 0;
-
-/*
- * Time zone information, stored in minutes,
- * negative values indicate the east of UTC,
- * positive values indicate the west of UTC.
- */
-static INT32 g_rtcTimeZone = -480;
-static struct tm g_tm = {0};
-
-int nanosleep(const struct timespec *rqtp, struct timespec *rmtp)
-{
-    UINT64 nseconds;
-    UINT64 tick;
-    UINT32 ret;
-    const UINT32 nsPerTick = OS_SYS_NS_PER_SECOND / LOSCFG_BASE_CORE_TICK_PER_SECOND;
-
-    if (!ValidTimeSpec(rqtp)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    nseconds = (UINT64)rqtp->tv_sec * OS_SYS_NS_PER_SECOND + rqtp->tv_nsec;
-
-    tick = (nseconds + nsPerTick - 1) / nsPerTick; // Round up for ticks
-
-    if (tick >= UINT32_MAX) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    /* PS: skip the first tick because it is NOT a full tick. */
-    ret = LOS_TaskDelay(tick ? (UINT32)(tick + 1) : 0);
-    if (ret == LOS_OK || ret == LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK) {
-        if (rmtp) {
-            rmtp->tv_sec = rmtp->tv_nsec = 0;
-        }
-        return 0;
-    }
-
-    /* sleep in interrupt context or in task sched lock state */
-    errno = EPERM;
-    return -1;
-}
-
-int timer_create(clockid_t clockID, struct sigevent *restrict evp, timer_t *restrict timerID)
-{
-    UINT32 ret;
-    UINT32 swtmrID;
-
-    if (!timerID || (clockID != CLOCK_REALTIME)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    if (!evp || evp->sigev_notify != SIGEV_THREAD || evp->sigev_notify_attributes) {
-        errno = ENOTSUP;
-        return -1;
-    }
-
-    ret = LOS_SwtmrCreate(1, LOS_SWTMR_MODE_ONCE, (SWTMR_PROC_FUNC)evp->sigev_notify_function,
-                          &swtmrID, (UINT32)(UINTPTR)evp->sigev_value.sival_ptr
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-                          , OS_SWTMR_ROUSES_IGNORE, OS_SWTMR_ALIGN_INSENSITIVE
-#endif
-    );
-    if (ret != LOS_OK) {
-        errno = (ret == LOS_ERRNO_SWTMR_MAXSIZE) ? EAGAIN : EINVAL;
-        return -1;
-    }
-
-    *timerID = (timer_t)(UINTPTR)swtmrID;
-    return 0;
-}
-
-int timer_delete(timer_t timerID)
-{
-    UINT32 swtmrID = (UINT32)(UINTPTR)timerID;
-    if (LOS_SwtmrDelete(swtmrID) != LOS_OK) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    return 0;
-}
-
-int timer_settime(timer_t timerID, int flags,
-                  const struct itimerspec *restrict value,
-                  struct itimerspec *restrict oldValue)
-{
-    UINTPTR intSave;
-    UINT32 swtmrID = (UINT32)(UINTPTR)timerID;
-    SWTMR_CTRL_S *swtmr = NULL;
-    UINT32 interval, expiry, ret;
-
-    if (flags != 0) {
-        /* flags not supported currently */
-        errno = ENOSYS;
-        return -1;
-    }
-
-    if (value == NULL) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    if (!ValidTimeSpec(&value->it_value) || !ValidTimeSpec(&value->it_interval)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    expiry = OsTimeSpec2Tick(&value->it_value);
-    interval = OsTimeSpec2Tick(&value->it_interval);
-
-    /* if specified interval, it must be same with expiry due to the limitation of liteos-m */
-    if (interval && interval != expiry) {
-        errno = ENOTSUP;
-        return -1;
-    }
-
-    if (oldValue) {
-        (VOID)timer_gettime(timerID, oldValue);
-    }
-
-    ret = LOS_SwtmrStop(swtmrID);
-    if ((ret != LOS_OK) && (ret != LOS_ERRNO_SWTMR_NOT_STARTED)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    intSave = LOS_IntLock();
-    swtmr = OS_SWT_FROM_SID(swtmrID);
-    swtmr->ucMode = (interval ? LOS_SWTMR_MODE_PERIOD : LOS_SWTMR_MODE_NO_SELFDELETE);
-    swtmr->uwInterval = interval;
-    LOS_IntRestore(intSave);
-
-    if ((value->it_value.tv_sec == 0) && (value->it_value.tv_nsec == 0)) {
-        /*
-         * 1) when expiry is 0, means timer should be stopped.
-         * 2) If timer is ticking, stopping timer is already done before.
-         * 3) If timer is created but not ticking, return 0 as well.
-         */
-        return 0;
-    }
-
-    if (LOS_SwtmrStart(swtmr->usTimerID) != LOS_OK) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    return 0;
-}
-
-int timer_gettime(timer_t timerID, struct itimerspec *value)
-{
-    UINT32 tick = 0;
-    SWTMR_CTRL_S *swtmr = NULL;
-    UINT32 swtmrID = (UINT32)(UINTPTR)timerID;
-    UINT32 ret;
-
-    if (value == NULL) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    swtmr = OS_SWT_FROM_SID(swtmrID);
-
-    /* get expire time */
-    ret = LOS_SwtmrTimeGet(swtmr->usTimerID, &tick);
-    if ((ret != LOS_OK) && (ret != LOS_ERRNO_SWTMR_NOT_STARTED)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    OsTick2TimeSpec(&value->it_value, tick);
-    OsTick2TimeSpec(&value->it_interval, (swtmr->ucMode == LOS_SWTMR_MODE_ONCE) ? 0 : swtmr->uwInterval);
-    return 0;
-}
-
-int timer_getoverrun(timer_t timerID)
-{
-    (void)timerID;
-
-    errno = ENOSYS;
-    return -1;
-}
-
-STATIC VOID OsGetHwTime(struct timespec *hwTime)
-{
-    UINT64 nowNsec;
-    UINT32 countHigh = 0;
-    UINT32 countLow = 0;
-    HalGetCpuCycle(&countHigh, &countLow);
-    nowNsec = (((UINT64)countHigh * OS_SYS_NS_PER_SECOND / OS_SYS_CLOCK) << 32) +
-              ((((UINT64)countHigh * OS_SYS_NS_PER_SECOND % OS_SYS_CLOCK) << 32) / OS_SYS_CLOCK) +
-              ((UINT64)countLow * OS_SYS_NS_PER_SECOND / OS_SYS_CLOCK);
-    hwTime->tv_sec = nowNsec / OS_SYS_NS_PER_SECOND;
-    hwTime->tv_nsec = nowNsec % OS_SYS_NS_PER_SECOND;
-}
-
-STATIC VOID OsGetRealTime(struct timespec *realTime)
-{
-    UINTPTR intSave;
-    struct timespec hwTime = {0};
-    OsGetHwTime(&hwTime);
-    intSave = LOS_IntLock();
-    realTime->tv_nsec = hwTime.tv_nsec + g_accDeltaFromSet.tv_nsec;
-    realTime->tv_sec = hwTime.tv_sec + g_accDeltaFromSet.tv_sec + (realTime->tv_nsec >= OS_SYS_NS_PER_SECOND);
-    realTime->tv_nsec %= OS_SYS_NS_PER_SECOND;
-    LOS_IntRestore(intSave);
-}
-
-STATIC VOID OsSetRealTime(const struct timespec *realTime)
-{
-    UINTPTR intSave;
-    struct timespec hwTime = {0};
-    OsGetHwTime(&hwTime);
-    intSave = LOS_IntLock();
-    g_accDeltaFromSet.tv_nsec = realTime->tv_nsec - hwTime.tv_nsec;
-    g_accDeltaFromSet.tv_sec = realTime->tv_sec - hwTime.tv_sec - (g_accDeltaFromSet.tv_nsec < 0);
-    g_accDeltaFromSet.tv_nsec = (g_accDeltaFromSet.tv_nsec + OS_SYS_NS_PER_SECOND) % OS_SYS_NS_PER_SECOND;
-    LOS_IntRestore(intSave);
-}
-
-int clock_settime(clockid_t clockID, const struct timespec *tp)
-{
-    if (!ValidTimeSpec(tp)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    switch (clockID) {
-        case CLOCK_REALTIME:
-            /* we only support the realtime clock currently */
-            OsSetRealTime(tp);
-            return 0;
-        case CLOCK_MONOTONIC_COARSE:
-        case CLOCK_REALTIME_COARSE:
-        case CLOCK_MONOTONIC_RAW:
-        case CLOCK_PROCESS_CPUTIME_ID:
-        case CLOCK_BOOTTIME:
-        case CLOCK_REALTIME_ALARM:
-        case CLOCK_BOOTTIME_ALARM:
-        case CLOCK_SGI_CYCLE:
-        case CLOCK_TAI:
-        case CLOCK_THREAD_CPUTIME_ID:
-            errno = ENOTSUP;
-            return -1;
-        case CLOCK_MONOTONIC:
-        default:
-            errno = EINVAL;
-            return -1;
-    }
-}
-
-int clock_gettime(clockid_t clockID, struct timespec *tp)
-{
-    if (tp == NULL) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    switch (clockID) {
-        case CLOCK_MONOTONIC_RAW:
-        case CLOCK_MONOTONIC:
-        case CLOCK_MONOTONIC_COARSE:
-            OsGetHwTime(tp);
-            return 0;
-        case CLOCK_REALTIME:
-        case CLOCK_REALTIME_COARSE:
-            OsGetRealTime(tp);
-            return 0;
-        case CLOCK_THREAD_CPUTIME_ID:
-        case CLOCK_PROCESS_CPUTIME_ID:
-        case CLOCK_BOOTTIME:
-        case CLOCK_REALTIME_ALARM:
-        case CLOCK_BOOTTIME_ALARM:
-        case CLOCK_SGI_CYCLE:
-        case CLOCK_TAI:
-            errno = ENOTSUP;
-            return -1;
-        default:
-            errno = EINVAL;
-            return -1;
-    }
-}
-
-int clock_getres(clockid_t clockID, struct timespec *tp)
-{
-    if (tp == NULL) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    switch (clockID) {
-        case CLOCK_MONOTONIC_RAW:
-        case CLOCK_MONOTONIC:
-        case CLOCK_REALTIME:
-        case CLOCK_MONOTONIC_COARSE:
-        case CLOCK_REALTIME_COARSE:
-            tp->tv_nsec = OS_SYS_NS_PER_SECOND / OS_SYS_CLOCK;
-            tp->tv_sec = 0;
-            return 0;
-        case CLOCK_THREAD_CPUTIME_ID:
-        case CLOCK_PROCESS_CPUTIME_ID:
-        case CLOCK_BOOTTIME:
-        case CLOCK_REALTIME_ALARM:
-        case CLOCK_BOOTTIME_ALARM:
-        case CLOCK_SGI_CYCLE:
-        case CLOCK_TAI:
-            errno = ENOTSUP;
-            return -1;
-        default:
-            errno = EINVAL;
-            return -1;
-    }
-}
-
-int clock_nanosleep(clockid_t clk, int flags, const struct timespec *req, struct timespec *rem)
-{
-    switch (clk) {
-        case CLOCK_REALTIME:
-            if (flags == 0) {
-                /* we only support the realtime clock currently */
-                return nanosleep(req, rem);
-            }
-            /* fallthrough */
-        case CLOCK_MONOTONIC_COARSE:
-        case CLOCK_REALTIME_COARSE:
-        case CLOCK_MONOTONIC_RAW:
-        case CLOCK_MONOTONIC:
-        case CLOCK_PROCESS_CPUTIME_ID:
-        case CLOCK_BOOTTIME:
-        case CLOCK_REALTIME_ALARM:
-        case CLOCK_BOOTTIME_ALARM:
-        case CLOCK_SGI_CYCLE:
-        case CLOCK_TAI:
-            if (flags == 0 || flags == TIMER_ABSTIME) {
-                return ENOTSUP;
-            }
-            /* fallthrough */
-        case CLOCK_THREAD_CPUTIME_ID:
-        default:
-            return EINVAL;
-    }
-}
-
-clock_t clock(void)
-{
-    return HalGetExpandTick();
-}
-
-time_t time(time_t *timer)
-{
-    UINT64 usec = 0;
-    time_t sec;
-    INT32 rtcRet;
-
-    rtcRet = HalGetRtcTime(&usec);
-    if (rtcRet != 0) {
-        UINT64 currentTime;
-        UINT64 tickDelta;
-        UINT64 currentTick = HalGetExpandTick();
-        if ((g_systickBase != 0) && (currentTick > g_systickBase)) {
-            tickDelta = currentTick - g_systickBase;
-        }
-        currentTime = g_rtcTimeBase + tickDelta;
-        sec = currentTime / OS_SYS_MS_PER_SECOND;
-    } else {
-        sec = usec / OS_SYS_US_PER_SECOND;
-    }
-
-    if (timer != NULL) {
-        *timer = sec;
-    }
-    return sec;
-}
-
-/*
- * Compute the `struct tm' representation of T,
- * offset OFFSET seconds east of UTC,
- * and store year, yday, mon, mday, wday, hour, min, sec into *TP.
- * Return nonzero if successful.
- */
-static INT32 ConvertSecs2Utc(time_t t, INT32 offset, struct tm *tp)
-{
-    time_t days;
-    time_t rem;
-    time_t year;
-    time_t month;
-    time_t yearGuess;
-
-    days = t / SECS_PER_DAY;
-    rem = t % SECS_PER_DAY;
-    rem += offset;
-    while (rem < 0) {
-        rem += SECS_PER_DAY;
-        --days;
-    }
-    while (rem >= SECS_PER_DAY) {
-        rem -= SECS_PER_DAY;
-        ++days;
-    }
-    tp->tm_hour = rem / SECS_PER_HOUR;
-    rem %= SECS_PER_HOUR;
-    tp->tm_min = rem / SECS_PER_MIN;
-    tp->tm_sec = rem % SECS_PER_MIN;
-    /* January 1, 1970 was a Thursday.  */
-    tp->tm_wday = (BEGIN_WEEKDAY + days) % DAYS_PER_WEEK;
-    if (tp->tm_wday < 0) {
-        tp->tm_wday += DAYS_PER_WEEK;
-    }
-    year = EPOCH_YEAR;
-
-    while ((days < 0) ||
-           (days >= (IS_LEAP_YEAR (year) ? DAYS_PER_LEAP_YEAR : DAYS_PER_NORMAL_YEAR))) {
-        /* Guess a corrected year, assuming 365 days per year.  */
-        yearGuess = year + days / DAYS_PER_NORMAL_YEAR - (days % DAYS_PER_NORMAL_YEAR < 0);
-
-        /* Adjust days and year to match the guessed year.  */
-        days -= ((yearGuess - year) * DAYS_PER_NORMAL_YEAR +
-                 LEAPS_THRU_END_OF (yearGuess - 1) -
-                 LEAPS_THRU_END_OF (year - 1));
-        year = yearGuess;
-    }
-    tp->tm_year = year - TM_YEAR_BASE;
-    if (tp->tm_year != year - TM_YEAR_BASE) {
-        return 0;
-    }
-    tp->tm_yday = days;
-    const UINT16 *daysInMonth = g_daysInMonth[IS_LEAP_YEAR(year)];
-    /* valid month value is 0-11 */
-    for (month = 11; days < (long int) daysInMonth[month]; --month) {
-        continue;
-    }
-    days -= daysInMonth[month];
-    tp->tm_mon = month;
-    tp->tm_mday = days + 1;
-    return 1;
-}
-
-struct tm *gmtime_r(const time_t *timer, struct tm *tp)
-{
-    time_t t64;
-    UINT32 intSave;
-    if ((timer == NULL) || (tp == NULL)) {
-        return NULL;
-    }
-    intSave = LOS_IntLock();
-    t64 = *timer;
-    if (!ConvertSecs2Utc(t64, 0, tp)) {
-        tp = NULL;
-    }
-    (void)LOS_IntRestore(intSave);
-    return tp;
-}
-
-struct tm *gmtime(const time_t *timer)
-{
-    return gmtime_r(timer, &g_tm);
-}
-
-struct tm *localtime_r(const time_t *timer, struct tm *tp)
-{
-    UINT32 intSave;
-    time_t t64;
-    INT32 offset;
-    if ((timer == NULL) || (tp == NULL)) {
-        return NULL;
-    }
-    intSave = LOS_IntLock();
-    t64 = *timer;
-    offset = -(g_rtcTimeZone * SECS_PER_MIN);
-    if (!ConvertSecs2Utc(t64, offset, tp)) {
-        tp = NULL;
-    }
-    (void)LOS_IntRestore(intSave);
-    return tp;
-}
-
-struct tm *localtime(const time_t *timer)
-{
-    return localtime_r(timer, &g_tm);
-}
-
-static time_t ConvertUtc2Secs(struct tm *tm)
-{
-    time_t seconds = 0;
-    INT32 month = 0;
-    UINT8 leap = 0;
-
-    INT32 year = (EPOCH_YEAR - TM_YEAR_BASE);
-    while (year < tm->tm_year) {
-        seconds += SECS_PER_NORMAL_YEAR;
-        if (IS_LEAP_YEAR(year + TM_YEAR_BASE)) {
-            seconds += SECS_PER_DAY;
-        }
-        year++;
-    }
-
-    if (IS_LEAP_YEAR(tm->tm_year + TM_YEAR_BASE)) {
-        leap = 1;
-    }
-    while (month < tm->tm_mon) {
-        if ((month == 1) && leap) {
-            seconds += (g_montbl[month] + 1) * SECS_PER_DAY;
-        } else {
-            seconds += g_montbl[month] * SECS_PER_DAY;
-        }
-        month++;
-    }
-
-    seconds += (tm->tm_mday - 1) * SECS_PER_DAY;
-
-    seconds += tm->tm_hour * SECS_PER_HOUR + tm->tm_min * SECS_PER_MIN + tm->tm_sec;
-
-    return seconds;
-}
-
-time_t mktime(struct tm *tmptr)
-{
-    struct tm tempTime;
-    time_t timeInSeconds;
-    if (tmptr == NULL) {
-        return 0;
-    }
-    if (tmptr->tm_year < (EPOCH_YEAR - TM_YEAR_BASE)) {
-        return 0;
-    }
-    tempTime = *tmptr;
-    timeInSeconds = ConvertUtc2Secs(&tempTime);
-    timeInSeconds += g_rtcTimeZone * SECS_PER_MIN;
-    return timeInSeconds;
-}
-
-int gettimeofday(struct timeval *tv, void *ptz)
-{
-    INT32 rtcRet;
-    INT32 timeZone = 0;
-    UINT64 usec = 0;
-    UINT64 currentTime;
-    UINT64 tickDelta = 0;
-    UINT64 currentTick;
-
-    struct timezone *tz = (struct timezone *)ptz;
-    if ((tv == NULL) && (tz == NULL)) {
-        return -1;
-    }
-    if (tv != NULL) {
-        rtcRet = HalGetRtcTime(&usec);
-        if (rtcRet != 0) {
-            currentTick = HalGetExpandTick();
-            if ((g_systickBase != 0) && (currentTick > g_systickBase)) {
-                tickDelta = currentTick - g_systickBase;
-            }
-            currentTime = g_rtcTimeBase + tickDelta;
-            tv->tv_sec = currentTime / OS_SYS_MS_PER_SECOND;
-            tv->tv_usec = (currentTime % OS_SYS_MS_PER_SECOND) * OS_SYS_MS_PER_SECOND;
-        } else {
-            tv->tv_sec = usec / OS_SYS_US_PER_SECOND;
-            tv->tv_usec = usec % OS_SYS_US_PER_SECOND;
-        }
-    }
-    HalGetRtcTimeZone(&timeZone);
-    if (tz != NULL) {
-        tz->tz_minuteswest = timeZone;
-    }
-    return 0;
-}
-
-int settimeofday(const struct timeval *tv, const struct timezone *tz)
-{
-    UINT64 usec;
-    if ((tv == NULL) || (tz == NULL)) {
-        return -1;
-    }
-    g_rtcTimeBase = tv->tv_sec * OS_SYS_MS_PER_SECOND + tv->tv_usec / OS_SYS_MS_PER_SECOND;
-    g_systickBase = HalGetExpandTick();
-    if ((tz->tz_minuteswest > TIME_ZONE_MIN) &&
-        (tz->tz_minuteswest < TIME_ZONE_MAX)) {
-        g_rtcTimeZone = tz->tz_minuteswest;
-    }
-    usec = tv->tv_sec * OS_SYS_US_PER_SECOND + tv->tv_usec;
-    HalSetRtcTime(g_rtcTimeBase, &usec);
-    HalSetRtcTimeZone(g_rtcTimeZone);
-    return 0;
-}
-
-int usleep(unsigned useconds)
-{
-    struct timespec specTime = { 0 };
-    UINT64 nanoseconds = useconds * OS_SYS_NS_PER_US;
-
-    specTime.tv_sec = (time_t)(nanoseconds / OS_SYS_NS_PER_SECOND);
-    specTime.tv_nsec = (long)(nanoseconds % OS_SYS_NS_PER_SECOND);
-    return nanosleep(&specTime, NULL);
-}
\ No newline at end of file
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define _GNU_SOURCE
+#include <time.h>
+#include <sys/time.h>
+#include <stdint.h>
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+#include "time_internal.h"
+#include "los_debug.h"
+#include "los_task.h"
+#include "los_swtmr.h"
+#include "los_tick.h"
+#include "los_context.h"
+#include "los_interrupt.h"
+
+
+/* accumulative time delta from discontinuous modify */
+STATIC struct timespec g_accDeltaFromSet;
+
+STATIC const UINT16 g_daysInMonth[2][13] = {
+    /* Normal years.  */
+    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
+    /* Leap years.  */
+    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
+};
+
+STATIC const UINT8 g_montbl[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
+
+/*
+ * Time zone information, stored in seconds,
+ * negative values indicate the east of UTC,
+ * positive values indicate the west of UTC.
+ */
+long timezone = -8 * 60 * 60; // defaults to CST: 8 hours east of the Prime Meridian
+
+/* internal shared struct tm object for localtime and gmtime */
+static struct tm g_tm;
+
+int nanosleep(const struct timespec *rqtp, struct timespec *rmtp)
+{
+    UINT64 nseconds;
+    UINT64 tick;
+    UINT32 ret;
+    const UINT32 nsPerTick = OS_SYS_NS_PER_SECOND / LOSCFG_BASE_CORE_TICK_PER_SECOND;
+
+    if (!ValidTimeSpec(rqtp)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    nseconds = (UINT64)rqtp->tv_sec * OS_SYS_NS_PER_SECOND + rqtp->tv_nsec;
+
+    tick = (nseconds + nsPerTick - 1) / nsPerTick; // Round up for ticks
+
+    if (tick >= UINT32_MAX) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    /* PS: skip the first tick because it is NOT a full tick. */
+    ret = LOS_TaskDelay(tick ? (UINT32)(tick + 1) : 0);
+    if (ret == LOS_OK || ret == LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK) {
+        if (rmtp) {
+            rmtp->tv_sec = rmtp->tv_nsec = 0;
+        }
+        return 0;
+    }
+
+    /* sleep in interrupt context or in task sched lock state */
+    errno = EPERM;
+    return -1;
+}
+
+int timer_create(clockid_t clockID, struct sigevent *restrict evp, timer_t *restrict timerID)
+{
+    UINT32 ret;
+    UINT32 swtmrID;
+
+    if (!timerID || (clockID != CLOCK_REALTIME)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if (!evp || evp->sigev_notify != SIGEV_THREAD || evp->sigev_notify_attributes) {
+        errno = ENOTSUP;
+        return -1;
+    }
+
+    ret = LOS_SwtmrCreate(1, LOS_SWTMR_MODE_ONCE, (SWTMR_PROC_FUNC)evp->sigev_notify_function,
+                          &swtmrID, (UINT32)(UINTPTR)evp->sigev_value.sival_ptr
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+                          , OS_SWTMR_ROUSES_IGNORE, OS_SWTMR_ALIGN_INSENSITIVE
+#endif
+    );
+    if (ret != LOS_OK) {
+        errno = (ret == LOS_ERRNO_SWTMR_MAXSIZE) ? EAGAIN : EINVAL;
+        return -1;
+    }
+
+    *timerID = (timer_t)(UINTPTR)swtmrID;
+    return 0;
+}
+
+int timer_delete(timer_t timerID)
+{
+    UINT32 swtmrID = (UINT32)(UINTPTR)timerID;
+    if (LOS_SwtmrDelete(swtmrID) != LOS_OK) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    return 0;
+}
+
+int timer_settime(timer_t timerID, int flags,
+                  const struct itimerspec *restrict value,
+                  struct itimerspec *restrict oldValue)
+{
+    UINT32 intSave;
+    UINT32 swtmrID = (UINT32)(UINTPTR)timerID;
+    SWTMR_CTRL_S *swtmr = NULL;
+    UINT32 interval, expiry, ret;
+
+    if (flags != 0) {
+        /* flags not supported currently */
+        errno = ENOSYS;
+        return -1;
+    }
+
+    if (value == NULL) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if (!ValidTimeSpec(&value->it_value) || !ValidTimeSpec(&value->it_interval)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    expiry = OsTimeSpec2Tick(&value->it_value);
+    interval = OsTimeSpec2Tick(&value->it_interval);
+
+    /* if specified interval, it must be same with expiry due to the limitation of liteos-m */
+    if (interval && interval != expiry) {
+        errno = ENOTSUP;
+        return -1;
+    }
+
+    if (oldValue) {
+        (VOID)timer_gettime(timerID, oldValue);
+    }
+
+    ret = LOS_SwtmrStop(swtmrID);
+    if ((ret != LOS_OK) && (ret != LOS_ERRNO_SWTMR_NOT_STARTED)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    intSave = LOS_IntLock();
+    swtmr = OS_SWT_FROM_SID(swtmrID);
+    swtmr->ucMode = (interval ? LOS_SWTMR_MODE_PERIOD : LOS_SWTMR_MODE_NO_SELFDELETE);
+    swtmr->uwInterval = (interval ? interval : expiry);
+
+    LOS_IntRestore(intSave);
+
+    if ((value->it_value.tv_sec == 0) && (value->it_value.tv_nsec == 0)) {
+        /*
+         * 1) when expiry is 0, means timer should be stopped.
+         * 2) If timer is ticking, stopping timer is already done before.
+         * 3) If timer is created but not ticking, return 0 as well.
+         */
+        return 0;
+    }
+
+    if (LOS_SwtmrStart(swtmr->usTimerID) != LOS_OK) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    return 0;
+}
+
+int timer_gettime(timer_t timerID, struct itimerspec *value)
+{
+    UINT32 tick = 0;
+    SWTMR_CTRL_S *swtmr = NULL;
+    UINT32 swtmrID = (UINT32)(UINTPTR)timerID;
+    UINT32 ret;
+
+    if (value == NULL) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    swtmr = OS_SWT_FROM_SID(swtmrID);
+
+    /* get expire time */
+    ret = LOS_SwtmrTimeGet(swtmr->usTimerID, &tick);
+    if ((ret != LOS_OK) && (ret != LOS_ERRNO_SWTMR_NOT_STARTED)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    OsTick2TimeSpec(&value->it_value, tick);
+    OsTick2TimeSpec(&value->it_interval, (swtmr->ucMode == LOS_SWTMR_MODE_ONCE) ? 0 : swtmr->uwInterval);
+    return 0;
+}
+
+int timer_getoverrun(timer_t timerID)
+{
+    (void)timerID;
+
+    errno = ENOSYS;
+    return -1;
+}
+
+STATIC VOID OsGetHwTime(struct timespec *hwTime)
+{
+    UINT64 cycle = LOS_SysCycleGet();
+    UINT64 nowNsec = (cycle / OS_SYS_CLOCK) * OS_SYS_NS_PER_SECOND +
+                     (cycle % OS_SYS_CLOCK) * OS_SYS_NS_PER_SECOND / OS_SYS_CLOCK;
+
+    hwTime->tv_sec = nowNsec / OS_SYS_NS_PER_SECOND;
+    hwTime->tv_nsec = nowNsec % OS_SYS_NS_PER_SECOND;
+}
+
+STATIC VOID OsGetRealTime(struct timespec *realTime)
+{
+    UINT32 intSave;
+    struct timespec hwTime = {0};
+    OsGetHwTime(&hwTime);
+    intSave = LOS_IntLock();
+    realTime->tv_nsec = hwTime.tv_nsec + g_accDeltaFromSet.tv_nsec;
+    realTime->tv_sec = hwTime.tv_sec + g_accDeltaFromSet.tv_sec + (realTime->tv_nsec >= OS_SYS_NS_PER_SECOND);
+    realTime->tv_nsec %= OS_SYS_NS_PER_SECOND;
+    LOS_IntRestore(intSave);
+}
+
+STATIC VOID OsSetRealTime(const struct timespec *realTime)
+{
+    UINT32 intSave;
+    struct timespec hwTime = {0};
+    OsGetHwTime(&hwTime);
+    intSave = LOS_IntLock();
+    g_accDeltaFromSet.tv_nsec = realTime->tv_nsec - hwTime.tv_nsec;
+    g_accDeltaFromSet.tv_sec = realTime->tv_sec - hwTime.tv_sec - (g_accDeltaFromSet.tv_nsec < 0);
+    g_accDeltaFromSet.tv_nsec = (g_accDeltaFromSet.tv_nsec + OS_SYS_NS_PER_SECOND) % OS_SYS_NS_PER_SECOND;
+    LOS_IntRestore(intSave);
+}
+
+int clock_settime(clockid_t clockID, const struct timespec *tp)
+{
+    if (!ValidTimeSpec(tp)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    switch (clockID) {
+        case CLOCK_REALTIME:
+            /* we only support the realtime clock currently */
+            OsSetRealTime(tp);
+            return 0;
+        case CLOCK_MONOTONIC_COARSE:
+        case CLOCK_REALTIME_COARSE:
+        case CLOCK_MONOTONIC_RAW:
+        case CLOCK_PROCESS_CPUTIME_ID:
+        case CLOCK_BOOTTIME:
+        case CLOCK_REALTIME_ALARM:
+        case CLOCK_BOOTTIME_ALARM:
+        case CLOCK_SGI_CYCLE:
+        case CLOCK_TAI:
+        case CLOCK_THREAD_CPUTIME_ID:
+            errno = ENOTSUP;
+            return -1;
+        case CLOCK_MONOTONIC:
+        default:
+            errno = EINVAL;
+            return -1;
+    }
+}
+
+int clock_gettime(clockid_t clockID, struct timespec *tp)
+{
+    if (tp == NULL) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    switch (clockID) {
+        case CLOCK_MONOTONIC_RAW:
+        case CLOCK_MONOTONIC:
+        case CLOCK_MONOTONIC_COARSE:
+            OsGetHwTime(tp);
+            return 0;
+        case CLOCK_REALTIME:
+        case CLOCK_REALTIME_COARSE:
+            OsGetRealTime(tp);
+            return 0;
+        case CLOCK_THREAD_CPUTIME_ID:
+        case CLOCK_PROCESS_CPUTIME_ID:
+        case CLOCK_BOOTTIME:
+        case CLOCK_REALTIME_ALARM:
+        case CLOCK_BOOTTIME_ALARM:
+        case CLOCK_SGI_CYCLE:
+        case CLOCK_TAI:
+            errno = ENOTSUP;
+            return -1;
+        default:
+            errno = EINVAL;
+            return -1;
+    }
+}
+
+int clock_getres(clockid_t clockID, struct timespec *tp)
+{
+    if (tp == NULL) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    switch (clockID) {
+        case CLOCK_MONOTONIC_RAW:
+        case CLOCK_MONOTONIC:
+        case CLOCK_REALTIME:
+        case CLOCK_MONOTONIC_COARSE:
+        case CLOCK_REALTIME_COARSE:
+            tp->tv_nsec = OS_SYS_NS_PER_SECOND / OS_SYS_CLOCK;
+            tp->tv_sec = 0;
+            return 0;
+        case CLOCK_THREAD_CPUTIME_ID:
+        case CLOCK_PROCESS_CPUTIME_ID:
+        case CLOCK_BOOTTIME:
+        case CLOCK_REALTIME_ALARM:
+        case CLOCK_BOOTTIME_ALARM:
+        case CLOCK_SGI_CYCLE:
+        case CLOCK_TAI:
+            errno = ENOTSUP;
+            return -1;
+        default:
+            errno = EINVAL;
+            return -1;
+    }
+}
+
+int clock_nanosleep(clockid_t clk, int flags, const struct timespec *req, struct timespec *rem)
+{
+    switch (clk) {
+        case CLOCK_REALTIME:
+            if (flags == 0) {
+                /* we only support the realtime clock currently */
+                return nanosleep(req, rem);
+            }
+            /* fallthrough */
+        case CLOCK_MONOTONIC_COARSE:
+        case CLOCK_REALTIME_COARSE:
+        case CLOCK_MONOTONIC_RAW:
+        case CLOCK_MONOTONIC:
+        case CLOCK_PROCESS_CPUTIME_ID:
+        case CLOCK_BOOTTIME:
+        case CLOCK_REALTIME_ALARM:
+        case CLOCK_BOOTTIME_ALARM:
+        case CLOCK_SGI_CYCLE:
+        case CLOCK_TAI:
+            if (flags == 0 || flags == TIMER_ABSTIME) {
+                return ENOTSUP;
+            }
+            /* fallthrough */
+        case CLOCK_THREAD_CPUTIME_ID:
+        default:
+            return EINVAL;
+    }
+}
+
+clock_t clock(void)
+{
+    clock_t clk;
+    struct timespec hwTime;
+    OsGetHwTime(&hwTime);
+
+    clk = hwTime.tv_sec * CLOCKS_PER_SEC;
+    clk += hwTime.tv_nsec  / (OS_SYS_NS_PER_SECOND / CLOCKS_PER_SEC);
+
+    return clk;
+}
+
+time_t time(time_t *timer)
+{
+    struct timespec ts;
+
+    if (-1 == clock_gettime(CLOCK_REALTIME, &ts)) {
+        return (time_t)-1;
+    }
+
+    if (timer != NULL) {
+        *timer = ts.tv_sec;
+    }
+    return ts.tv_sec;
+}
+
+/*
+ * Compute the `struct tm' representation of T,
+ * offset OFFSET seconds east of UTC,
+ * and store year, yday, mon, mday, wday, hour, min, sec into *TP.
+ * Return nonzero if successful.
+ */
+static INT32 ConvertSecs2Utc(time_t t, INT32 offset, struct tm *tp)
+{
+    time_t days;
+    time_t rem;
+    time_t year;
+    time_t month;
+    time_t yearGuess;
+
+    days = t / SECS_PER_DAY;
+    rem = t % SECS_PER_DAY;
+    rem += offset;
+    while (rem < 0) {
+        rem += SECS_PER_DAY;
+        --days;
+    }
+    while (rem >= SECS_PER_DAY) {
+        rem -= SECS_PER_DAY;
+        ++days;
+    }
+    tp->tm_hour = rem / SECS_PER_HOUR;
+    rem %= SECS_PER_HOUR;
+    tp->tm_min = rem / SECS_PER_MIN;
+    tp->tm_sec = rem % SECS_PER_MIN;
+    /* January 1, 1970 was a Thursday.  */
+    tp->tm_wday = (BEGIN_WEEKDAY + days) % DAYS_PER_WEEK;
+    if (tp->tm_wday < 0) {
+        tp->tm_wday += DAYS_PER_WEEK;
+    }
+    year = EPOCH_YEAR;
+
+    while ((days < 0) ||
+           (days >= (IS_LEAP_YEAR (year) ? DAYS_PER_LEAP_YEAR : DAYS_PER_NORMAL_YEAR))) {
+        /* Guess a corrected year, assuming 365 days per year.  */
+        yearGuess = year + days / DAYS_PER_NORMAL_YEAR - (days % DAYS_PER_NORMAL_YEAR < 0);
+
+        /* Adjust days and year to match the guessed year.  */
+        days -= ((yearGuess - year) * DAYS_PER_NORMAL_YEAR +
+                 LEAPS_THRU_END_OF (yearGuess - 1) -
+                 LEAPS_THRU_END_OF (year - 1));
+        year = yearGuess;
+    }
+    tp->tm_year = year - TM_YEAR_BASE;
+    if (tp->tm_year != year - TM_YEAR_BASE) {
+        return 0;
+    }
+    tp->tm_yday = days;
+    const UINT16 *daysInMonth = g_daysInMonth[IS_LEAP_YEAR(year)];
+    /* valid month value is 0-11 */
+    for (month = 11; days < (long int) daysInMonth[month]; --month) {
+        continue;
+    }
+    days -= daysInMonth[month];
+    tp->tm_mon = month;
+    tp->tm_mday = days + 1;
+    tp->__tm_gmtoff = offset;
+    tp->__tm_zone = NULL;
+    tp->tm_isdst = 0;
+    return 1;
+}
+
+struct tm *gmtime_r(const time_t *timep, struct tm *result)
+{
+    if ((timep == NULL) || (result == NULL)) {
+        errno = EFAULT;
+        return NULL;
+    }
+    if (!ConvertSecs2Utc(*timep, 0, result)) {
+        errno = EINVAL;
+        return NULL;
+    }
+    return result;
+}
+
+struct tm *gmtime(const time_t *timer)
+{
+    return gmtime_r(timer, &g_tm);
+}
+
+struct tm *localtime_r(const time_t *timep, struct tm *result)
+{
+    if ((timep == NULL) || (result == NULL)) {
+        errno = EFAULT;
+        return NULL;
+    }
+    if (!ConvertSecs2Utc(*timep, -timezone, result)) {
+        errno = EINVAL;
+        return NULL;
+    }
+    return result;
+}
+
+struct tm *localtime(const time_t *timer)
+{
+    return localtime_r(timer, &g_tm);
+}
+
+static time_t ConvertUtc2Secs(struct tm *tm)
+{
+    time_t seconds = 0;
+    INT32 month = 0;
+    UINT8 leap = 0;
+
+    INT32 year = (EPOCH_YEAR - TM_YEAR_BASE);
+    while (year < tm->tm_year) {
+        seconds += SECS_PER_NORMAL_YEAR;
+        if (IS_LEAP_YEAR(year + TM_YEAR_BASE)) {
+            seconds += SECS_PER_DAY;
+        }
+        year++;
+    }
+
+    if (IS_LEAP_YEAR(tm->tm_year + TM_YEAR_BASE)) {
+        leap = 1;
+    }
+    while (month < tm->tm_mon) {
+        if ((month == 1) && leap) {
+            seconds += (g_montbl[month] + 1) * SECS_PER_DAY;
+        } else {
+            seconds += g_montbl[month] * SECS_PER_DAY;
+        }
+        month++;
+    }
+
+    seconds += (tm->tm_mday - 1) * SECS_PER_DAY;
+    seconds += tm->tm_hour * SECS_PER_HOUR + tm->tm_min * SECS_PER_MIN + tm->tm_sec;
+
+    seconds -= tm->__tm_gmtoff; // sub time zone to get UTC time
+    return seconds;
+}
+
+time_t mktime(struct tm *tmptr)
+{
+    time_t timeInSeconds;
+    if (tmptr == NULL) {
+        errno = EFAULT;
+        return (time_t)-1;
+    }
+
+    /* tm_isdst is not supported and is ignored */
+    if (tmptr->tm_year < (EPOCH_YEAR - TM_YEAR_BASE) ||
+            tmptr->__tm_gmtoff > (-TIME_ZONE_MIN * SECS_PER_MIN) ||
+            tmptr->__tm_gmtoff < (-TIME_ZONE_MAX * SECS_PER_MIN) ||
+            tmptr->tm_sec > 60 || tmptr->tm_sec < 0 ||      /* Seconds [0-60] */
+            tmptr->tm_min > 59 || tmptr->tm_min < 0 ||      /* Minutes [0-59] */
+            tmptr->tm_hour > 23 || tmptr->tm_hour < 0 ||    /* Hours [0-23] */
+            tmptr->tm_mday > 31 || tmptr->tm_mday < 1 ||    /* Day of the month [1-31] */
+            tmptr->tm_mon > 11 || tmptr->tm_mon < 0) {      /* Month [0-11] */
+        errno = EOVERFLOW;
+        return (time_t)-1;
+    }
+    timeInSeconds = ConvertUtc2Secs(tmptr);
+    /* normalize tm_wday and tm_yday */
+    ConvertSecs2Utc(timeInSeconds, tmptr->__tm_gmtoff, tmptr);
+    return timeInSeconds;
+}
+
+int gettimeofday(struct timeval *tv, void *ptz)
+{
+    struct timespec ts;
+    struct timezone *tz = (struct timezone *)ptz;
+
+    if (tv != NULL) {
+        if (-1 == clock_gettime(CLOCK_REALTIME, &ts)) {
+            return -1;
+        }
+        tv->tv_sec = ts.tv_sec;
+        tv->tv_usec = ts.tv_nsec / OS_SYS_NS_PER_US;
+    }
+    if (tz != NULL) {
+        tz->tz_minuteswest = timezone / SECS_PER_MIN;
+        tz->tz_dsttime = 0;
+    }
+    return 0;
+}
+
+int settimeofday(const struct timeval *tv, const struct timezone *tz)
+{
+    struct timespec ts;
+    INT32 rtcTimeZone = timezone;
+
+    if (tv == NULL) {
+        errno = EFAULT;
+        return -1;
+    }
+    if (tz != NULL) {
+        if ((tz->tz_minuteswest >= TIME_ZONE_MIN) &&
+            (tz->tz_minuteswest <= TIME_ZONE_MAX)) {
+            rtcTimeZone = tz->tz_minuteswest * SECS_PER_MIN;
+        } else {
+            errno = EINVAL;
+            return -1;
+        }
+    }
+
+    if (tv->tv_usec >= OS_SYS_US_PER_SECOND) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ts.tv_sec = tv->tv_sec;
+    ts.tv_nsec = tv->tv_usec * OS_SYS_NS_PER_US;
+    if (-1 == clock_settime(CLOCK_REALTIME, &ts)) {
+        return -1;
+    }
+
+    timezone = rtcTimeZone;
+
+    return 0;
+}
+
+int usleep(unsigned useconds)
+{
+    struct timespec specTime = { 0 };
+    UINT64 nanoseconds = (UINT64)useconds * OS_SYS_NS_PER_US;
+
+    specTime.tv_sec = (time_t)(nanoseconds / OS_SYS_NS_PER_SECOND);
+    specTime.tv_nsec = (long)(nanoseconds % OS_SYS_NS_PER_SECOND);
+    return nanosleep(&specTime, NULL);
+}
+
+unsigned sleep(unsigned seconds)
+{
+    struct timespec specTime = { 0 };
+    UINT64 nanoseconds = (UINT64)seconds * OS_SYS_NS_PER_SECOND;
+
+    specTime.tv_sec = (time_t)(nanoseconds / OS_SYS_NS_PER_SECOND);
+    specTime.tv_nsec = (long)(nanoseconds % OS_SYS_NS_PER_SECOND);
+    return nanosleep(&specTime, NULL);
+}
diff --git a/kernel/liteos_m/kal/posix/src/time_internal.h b/kernel/liteos_m/kal/posix/src/time_internal.h
index e7181d1..d838d06 100644
--- a/kernel/liteos_m/kal/posix/src/time_internal.h
+++ b/kernel/liteos_m/kal/posix/src/time_internal.h
@@ -1,123 +1,115 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _TIME_IMPL_H
-#define _TIME_IMPL_H
-
-#include <time.h>
-#include <sys/time.h>
-#include <stdint.h>
-#include <errno.h>
-#include <signal.h>
-#include <unistd.h>
-#include "los_debug.h"
-#include "los_task.h"
-#include "los_swtmr.h"
-#include "los_timer.h"
-#include "los_context.h"
-#include "los_compiler.h"
-
-#define OS_SYS_NS_PER_US 1000
-#define OS_SYS_NS_PER_SECOND 1000000000
-#define OS_SYS_US_PER_SECOND 1000000
-#define OS_SYS_MS_PER_SECOND 1000
-
-#define TM_YEAR_BASE         1900
-#define EPOCH_YEAR           1970
-#define SECS_PER_MIN         60
-#define MINS_PER_HOUR        60
-#define SECS_PER_HOUR        3600  /* 60 * 60 */
-#define SECS_PER_DAY         86400 /* 60 * 60 * 24 */
-#define SECS_PER_NORMAL_YEAR 31536000 /* 60 * 60 * 24 * 365 */
-#define DAYS_PER_WEEK        7
-#define DAYS_PER_NORMAL_YEAR 365
-#define DAYS_PER_LEAP_YEAR   366
-#define BEGIN_WEEKDAY        4
-#define TIME_ZONE_MAX        720 /* 12 * 60 */
-#define TIME_ZONE_MIN        (-840) /* -14 * 60 */
-
-/*
- * Nonzero if YEAR is a leap year (every 4 years,
- * except every 100th isn't, and every 400th is).
- */
-#ifndef IS_LEAP_YEAR
-#define IS_LEAP_YEAR(year) \
-    (((year) % 4 == 0) && (((year) % 100 != 0) || ((year) % 400 == 0)))
-#endif
-/* The lowest two bytes indicate minutes of the time zone */
-#ifndef OFFSET_TO_MINUTE
-#define OFFSET_TO_MINUTE(time) (((time) < 0) ? (-(time)) : (time))
-#endif
-/* The highest 31 bytes, 1 indicates eastern time zone? indicates western time zone */
-#ifndef TIME_ZONE_SIGN
-#define TIME_ZONE_SIGN(time) ((time) >> 31)
-#endif
-
-#define DIV(a, b) (((a) / (b)) - ((a) % (b) < 0))
-#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))
-
-/* internal functions */
-STATIC INLINE BOOL ValidTimeSpec(const struct timespec *tp)
-{
-    /* Fail a NULL pointer */
-    if (tp == NULL) {
-        return FALSE;
-    }
-
-    /* Fail illegal nanosecond values */
-    if ((tp->tv_nsec < 0) || (tp->tv_nsec >= OS_SYS_NS_PER_SECOND) || (tp->tv_sec < 0)) {
-        return FALSE;
-    }
-
-    return TRUE;
-}
-
-STATIC INLINE UINT32 OsTimeSpec2Tick(const struct timespec *tp)
-{
-    UINT64 tick, ns;
-
-    ns = (UINT64)tp->tv_sec * OS_SYS_NS_PER_SECOND + tp->tv_nsec;
-    /* Round up for ticks */
-    tick = (ns * LOSCFG_BASE_CORE_TICK_PER_SECOND + (OS_SYS_NS_PER_SECOND - 1)) / OS_SYS_NS_PER_SECOND;
-    if (tick > LOS_WAIT_FOREVER) {
-        tick = LOS_WAIT_FOREVER;
-    }
-    return (UINT32)tick;
-}
-
-STATIC INLINE VOID OsTick2TimeSpec(struct timespec *tp, UINT32 tick)
-{
-    UINT64 ns = ((UINT64)tick * OS_SYS_NS_PER_SECOND) / LOSCFG_BASE_CORE_TICK_PER_SECOND;
-    tp->tv_sec = (time_t)(ns / OS_SYS_NS_PER_SECOND);
-    tp->tv_nsec = (long)(ns % OS_SYS_NS_PER_SECOND);
-}
-#endif
-
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _TIME_IMPL_H
+#define _TIME_IMPL_H
+
+#include <time.h>
+#include <sys/time.h>
+#include <stdint.h>
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+#include "los_debug.h"
+#include "los_task.h"
+#include "los_swtmr.h"
+#include "los_timer.h"
+#include "los_context.h"
+#include "los_compiler.h"
+
+#define OS_SYS_NS_PER_US 1000
+#define OS_SYS_NS_PER_SECOND 1000000000
+#define OS_SYS_US_PER_SECOND 1000000
+#define OS_SYS_MS_PER_SECOND 1000
+
+#define TM_YEAR_BASE         1900
+#define EPOCH_YEAR           1970
+#define SECS_PER_MIN         60
+#define MINS_PER_HOUR        60
+#define SECS_PER_HOUR        3600  /* 60 * 60 */
+#define SECS_PER_DAY         86400 /* 60 * 60 * 24 */
+#define SECS_PER_NORMAL_YEAR 31536000 /* 60 * 60 * 24 * 365 */
+#define DAYS_PER_WEEK        7
+#define DAYS_PER_NORMAL_YEAR 365
+#define DAYS_PER_LEAP_YEAR   366
+#define BEGIN_WEEKDAY        4
+#define TIME_ZONE_MAX        720 /* UTC-12:00 , the last time zone */
+#define TIME_ZONE_MIN        (-840) /* UTC+14:00 , the first time zone */
+
+/*
+ * Nonzero if YEAR is a leap year (every 4 years,
+ * except every 100th isn't, and every 400th is).
+ */
+#ifndef IS_LEAP_YEAR
+#define IS_LEAP_YEAR(year) \
+    (((year) % 4 == 0) && (((year) % 100 != 0) || ((year) % 400 == 0)))
+#endif
+
+#define DIV(a, b) (((a) / (b)) - ((a) % (b) < 0))
+#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))
+
+/* internal functions */
+STATIC INLINE BOOL ValidTimeSpec(const struct timespec *tp)
+{
+    /* Fail a NULL pointer */
+    if (tp == NULL) {
+        return FALSE;
+    }
+
+    /* Fail illegal nanosecond values */
+    if ((tp->tv_nsec < 0) || (tp->tv_nsec >= OS_SYS_NS_PER_SECOND) || (tp->tv_sec < 0)) {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+STATIC INLINE UINT32 OsTimeSpec2Tick(const struct timespec *tp)
+{
+    UINT64 tick, ns;
+
+    ns = (UINT64)tp->tv_sec * OS_SYS_NS_PER_SECOND + tp->tv_nsec;
+    /* Round up for ticks */
+    tick = (ns * LOSCFG_BASE_CORE_TICK_PER_SECOND + (OS_SYS_NS_PER_SECOND - 1)) / OS_SYS_NS_PER_SECOND;
+    if (tick > LOS_WAIT_FOREVER) {
+        tick = LOS_WAIT_FOREVER;
+    }
+    return (UINT32)tick;
+}
+
+STATIC INLINE VOID OsTick2TimeSpec(struct timespec *tp, UINT32 tick)
+{
+    UINT64 ns = ((UINT64)tick * OS_SYS_NS_PER_SECOND) / LOSCFG_BASE_CORE_TICK_PER_SECOND;
+    tp->tv_sec = (time_t)(ns / OS_SYS_NS_PER_SECOND);
+    tp->tv_nsec = (long)(ns % OS_SYS_NS_PER_SECOND);
+}
+#endif
+
diff --git a/kernel/liteos_m/kernel/BUILD.gn b/kernel/liteos_m/kernel/BUILD.gn
index 1853f63..a18dfa0 100644
--- a/kernel/liteos_m/kernel/BUILD.gn
+++ b/kernel/liteos_m/kernel/BUILD.gn
@@ -1,66 +1,70 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-static_library("kernel") {
-  sources = [
-    "src/los_event.c",
-    "src/los_init.c",
-    "src/los_mux.c",
-    "src/los_queue.c",
-    "src/los_sem.c",
-    "src/los_swtmr.c",
-    "src/los_task.c",
-    "src/los_tick.c",
-    "src/mm/los_membox.c",
-    "src/mm/los_memory.c",
-  ]
-
-  include_dirs = [
-    "include",
-    "arch/include",
-    "../components/cpup",
-    "../components/exchook",
-    "../utils",
-    "//third_party/bounds_checking_function/include",
-  ]
-
-  if ("$board_cpu" == "cortex-m3") {
-    deps = [ "arch/arm/cortex-m3/gcc/:arch" ]
-  } else if ("$board_cpu" == "cortex-m4") {
-    deps = [ "arch/arm/cortex-m4/gcc/:arch" ]
-  } else if ("$board_cpu" == "cortex-m7") {
-    deps = [ "arch/arm/cortex-m7/gcc/:arch" ]
-  } else if ("$board_cpu" == "cortex-m33") {
-    deps = [ "arch/arm/cortex-m33/gcc/:arch" ]
-  } else if ("$board_cpu" == "") {
-    if ("$board_arch" == "rv32imac" || "$board_arch" == "rv32imafdc") {
-      deps = [ "arch/risc-v/riscv32/gcc:arch" ]
-    }
-  }
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("kernel") {
+  sources = [
+    "src/los_event.c",
+    "src/los_init.c",
+    "src/los_mux.c",
+    "src/los_queue.c",
+    "src/los_sem.c",
+    "src/los_swtmr.c",
+    "src/los_task.c",
+    "src/los_tick.c",
+    "src/los_sched.c",
+    "src/los_sortlink.c",
+    "src/mm/los_membox.c",
+    "src/mm/los_memory.c",
+  ]
+
+  include_dirs = [
+    "include",
+    "arch/include",
+    "../components/cpup",
+    "../components/exchook",
+    "../components/backtrace",
+    "../components/power",
+    "../utils",
+    "//third_party/bounds_checking_function/include",
+  ]
+
+  if ("$board_cpu" == "cortex-m3") {
+    deps = [ "arch/arm/cortex-m3/gcc/:arch" ]
+  } else if ("$board_cpu" == "cortex-m4") {
+    deps = [ "arch/arm/cortex-m4/gcc/:arch" ]
+  } else if ("$board_cpu" == "cortex-m7") {
+    deps = [ "arch/arm/cortex-m7/gcc/:arch" ]
+  } else if ("$board_cpu" == "cortex-m33") {
+    deps = [ "arch/arm/cortex-m33/gcc/:arch" ]
+  } else if ("$board_cpu" == "") {
+    if ("$board_arch" == "rv32imac" || "$board_arch" == "rv32imafdc") {
+      deps = [ "arch/risc-v/riscv32/gcc:arch" ]
+    }
+  }
+}
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/BUILD.gn b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/BUILD.gn
new file mode 100644
index 0000000..9f6bf09
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/BUILD.gn
@@ -0,0 +1,46 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("arch") {
+  sources = [
+    "los_context.c",
+    "los_dispatch.S",
+    "los_exc.S",
+    "los_interrupt.c",
+    "los_timer.c",
+    "reset_vector.S",
+  ]
+
+  include_dirs = [
+    "../../../../../kernel/arch/include",
+    "../../../../../kernel/include",
+    "../../../../../utils",
+    "//third_party/bounds_checking_function/include",
+  ]
+}
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_atomic.h b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_atomic.h
new file mode 100644
index 0000000..19a6a1a
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_atomic.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_ARCH_ATOMIC_H
+#define _LOS_ARCH_ATOMIC_H
+
+#include "los_compiler.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/**
+ * @ingroup  los_arch_atomic
+ * @brief Atomic exchange for 32-bit variable.
+ *
+ * @par Description:
+ * This API is used to implement the atomic exchange for 32-bit variable and return the previous value of the atomic variable.
+ * @attention
+ * <ul>The pointer v must not be NULL.</ul>
+ *
+ * @param  v       [IN] The variable pointer.
+ * @param  val       [IN] The exchange value.
+ *
+ * @retval #INT32       The previous value of the atomic variable
+ * @par Dependency:
+ * <ul><li>los_arch_atomic.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+STATIC INLINE INT32 HalAtomicXchg32bits(volatile INT32 *v, INT32 val)
+{
+    return -1;
+}
+
+/**
+ * @ingroup  los_arch_atomic
+ * @brief Atomic auto-decrement.
+ *
+ * @par Description:
+ * This API is used to implement the atomic auto-decrement and return the result of auto-decrement.
+ * @attention
+ * <ul>
+ * <li>The pointer v must not be NULL.</li>
+ * <li>The value which v point to must not be INT_MIN to avoid overflow after reducing 1.</li>
+ * </ul>
+ *
+ * @param  v      [IN] The addSelf variable pointer.
+ *
+ * @retval #INT32  The return value of variable auto-decrement.
+ * @par Dependency:
+ * <ul><li>los_arch_atomic.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+STATIC INLINE INT32 HalAtomicDecRet(volatile INT32 *v)
+{
+    return -1;
+}
+
+/**
+ * @ingroup  los_arch_atomic
+ * @brief Atomic exchange for 32-bit variable with compare.
+ *
+ * @par Description:
+ * This API is used to implement the atomic exchange for 32-bit variable, if the value of variable is equal to oldVal.
+ * @attention
+ * <ul>The pointer v must not be NULL.</ul>
+ *
+ * @param  v       [IN] The variable pointer.
+ * @param  val     [IN] The new value.
+ * @param  oldVal      [IN] The old value.
+ *
+ * @retval TRUE  The previous value of the atomic variable is not equal to oldVal.
+ * @retval FALSE The previous value of the atomic variable is equal to oldVal.
+ * @par Dependency:
+ * <ul><li>los_arch_atomic.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+STATIC INLINE BOOL HalAtomicCmpXchg32bits(volatile INT32 *v, INT32 val, INT32 oldVal)
+{
+    return FALSE;
+}
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_ARCH_ATOMIC_H */
+
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_context.h b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_context.h
new file mode 100644
index 0000000..661706e
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_context.h
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_ARCH_CONTEXT_H
+#define _LOS_ARCH_CONTEXT_H
+
+#include "los_config.h"
+#include "los_compiler.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define PSR_T_ARM      0x00000000U
+#define PSR_T_THUMB    0x00000020U
+#define PSR_MODE_SVC   0x00000013U
+#define PSR_MODE_SYS   0x0000001FU
+
+#define PSR_MODE_SVC_THUMB  (PSR_MODE_SVC | PSR_T_THUMB)
+#define PSR_MODE_SVC_ARM    (PSR_MODE_SVC | PSR_T_ARM)
+
+#define PSR_MODE_SYS_THUMB  (PSR_MODE_SYS | PSR_T_THUMB)
+#define PSR_MODE_SYS_ARM    (PSR_MODE_SYS | PSR_T_ARM)
+
+VOID OsTaskEntryArm(VOID);
+VOID OsTaskEntryThumb(VOID);
+
+typedef struct TagTskContext {
+    UINT32 spsr;
+    UINT32 r0;
+    UINT32 r1;
+    UINT32 r2;
+    UINT32 r3;
+    UINT32 r4;
+    UINT32 r5;
+    UINT32 r6;
+    UINT32 r7;
+    UINT32 r8;
+    UINT32 r9;
+    UINT32 r10;
+    UINT32 r11;
+    UINT32 r12;
+    UINT32 sp;
+    UINT32 lr;
+    UINT32 pc;
+} TaskContext;
+
+/**
+ * @ingroup  los_config
+ * @brief: Task start running function.
+ *
+ * @par Description:
+ * This API is used to start a task.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param: None.
+ *
+ * @retval None.
+ *
+ * @par Dependency:
+ * <ul><li>los_config.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern VOID HalStartToRun(VOID);
+
+/**
+ * @ingroup los_arch_context
+ * @brief Wait for interrupt.
+ *
+ * @par Description:
+ * <ul>
+ * <li>This API is used to suspend execution until interrupt or a debug request occurs.</li>
+ * </ul>
+ * @attention None.
+ *
+ * @param None.
+ *
+ * @retval: None.
+ *
+ * @par Dependency:
+ * los_arch_context.h: the header file that contains the API declaration.
+ * @see None.
+ */
+extern VOID wfi(VOID);
+
+/**
+ * @ingroup los_arch_context
+ * @brief: mem fence function.
+ *
+ * @par Description:
+ * This API is used to fence for memory.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param: None.
+ *
+ * @retval:None.
+ * @par Dependency:
+ * <ul><li>los_arch_context.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern VOID dmb(VOID);
+
+/**
+ * @ingroup los_arch_context
+ * @brief: mem fence function.
+ *
+ * @par Description:
+ * This API is same as dmb, it just for adaptation.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param: None.
+ *
+ * @retval:None.
+ * @par Dependency:
+ * <ul><li>los_arch_context.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern VOID dsb(VOID);
+
+/**
+ * @ingroup los_arch_context
+ * @brief: instruction fence function.
+ *
+ * @par Description:
+ * This API is used to fence for instruction.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param: None.
+ *
+ * @retval:None.
+ * @par Dependency:
+ * <ul><li>los_arch_context.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern VOID isb(VOID);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_ARCH_CONTEXT_H */
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_interrupt.h b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_interrupt.h
new file mode 100644
index 0000000..9ce2188
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_interrupt.h
@@ -0,0 +1,353 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_ARCH_INTERRUPT_H
+#define _LOS_ARCH_INTERRUPT_H
+
+#include "los_config.h"
+#include "los_compiler.h"
+#include "los_interrupt.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Maximum number of used hardware interrupts.
+ */
+#ifndef OS_HWI_MAX_NUM
+#define OS_HWI_MAX_NUM                        LOSCFG_PLATFORM_HWI_LIMIT
+#endif
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Highest priority of a hardware interrupt.
+ */
+#ifndef OS_HWI_PRIO_HIGHEST
+#define OS_HWI_PRIO_HIGHEST                   0
+#endif
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Lowest priority of a hardware interrupt.
+ */
+#ifndef OS_HWI_PRIO_LOWEST
+#define OS_HWI_PRIO_LOWEST                    7
+#endif
+
+
+/* *
+ * @ingroup  los_arch_interrupt
+ * Define the type of a hardware interrupt vector table function.
+ */
+typedef VOID (**HWI_VECTOR_FUNC)(void);
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Count of interrupts.
+ */
+extern UINT32 g_intCount;
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Count of arm9 system interrupt vector.
+ */
+#define OS_SYS_VECTOR_CNT                     0
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Count of arm9 interrupt vector.
+ */
+#define OS_VECTOR_CNT                         (OS_SYS_VECTOR_CNT + OS_HWI_MAX_NUM)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Invalid interrupt number.
+ *
+ * Value: 0x02000900
+ *
+ * Solution: Ensure that the interrupt number is valid. The value range of the interrupt number applicable for a Cortex-A7 platform is [OS_USER_HWI_MIN,OS_USER_HWI_MAX].
+ */
+#define OS_ERRNO_HWI_NUM_INVALID              LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x00)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Null hardware interrupt handling function.
+ *
+ * Value: 0x02000901
+ *
+ * Solution: Pass in a valid non-null hardware interrupt handling function.
+ */
+#define OS_ERRNO_HWI_PROC_FUNC_NULL           LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x01)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Insufficient interrupt resources for hardware interrupt creation.
+ *
+ * Value: 0x02000902
+ *
+ * Solution: Increase the configured maximum number of supported hardware interrupts.
+ */
+#define OS_ERRNO_HWI_CB_UNAVAILABLE           LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x02)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Insufficient memory for hardware interrupt initialization.
+ *
+ * Value: 0x02000903
+ *
+ * Solution: Expand the configured memory.
+ */
+#define OS_ERRNO_HWI_NO_MEMORY                LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x03)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: The interrupt has already been created.
+ *
+ * Value: 0x02000904
+ *
+ * Solution: Check whether the interrupt specified by the passed-in interrupt number has already been created.
+ */
+#define OS_ERRNO_HWI_ALREADY_CREATED          LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x04)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Invalid interrupt priority.
+ *
+ * Value: 0x02000905
+ *
+ * Solution: Ensure that the interrupt priority is valid. The value range of the interrupt priority applicable for a Cortex-A7 platform is [0,15].
+ */
+#define OS_ERRNO_HWI_PRIO_INVALID             LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x05)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: Incorrect interrupt creation mode.
+ *
+ * Value: 0x02000906
+ *
+ * Solution: The interrupt creation mode can be only set to OS_HWI_MODE_COMM or OS_HWI_MODE_FAST of which the value can be 0 or 1.
+ */
+#define OS_ERRNO_HWI_MODE_INVALID             LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x06)
+
+/* *
+ * @ingroup los_arch_interrupt
+ * Hardware interrupt error code: The interrupt has already been created as a fast interrupt.
+ *
+ * Value: 0x02000907
+ *
+ * Solution: Check whether the interrupt specified by the passed-in interrupt number has already been created.
+ */
+#define OS_ERRNO_HWI_FASTMODE_ALREADY_CREATED LOS_ERRNO_OS_ERROR(LOS_MOD_HWI, 0x07)
+
+#if (OS_HWI_WITH_ARG == 1)
+/* *
+ * @ingroup los_hwi
+ * Set interrupt vector table.
+ */
+extern VOID OsSetVector(UINT32 num, HWI_PROC_FUNC vector, VOID *arg);
+#else
+/* *
+ * @ingroup los_hwi
+ * Set interrupt vector table.
+ */
+extern VOID OsSetVector(UINT32 num, HWI_PROC_FUNC vector);
+#endif
+
+/* *
+ * @ingroup  los_arch_interrupt
+ * @brief: Hardware interrupt entry function.
+ *
+ * @par Description:
+ * This API is used as all hardware interrupt handling function entry.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param:None.
+ *
+ * @retval:None.
+ * @par Dependency:
+ * <ul><li>los_arch_interrupt.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern VOID HalFiqInterrupt(VOID);
+extern VOID HalIrqInterrupt(VOID);
+
+/* *
+ * @ingroup  los_arch_interrupt
+ * @brief: Get an interrupt number.
+ *
+ * @par Description:
+ * This API is used to get the current interrupt number.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param: None.
+ *
+ * @retval: Interrupt Indexes number.
+ * @par Dependency:
+ * <ul><li>los_arch_interrupt.h: the header file that contains the API declaration.</li></ul>
+ * @see None.
+ */
+extern UINT32 HalIntNumGet(VOID);
+
+/* *
+ * @ingroup  los_arch_interrupt
+ * @brief: Default vector handling function.
+ *
+ * @par Description:
+ * This API is used to configure interrupt for null function.
+ *
+ * @attention:
+ * <ul><li>None.</li></ul>
+ *
+ * @param:None.
+ *
+ * @retval:None.
+ * @par Dependency:
+ * <ul><li>los_arch_interrupt.h: the header file that contains the API declaration.</li
+></ul>
+ * @see None.
+ */
+extern VOID HalHwiDefaultHandler(VOID);
+
+#define OS_EXC_IN_INIT                      0
+#define OS_EXC_IN_TASK                      1
+#define OS_EXC_IN_HWI                       2
+
+#define OS_EXC_FLAG_FAULTADDR_VALID         0x01
+#define OS_EXC_FLAG_IN_HWI                  0x02
+
+#define OS_EXC_IMPRECISE_ACCESS_ADDR        0xABABABAB
+
+/**
+ * @ingroup los_exc
+ * the struct of register files
+ *
+ * description: the register files that saved when exception triggered
+ *
+ * notes:the following register with prefix 'uw'  correspond to the registers in the cpu  data sheet.
+ */
+typedef struct TagExcContext {
+    UINT32 spsr;
+    UINT32 r0;
+    UINT32 r1;
+    UINT32 r2;
+    UINT32 r3;
+    UINT32 r4;
+    UINT32 r5;
+    UINT32 r6;
+    UINT32 r7;
+    UINT32 r8;
+    UINT32 r9;
+    UINT32 r10;
+    UINT32 r11;
+    UINT32 r12;
+    UINT32 sp;
+    UINT32 lr;
+    UINT32 pc;
+} EXC_CONTEXT_S;
+
+typedef VOID (*EXC_PROC_FUNC)(UINT32, EXC_CONTEXT_S *);
+VOID HalExcHandleEntry(UINT32 excType, UINT32 faultAddr, UINT32 pid, EXC_CONTEXT_S *excBufAddr);
+VOID HalHwiInit();
+
+/**
+ * @ingroup los_exc
+ * exception types: undefined instruction exception.
+ */
+#define OS_EXCEPT_UNDEF_INSTR           1
+
+/**
+ * @ingroup los_exc
+ * exception types: software interrupt.
+ */
+#define OS_EXCEPT_SWI                   2
+
+/**
+ * @ingroup los_exc
+ * exception types: prefetch abort exception.
+ */
+#define OS_EXCEPT_PREFETCH_ABORT        3
+
+/**
+ * @ingroup los_exc
+ * exception types: data abort exception.
+ */
+#define OS_EXCEPT_DATA_ABORT            4
+
+/**
+ * @ingroup los_exc
+ * exception types: FIQ exception.
+ */
+#define OS_EXCEPT_FIQ                   5
+
+/**
+ * @ingroup los_exc
+ * Exception information structure
+ *
+ * Description: Exception information saved when an exception is triggered on the Cortex-M4 platform.
+ *
+ */
+typedef struct TagExcInfo {
+    /**< Exception occurrence phase: 0 means that an exception occurs in initialization, 1 means that an exception occurs in a task, and 2 means that an exception occurs in an interrupt */
+    UINT16 phase;
+    /**< Exception type. When exceptions occur, check the numbers 1 - 19 listed above */
+    UINT16 type;
+    /**< If the exact address access error indicates the wrong access address when the exception occurred */
+    UINT32 faultAddr;
+    /**< An exception occurs in an interrupt, indicating the interrupt number. An exception occurs in the task, indicating the task ID, or 0xFFFFFFFF if it occurs during initialization */
+    UINT32 thrdPid;
+    /**< Number of nested exceptions. Currently only registered hook functions are supported when an exception is entered for the first time */
+    UINT16 nestCnt;
+    /**< reserve */
+    UINT16 reserved;
+    /**< Hardware context at the time an exception to the automatic stack floating-point register occurs */
+    EXC_CONTEXT_S *context;
+} ExcInfo;
+
+extern UINT32 g_intCount;
+extern ExcInfo g_excInfo;
+
+#define MAX_INT_INFO_SIZE       (8 + 0x164)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_ARCH_INTERRUPT_H */
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_timer.h b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_timer.h
new file mode 100644
index 0000000..ba54bc1
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_arch_timer.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_ARCH_TIMER_H
+#define _LOS_ARCH_TIMER_H
+
+#include "los_config.h"
+#include "los_compiler.h"
+#include "los_context.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+UINT32 HalTickStart(OS_TICK_HANDLER handler);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_ARCH_TIMER_H */
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_context.c b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_context.c
new file mode 100644
index 0000000..97c0986
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_context.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_context.h"
+#include "securec.h"
+#include "los_arch_context.h"
+#include "los_arch_interrupt.h"
+#include "los_task.h"
+#include "los_sched.h"
+#include "los_interrupt.h"
+#include "los_arch_timer.h"
+#include "los_debug.h"
+
+/* ****************************************************************************
+ Function    : HalArchInit
+ Description : arch init function
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_INIT VOID HalArchInit()
+{
+    HalHwiInit();
+}
+
+/* ****************************************************************************
+ Function    : HalSysExit
+ Description : Task exit function
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_MINOR VOID HalSysExit(VOID)
+{
+    LOS_IntLock();
+    while (1) {
+    }
+}
+
+/* ****************************************************************************
+ Function    : HalTskStackInit
+ Description : Task stack initialization function
+ Input       : taskID     --- TaskID
+               stackSize  --- Total size of the stack
+               topStack    --- Top of task's stack
+ Output      : None
+ Return      : Context pointer
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_INIT VOID *HalTskStackInit(UINT32 taskID, UINT32 stackSize, VOID *topStack)
+{
+    TaskContext *context = NULL;
+    LosTaskCB *taskCB = OS_TCB_FROM_TID(taskID);
+    errno_t result;
+
+    /* initialize the task stack, write magic num to stack top */
+    result = memset_s(topStack, stackSize, (INT32)(OS_TASK_STACK_INIT & 0xFF), stackSize);
+    if (result != EOK) {
+        PRINT_ERR("memset_s is failed:%s[%d]\r\n", __FUNCTION__, __LINE__);
+    }
+    *((UINT32 *)(topStack)) = OS_TASK_MAGIC_WORD;
+
+    context = (TaskContext *)(((UINTPTR)topStack + stackSize) - sizeof(TaskContext));
+
+    context->r0 = taskID;
+    context->r1 = 0x01010101L;
+    context->r2 = 0x02020202L;
+    context->r3 = 0x03030303L;
+    context->r4 = 0x04040404L;
+    context->r5 = 0x05050505L;
+    context->r6 = 0x06060606L;
+    context->r7 = 0x07070707L;
+    context->r8 = 0x08080808L;
+    context->r9 = 0x09090909L;
+    context->r10 = 0x10101010L;
+    context->r11 = 0x11111111L;
+    context->r12 = 0x12121212L;
+    context->sp = (UINTPTR)topStack + stackSize;
+    context->lr = (UINTPTR)HalSysExit;
+
+    if ((UINTPTR)taskCB->taskEntry & 0x01) {
+        context->pc = (UINTPTR)OsTaskEntryThumb;
+        context->spsr = PSR_MODE_SYS_THUMB; /* thumb mode */
+    } else {
+        context->pc = (UINTPTR)OsTaskEntryArm;
+        context->spsr = PSR_MODE_SYS_ARM;   /* arm mode */
+    }
+
+    return (VOID *)context;
+}
+
+LITE_OS_SEC_TEXT_INIT UINT32 HalStartSchedule(OS_TICK_HANDLER handler)
+{
+    (VOID)LOS_IntLock();
+    UINT32 ret = HalTickStart(handler);
+    if (ret != LOS_OK) {
+        return ret;
+    }
+
+    OsSchedStart();
+    HalStartToRun();
+
+    return LOS_OK; /* never return */
+}
+
+LITE_OS_SEC_TEXT_INIT VOID HalTaskSchedule(VOID)
+{
+	GLOBAL_INT_DECLARATION();
+
+	GLOBAL_INT_DISABLE();
+    __asm__ __volatile__("swi 0");
+	GLOBAL_INT_RESTORE();
+}
+
+LITE_OS_SEC_TEXT_INIT VOID dmb(VOID)
+{
+    __asm__ __volatile__("" : : : "memory");
+}
+
+LITE_OS_SEC_TEXT_INIT VOID dsb(VOID)
+{
+    __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 4" : : "r"(0) : "memory");
+}
+
+LITE_OS_SEC_TEXT_INIT VOID isb(VOID)
+{
+    __asm__ __volatile__("" : : : "memory");
+}
+
+LITE_OS_SEC_TEXT_INIT VOID wfi(VOID)
+{
+    __asm__ __volatile__("mcr p15, 0, %0, c7, c0, 4" : : "r"(0) : "memory");
+}
+
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_dispatch.S b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_dispatch.S
new file mode 100644
index 0000000..bea3c3e
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_dispatch.S
@@ -0,0 +1,223 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+    .equ    OS_PSR_THUMB,       0x20
+    .equ    OS_PSR_INT_DIS,     0xC0
+    .equ    OS_PSR_FIQ_DIS,     0x40
+    .equ    OS_PSR_IRQ_DIS,     0x80
+    .equ    OS_PSR_MODE_MASK,   0x1F
+    .equ    OS_PSR_MODE_USR,    0x10
+    .equ    OS_PSR_MODE_FIQ,    0x11
+    .equ    OS_PSR_MODE_IRQ,    0x12
+    .equ    OS_PSR_MODE_SVC,    0x13
+    .equ    OS_PSR_MODE_ABT,    0x17
+    .equ    OS_PSR_MODE_UND,    0x1B
+    .equ    OS_PSR_MODE_SYS,    0x1F
+
+    .global HalStartToRun
+    .global OsTaskEntryArm
+    .global OsTaskEntryThumb
+    .global HalExceptSwiHdl
+    .global HalExceptFiqHdl
+    .global HalExceptIrqHdl
+    .global OsTryToSchedTaskSwitch
+    .global OsSetTryToTaskSwitch
+
+    .extern OsTaskEntry
+    .extern OsSchedTaskSwitch
+    .extern HalIrqInterrupt
+    .extern HalFiqInterrupt
+    .extern g_losTask
+
+    .code 32
+    .text
+
+.macro SAVE_CONTEXT
+	/* push r0 into current stack, and r0 will be used*/
+    STMFD   SP!, {R0}
+
+	/* disable irq and fiq*/
+    MRS     R0, CPSR
+    ORR     R0, R0, #OS_PSR_INT_DIS
+    MSR     CPSR, R0
+
+	/* check the previous arm mode*/
+    MRS     R0, SPSR
+    AND     R0, R0, #OS_PSR_MODE_SYS
+    CMP     R0, #OS_PSR_MODE_SYS
+    BNE     1f
+		
+	/* store the sp register of non-current arm mode 
+	 * into stack space of current mode*/
+    STMFD   SP, {SP}^
+    NOP
+    SUB     SP, SP, #4
+    LDMFD   SP!, {R0}
+
+    STMFD   R0!, {LR}
+    MOV     LR, R0
+    LDMFD   SP!, {R0}
+
+    STMFD   LR, {R0-R14}^
+	NOP
+	NOP
+    SUB     LR, LR, #60
+    MRS     R0, SPSR
+    STMFD   LR!, {R0}
+
+    LDR     R1, =g_losTask
+    LDR     R1, [R1]
+    STR     LR, [R1]
+    B       2f
+
+1:
+    LDMFD   SP!, {R0}
+    STMFD   SP!, {R0-R12, LR}
+	NOP
+	NOP
+    MRS     R0, SPSR
+    STMFD   SP!, {R0}
+
+2:
+.endm
+
+.macro RESTORE_CONTEXT
+    MRS     R0, SPSR
+    AND     R0, R0, #OS_PSR_MODE_SYS
+    CMP     R0, #OS_PSR_MODE_SYS
+    BNE     3f
+
+    LDR     R1, =g_losTask
+    LDR     R1, [R1]
+    LDR     LR, [R1]
+
+    LDMFD   LR!, {R0}
+    MSR     SPSR_cxsf, R0
+    LDMFD   LR, {R0-R14}^
+    NOP
+    NOP
+    ADD     LR, LR, #60
+    LDMFD   LR!, {PC}^
+3:
+    LDMFD   SP!, {R0}
+    MSR     SPSR_cxsf, R0
+    LDMFD   SP!, {R0-R12, LR}
+	NOP
+	NOP
+    MOVS    PC, LR
+.endm
+
+.macro SWI_TASK_SWITCH	
+    MRS     R0, SPSR
+    AND     R0, R0, #OS_PSR_MODE_SYS
+    CMP     R0, #OS_PSR_MODE_SYS
+    BNE     33f
+    
+    BLX     OsSchedTaskSwitch
+    CMP     R0, #0
+    BEQ     44f
+
+    LDR     R0, =g_losTask
+    LDR     R1, [R0, #4]
+    STR     R1, [R0]
+    B      44f
+    
+33:
+	BLX     OsSetTryToTaskSwitch
+44:
+.endm
+	
+	
+.macro INT_TASK_SWITCH	
+	MRS 	R0, SPSR
+	AND 	R0, R0, #OS_PSR_MODE_SYS
+	CMP 	R0, #OS_PSR_MODE_SYS
+	BNE 	88f
+	
+	BLX 	OsTryToSchedTaskSwitch
+	CMP 	R0, #0
+	BEQ 	88f
+
+	LDR 	R0, =g_losTask
+	LDR 	R1, [R0, #4]
+	STR 	R1, [R0]
+	
+88:
+.endm
+
+HalStartToRun:
+    LDR     R1, =g_losTask
+    LDR     R0, [R1, #4]
+    LDR     LR, [R0]
+
+    LDMFD   LR!, {R0}
+    MSR     SPSR_cxsf, R0
+
+    LDMFD   LR, {R0-R14}^
+    ADD     LR, LR, #60
+    LDMFD   LR!, {PC}^
+
+HalExceptSwiHdl:
+    SAVE_CONTEXT
+    SWI_TASK_SWITCH
+    RESTORE_CONTEXT
+
+HalExceptFiqHdl:
+    SUB     LR, LR, #4
+		
+    SAVE_CONTEXT
+    BLX     HalFiqInterrupt
+    INT_TASK_SWITCH
+    RESTORE_CONTEXT
+
+HalExceptIrqHdl:
+    SUB     LR, LR, #4
+
+    SAVE_CONTEXT
+    BLX     HalIrqInterrupt
+    INT_TASK_SWITCH
+    RESTORE_CONTEXT
+
+OsTaskEntryArm:
+    STMFD   SP!, {LR}
+    BL      OsTaskEntry
+    LDMFD   SP!, {LR}
+    BX      LR
+
+    .code 16
+    .text
+OsTaskEntryThumb:
+    PUSH    {LR}
+    BL      OsTaskEntry
+    POP     {R0}
+    MOV     LR, R0
+    BX      LR
+
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_exc.S b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_exc.S
new file mode 100644
index 0000000..d29e456
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_exc.S
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+	.equ OS_PSR_INT_DIS,            0xC0
+	.equ OS_PSR_FIQ_DIS,            0x40
+	.equ OS_PSR_IRQ_DIS,            0x80
+	.equ OS_PSR_MODE_MASK,          0x1F
+	.equ OS_PSR_MODE_USR,           0x10
+	.equ OS_PSR_MODE_FIQ,           0x11
+	.equ OS_PSR_MODE_IRQ,           0x12
+	.equ OS_PSR_MODE_SVC,           0x13
+	.equ OS_PSR_MODE_ABT,           0x17
+	.equ OS_PSR_MODE_UND,           0x1B
+	.equ OS_PSR_MODE_SYS,           0x1F
+
+	.equ OS_EXCEPT_RESET,           0x00
+	.equ OS_EXCEPT_UNDEF_INSTR,     0x01
+	.equ OS_EXCEPT_SWI,             0x02
+	.equ OS_EXCEPT_PREFETCH_ABORT,  0x03
+	.equ OS_EXCEPT_DATA_ABORT,      0x04
+	.equ OS_EXCEPT_FIQ,             0x05
+	.equ OS_EXCEPT_ADDR_ABORT,      0x06
+	.equ OS_EXCEPT_IRQ,             0x07
+
+	.global HalExceptAddrAbortHdl
+	.global HalExceptDataAbortHdl
+	.global HalExceptPrefetchAbortHdl
+	.global HalExceptUndefInstrHdl
+
+	.extern HalExcHandleEntry
+	.extern __exc_stack_top
+
+	.code 32
+	.text
+
+HalExceptUndefInstrHdl:
+    STMFD   SP!, {R0-R5}
+    MOV     R0, #OS_EXCEPT_UNDEF_INSTR
+    B       _osExceptDispatch
+
+HalExceptPrefetchAbortHdl:
+    SUB     LR, LR, #4
+    STMFD   SP!, {R0-R5}
+
+    MOV     R0, #OS_EXCEPT_PREFETCH_ABORT
+
+    B       _osExceptDispatch
+
+HalExceptDataAbortHdl:
+    SUB     LR, LR, #4
+    STMFD   SP!, {R0-R5}
+
+    MOV     R0, #OS_EXCEPT_DATA_ABORT
+
+    B       _osExceptDispatch
+
+HalExceptAddrAbortHdl:
+    SUB     LR, LR, #8
+    STMFD   SP!, {R0-R5}
+
+    MOV     R0, #OS_EXCEPT_ADDR_ABORT
+
+    B       _osExceptDispatch
+
+_osExceptDispatch:
+    MRS     R1, SPSR
+    MOV     R2, LR
+    MOV     R4, SP
+    ADD     SP, SP, #(6 * 4)
+
+    MSR     CPSR_c, #(OS_PSR_INT_DIS | OS_PSR_MODE_SVC)
+    MOV     R3, SP
+    LDR     SP, =__exc_stack_top
+
+    STMFD   SP!, {R2}
+    STMFD   SP!, {LR}
+    STMFD   SP!, {R3}
+    STMFD   SP!, {R6-R12}
+    LDMFD   R4!, {R6-R12}
+    STMFD   SP!, {R6-R11}
+    STMFD   SP!, {R1}
+    MOV     R3, SP
+
+_osExceptionGetSP:
+    STMFD   SP!, {R1}
+    LDR     R2, =HalExcHandleEntry
+
+    MOV     LR, PC
+    BX      R2
+
+    LDMFD   SP!, {R1}
+    MOV     SP, R1
+
+    LDMFD   SP!, {R1}
+    MSR     CPSR, R1
+    LDMFD   SP!, {R0-R12}
+    ADD     SP, SP, #(4 * 2)
+    LDMFD   SP!, {LR}
+    SUB     SP, SP, #(4 * 3)
+    LDMFD   SP, {SP}
+    ADD     LR, LR, #4
+    MOV     PC, LR
+
+    .end
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_interrupt.c b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_interrupt.c
new file mode 100644
index 0000000..61cede4
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_interrupt.c
@@ -0,0 +1,483 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "los_interrupt.h"
+#include <stdarg.h>
+#include "securec.h"
+#include "los_context.h"
+#include "los_arch_interrupt.h"
+#include "los_debug.h"
+#include "los_hook.h"
+#include "los_task.h"
+#include "los_sched.h"
+#include "los_memory.h"
+#include "los_membox.h"
+#include "los_reg.h"
+#include "intc_pub.h"
+
+#define OS_INT_IRQ_ENABLE           (1U << 0)
+#define OS_INT_FIQ_ENABLE           (1U << 1)
+#define OS_INT_REG_BASE             0x00802040UL
+#define OS_INT_GLOBAL_ENABLE_ADDR   (OS_INT_REG_BASE + 4)
+#define OS_INT_ENABLE_ADDR          (OS_INT_REG_BASE)
+#define OS_INT_STATUS_ADDR          (OS_INT_REG_BASE + 12)
+
+#define OS_INT_ENABLE(num)          (*((volatile UINT32 *)OS_INT_ENABLE_ADDR) |= (1U << (num)))
+#define OS_INT_DISABLE(num)         (*((volatile UINT32 *)OS_INT_ENABLE_ADDR ) &= ~(1U << (num)))
+
+#define OS_INSTR_SET_MASK           0x01000020U
+#define OS_ARM_INSTR_LEN            4
+#define OS_THUMB_INSTR_LEN          2
+
+UINT32 g_intCount = 0;
+ExcInfo g_excInfo = {0};
+
+extern void intc_irq(void);
+extern void intc_fiq(void);
+
+/* *
+ * @ingroup los_hwi
+ * hardware interrupt form mapping handling function array.
+ */
+STATIC HWI_PROC_FUNC g_hwiForm[OS_VECTOR_CNT] = {0};
+
+#if (OS_HWI_WITH_ARG == 1)
+
+typedef struct {
+    HWI_PROC_FUNC pfnHandler;
+    VOID *pParm;
+} HWI_HANDLER_FUNC;
+
+/* *
+ * @ingroup los_hwi
+ * hardware interrupt handler form mapping handling function array.
+ */
+STATIC HWI_HANDLER_FUNC g_hwiHandlerForm[OS_VECTOR_CNT] = {{ (HWI_PROC_FUNC)0, (HWI_ARG_T)0 }};
+
+/* *
+ * @ingroup los_hwi
+ * Set interrupt vector table.
+ */
+VOID OsSetVector(UINT32 num, HWI_PROC_FUNC vector, VOID *arg)
+{
+    if ((num + OS_SYS_VECTOR_CNT) < OS_VECTOR_CNT) {
+        g_hwiForm[num + OS_SYS_VECTOR_CNT] = (HWI_PROC_FUNC)HalInterrupt;
+        g_hwiHandlerForm[num + OS_SYS_VECTOR_CNT].pfnHandler = vector;
+        g_hwiHandlerForm[num + OS_SYS_VECTOR_CNT].pParm = arg;
+    }
+}
+
+#else
+/* *
+ * @ingroup los_hwi
+ * hardware interrupt handler form mapping handling function array.
+ */
+STATIC HWI_PROC_FUNC g_hwiHandlerForm[OS_VECTOR_CNT] = {0};
+
+/* *
+ * @ingroup los_hwi
+ * Set interrupt vector table.
+ */
+VOID OsSetVector(UINT32 num, HWI_PROC_FUNC vector)
+{
+    if ((num + OS_SYS_VECTOR_CNT) < OS_VECTOR_CNT) {
+        g_hwiForm[num + OS_SYS_VECTOR_CNT] = HalIrqInterrupt;
+        g_hwiHandlerForm[num + OS_SYS_VECTOR_CNT] = vector;
+    }
+}
+#endif
+
+
+/* ****************************************************************************
+ Function    : HalIntNumGet
+ Description : Get an interrupt number
+ Input       : None
+ Output      : None
+ Return      : Interrupt Indexes number
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_MINOR UINT32 HalIntNumGet(VOID)
+{
+    UINT32 status;
+
+    READ_UINT32(status, OS_INT_STATUS_ADDR);
+    return (31 - CLZ(status));
+}
+
+inline UINT32 HalIsIntActive(VOID)
+{
+    return (g_intCount > 0);
+}
+/* ****************************************************************************
+ Function    : HalHwiDefaultHandler
+ Description : default handler of the hardware interrupt
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+/*lint -e529*/
+LITE_OS_SEC_TEXT_MINOR VOID HalHwiDefaultHandler(VOID)
+{
+    UINT32 irqNum = HalIntNumGet();
+    PRINT_ERR("%s irqnum:%d\n", __FUNCTION__, irqNum);
+    while (1) {}
+}
+
+WEAK VOID HalPreInterruptHandler(UINT32 arg)
+{
+    return;
+}
+
+WEAK VOID HalAftInterruptHandler(UINT32 arg)
+{
+    return;
+}
+
+/* ****************************************************************************
+ Function    : HalInterrupt
+ Description : Hardware interrupt entry function
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+LITE_OS_SEC_TEXT VOID HalIrqInterrupt(VOID)
+{
+    UINT32 intSave;
+    UINT32 hwiIndex;
+
+    intSave = LOS_IntLock();
+    g_intCount++;
+    LOS_IntRestore(intSave);
+
+#if (LOSCFG_BASE_CORE_SCHED_SLEEP == 1)
+    OsSchedUpdateSleepTime();
+#endif
+
+    hwiIndex = HalIntNumGet();
+
+    OsHookCall(LOS_HOOK_TYPE_ISR_ENTER, hwiIndex);
+
+    HalPreInterruptHandler(hwiIndex);
+
+	intc_irq();
+	
+    HalAftInterruptHandler(hwiIndex);
+
+    OsHookCall(LOS_HOOK_TYPE_ISR_EXIT, hwiIndex);
+
+    intSave = LOS_IntLock();
+    g_intCount--;
+    LOS_IntRestore(intSave);
+}
+
+/* ****************************************************************************
+ Function    : HalInterrupt
+ Description : Hardware interrupt entry function
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+LITE_OS_SEC_TEXT VOID HalFiqInterrupt(VOID)
+{
+    UINT32 intSave;
+    UINT32 hwiIndex;
+
+    intSave = LOS_IntLock();
+    g_intCount++;
+    LOS_IntRestore(intSave);
+
+#if (LOSCFG_BASE_CORE_SCHED_SLEEP == 1)
+    OsSchedUpdateSleepTime();
+#endif
+
+    hwiIndex = HalIntNumGet();
+
+    OsHookCall(LOS_HOOK_TYPE_ISR_ENTER, hwiIndex);
+
+    HalPreInterruptHandler(hwiIndex);
+
+	intc_fiq();
+	
+    HalAftInterruptHandler(hwiIndex);
+
+    OsHookCall(LOS_HOOK_TYPE_ISR_EXIT, hwiIndex);
+
+    intSave = LOS_IntLock();
+    g_intCount--;
+    LOS_IntRestore(intSave);
+}
+
+/* ****************************************************************************
+ Function    : HalHwiCreate
+ Description : create hardware interrupt
+ Input       : hwiNum   --- hwi num to create
+               hwiPrio  --- priority of the hwi
+               mode     --- unused
+               handler --- hwi handler
+               arg      --- param of the hwi handler
+ Output      : None
+ Return      : LOS_OK on success or error code on failure
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_INIT UINT32 HalHwiCreate(HWI_HANDLE_T hwiNum,
+                                          HWI_PRIOR_T hwiPrio,
+                                          HWI_MODE_T mode,
+                                          HWI_PROC_FUNC handler,
+                                          HWI_ARG_T arg)
+{
+	bk_printf("HalHwiCreate TODO\r\n");
+	intc_service_register((UINT8)hwiNum, (UINT8)hwiPrio, (FUNCPTR)handler);
+    return LOS_OK;
+}
+										  
+LITE_OS_SEC_TEXT_INIT UINT32 HalHwiDelete(HWI_HANDLE_T hwiNum)
+{
+  bk_printf("HalHwiDelete TODO\r\n");
+  intc_service_unregister((UINT8)hwiNum);
+  return LOS_OK;
+}
+
+LITE_OS_SEC_TEXT_INIT UINT32 HalHwiTrigger(HWI_HANDLE_T hwiNum)
+{
+  bk_printf("HalHwiTrigger TODO\r\n");
+  intc_service_trigger((UINT8)hwiNum);
+  return LOS_OK;
+}
+
+#if (LOSCFG_KERNEL_PRINTF != 0)
+STATIC VOID OsExcTypeInfo(const ExcInfo *excInfo)
+{
+    CHAR *phaseStr[] = {"exc in init", "exc in task", "exc in hwi"};
+
+    PRINTK("Type      = %d\n", excInfo->type);
+    PRINTK("ThrdPid   = %d\n", excInfo->thrdPid);
+    PRINTK("Phase     = %s\n", phaseStr[excInfo->phase]);
+    PRINTK("FaultAddr = 0x%x\n", excInfo->faultAddr);
+}
+
+STATIC VOID OsExcCurTaskInfo(const ExcInfo *excInfo)
+{
+    PRINTK("Current task info:\n");
+    if (excInfo->phase == OS_EXC_IN_TASK) {
+        LosTaskCB *taskCB = OS_TCB_FROM_TID(LOS_CurTaskIDGet());
+        PRINTK("Task name = %s\n", taskCB->taskName);
+        PRINTK("Task ID   = %d\n", taskCB->taskID);
+        PRINTK("Task SP   = 0x%x\n", taskCB->stackPointer);
+        PRINTK("Task ST   = 0x%x\n", taskCB->topOfStack);
+        PRINTK("Task SS   = 0x%x\n", taskCB->stackSize);
+    } else if (excInfo->phase == OS_EXC_IN_HWI) {
+        PRINTK("Exception occur in interrupt phase!\n");
+    } else {
+        PRINTK("Exception occur in system init phase!\n");
+    }
+}
+
+STATIC VOID OsExcRegInfo(const ExcInfo *excInfo)
+{
+    PRINTK("Exception reg dump:\n");
+    PRINTK("PC        = 0x%x\n", excInfo->context->pc);
+    PRINTK("LR        = 0x%x\n", excInfo->context->lr);
+    PRINTK("R0        = 0x%x\n", excInfo->context->r0);
+    PRINTK("R1        = 0x%x\n", excInfo->context->r1);
+    PRINTK("R2        = 0x%x\n", excInfo->context->r2);
+    PRINTK("R3        = 0x%x\n", excInfo->context->r3);
+    PRINTK("R4        = 0x%x\n", excInfo->context->r4);
+    PRINTK("R5        = 0x%x\n", excInfo->context->r5);
+    PRINTK("R6        = 0x%x\n", excInfo->context->r6);
+    PRINTK("R7        = 0x%x\n", excInfo->context->r7);
+    PRINTK("R8        = 0x%x\n", excInfo->context->r8);
+    PRINTK("R9        = 0x%x\n", excInfo->context->r9);
+    PRINTK("R10       = 0x%x\n", excInfo->context->r10);
+    PRINTK("R11       = 0x%x\n", excInfo->context->r11);
+    PRINTK("R12       = 0x%x\n", excInfo->context->r12);
+    PRINTK("xPSR      = 0x%x\n", excInfo->context->spsr);
+}
+
+STATIC VOID OsExcBackTraceInfo(const ExcInfo *excInfo)
+{
+    UINTPTR LR[LOSCFG_BACKTRACE_DEPTH] = {0};
+    UINT32 index;
+
+    OsBackTraceHookCall(LR, LOSCFG_BACKTRACE_DEPTH, 0, excInfo->context->sp);
+
+    PRINTK("----- backtrace start -----\n");
+    for (index = 0; index < LOSCFG_BACKTRACE_DEPTH; index++) {
+        if (LR[index] == 0) {
+            break;
+        }
+        PRINTK("backtrace %d -- lr = 0x%x\n", index, LR[index]);
+    }
+    PRINTK("----- backtrace end -----\n");
+}
+
+STATIC VOID OsExcMemPoolCheckInfo(VOID)
+{
+    PRINTK("\r\nmemory pools check:\n");
+#if (LOSCFG_PLATFORM_EXC == 1)
+    MemInfoCB memExcInfo[OS_SYS_MEM_NUM];
+    UINT32 errCnt;
+    UINT32 i;
+
+    (VOID)memset_s(memExcInfo, sizeof(memExcInfo), 0, sizeof(memExcInfo));
+
+    errCnt = OsMemExcInfoGet(OS_SYS_MEM_NUM, memExcInfo);
+    if (errCnt < OS_SYS_MEM_NUM) {
+        errCnt += OsMemboxExcInfoGet(OS_SYS_MEM_NUM - errCnt, memExcInfo + errCnt);
+    }
+
+    if (errCnt == 0) {
+        PRINTK("all memory pool check passed!\n");
+        return;
+    }
+
+    for (i = 0; i < errCnt; i++) {
+        PRINTK("pool num    = %d\n", i);
+        PRINTK("pool type   = %d\n", memExcInfo[i].type);
+        PRINTK("pool addr   = 0x%x\n", memExcInfo[i].startAddr);
+        PRINTK("pool size   = 0x%x\n", memExcInfo[i].size);
+        PRINTK("pool free   = 0x%x\n", memExcInfo[i].free);
+        PRINTK("pool blkNum = %d\n", memExcInfo[i].blockSize);
+        PRINTK("pool error node addr  = 0x%x\n", memExcInfo[i].errorAddr);
+        PRINTK("pool error node len   = 0x%x\n", memExcInfo[i].errorLen);
+        PRINTK("pool error node owner = %d\n", memExcInfo[i].errorOwner);
+    }
+#endif
+    UINT32 ret = LOS_MemIntegrityCheck(LOSCFG_SYS_HEAP_ADDR);
+    if (ret == LOS_OK) {
+        PRINTK("system heap memcheck over, all passed!\n");
+    }
+
+    PRINTK("memory pool check end!\n");
+}
+#endif
+
+STATIC VOID OsExcInfoDisplay(const ExcInfo *excInfo)
+{
+#if (LOSCFG_KERNEL_PRINTF != 0)
+    PRINTK("*************Exception Information**************\n");
+    OsExcTypeInfo(excInfo);
+    OsExcCurTaskInfo(excInfo);
+    OsExcRegInfo(excInfo);
+    OsExcBackTraceInfo(excInfo);
+    OsGetAllTskInfo();
+    OsExcMemPoolCheckInfo();
+#endif
+}
+
+LITE_OS_SEC_TEXT_INIT VOID HalExcHandleEntry(UINT32 excType, UINT32 faultAddr, UINT32 pid, EXC_CONTEXT_S *excBufAddr)
+{
+    g_intCount++;
+    g_excInfo.nestCnt++;
+
+    g_excInfo.type = excType;
+
+    if ((excType == OS_EXCEPT_UNDEF_INSTR) || (excType == OS_EXCEPT_SWI)) {
+        if ((excBufAddr->spsr & OS_INSTR_SET_MASK) == 0) { /* Work status: ARM */
+            excBufAddr->pc -= OS_ARM_INSTR_LEN;
+        } else if ((excBufAddr->spsr & OS_INSTR_SET_MASK) == 0x20) { /* Work status: Thumb */
+            excBufAddr->pc -= OS_THUMB_INSTR_LEN;
+        }
+    }
+    g_excInfo.faultAddr = OS_EXC_IMPRECISE_ACCESS_ADDR;
+
+    if (g_losTask.runTask != NULL) {
+        g_excInfo.phase = OS_EXC_IN_TASK;
+        g_excInfo.thrdPid = g_losTask.runTask->taskID;
+    } else {
+        g_excInfo.phase = OS_EXC_IN_INIT;
+        g_excInfo.thrdPid = OS_NULL_INT;
+    }
+    g_excInfo.context = excBufAddr;
+
+    OsDoExcHook(EXC_INTERRUPT);
+    OsExcInfoDisplay(&g_excInfo);
+    HalSysExit();
+}
+
+/* ****************************************************************************
+ Function    : HalHwiInit
+ Description : initialization of the hardware interrupt
+ Input       : None
+ Output      : None
+ Return      : None
+ **************************************************************************** */
+LITE_OS_SEC_TEXT_INIT VOID HalHwiInit(VOID)
+{
+#if (LOSCFG_USE_SYSTEM_DEFINED_INTERRUPT == 1)
+    UINT32 reg;
+    UINT32 val;
+
+    for (val = OS_SYS_VECTOR_CNT; val < OS_VECTOR_CNT; val++) {
+#if (OS_HWI_WITH_ARG == 1)
+        g_hwiForm[val].pfnHook = HalHwiDefaultHandler;
+        g_hwiForm[val].uwParam = 0;
+#else
+        g_hwiForm[val] = (HWI_PROC_FUNC)HalHwiDefaultHandler;
+#endif
+    }
+
+    val = OS_INT_IRQ_ENABLE | OS_INT_FIQ_ENABLE;
+    READ_UINT32(reg, OS_INT_GLOBAL_ENABLE_ADDR);
+    reg |= val;
+    WRITE_UINT32(reg, OS_INT_GLOBAL_ENABLE_ADDR);
+#endif
+    return;
+}
+
+UINT32 HalIntLock(VOID)
+{
+    UINT32 ret;
+    UINT32 temp;
+
+    __asm__ __volatile__("MRS %0, CPSR\n"
+                         "ORR %1, %0, #0xC0\n"
+                         "MSR CPSR_c, %1"
+                         : "=r"(ret), "=r"(temp)
+                         :
+                         : "memory");
+    return ret;
+}
+
+VOID HalIntRestore(UINT32 intSave)
+{
+    __asm__ __volatile__("MSR CPSR_c, %0" : : "r"(intSave));
+}
+
+UINT32 HalIntUnLock(VOID)
+{
+    UINT32 intSave;
+
+    __asm__ __volatile__("MRS %0, CPSR\n"
+                         "BIC %0, %0, #0xC0\n"
+                         "MSR CPSR_c, %0"
+                         : "=r"(intSave)
+                         :
+                         : "memory");
+    return intSave;
+}
+
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_timer.c b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_timer.c
new file mode 100644
index 0000000..efcc77a
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/los_timer.c
@@ -0,0 +1,163 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_config.h"
+#include "los_sched.h"
+#include "los_arch_context.h"
+#include "los_arch_interrupt.h"
+#include "los_reg.h"
+#include "uart_pub.h"
+
+#define OS_TIMER_CLKDIV_POS     3
+#define OS_TIMER_CLKDIV_MASK    7
+#define OS_TIMER_INT_POS        7
+#define OS_TIMER_INT_MASK       7
+#define OS_TIMER_IRQ_NUM        8
+#define OS_TIMER_ENABLE         (1U << 0)
+#define OS_TIMER_32K_CLK_BIT    (1U << 21)
+#define OS_TIMER_CNT_READ_BIT   (1U << 0)
+
+#define OS_TIMER_REG_BASE           0x00802A40UL
+#define OS_TIMER_CLK_PWD_ADDR       0x00802008UL
+#define OS_TIMER_PERIOD_REG_ADDR    (OS_TIMER_REG_BASE)
+#define OS_TIMER_CTL_REG_ADDR       (OS_TIMER_REG_BASE + 12)
+#define OS_TIMER_READ_CTL_ADDR      (OS_TIMER_REG_BASE + 16)
+#define OS_TIMER_READ_VAL_ADDR      (OS_TIMER_REG_BASE + 20)
+
+#if (0 == LOS_BEKEN)
+/* ****************************************************************************
+Function    : HalTickStart
+Description : Configure Tick Interrupt Start
+Input       : none
+output      : none
+return      : LOS_OK - Success , or LOS_ERRNO_TICK_CFG_INVALID - failed
+**************************************************************************** */
+WEAK UINT32 HalTickStart(OS_TICK_HANDLER *handler)
+{
+    UINT32 intSave = LOS_IntLock();
+    UINT32 value;
+
+    READ_UINT32(value, OS_TIMER_CLK_PWD_ADDR);
+    value &= ~(OS_TIMER_32K_CLK_BIT);
+    WRITE_UINT32(value, OS_TIMER_CLK_PWD_ADDR);
+
+    value = OS_SYS_CLOCK / LOSCFG_BASE_CORE_TICK_PER_SECOND;
+    WRITE_UINT32(value, OS_TIMER_PERIOD_REG_ADDR);
+
+    READ_UINT32(value, OS_TIMER_CTL_REG_ADDR);
+    value &= ~(OS_TIMER_CLKDIV_MASK << OS_TIMER_CLKDIV_POS); // The default is 1, and the clock does not divide.
+    value &= ~(OS_TIMER_INT_MASK << OS_TIMER_INT_POS); // Clearing interruption.
+    value |= 0x1 << OS_TIMER_INT_POS;
+    value |= OS_TIMER_ENABLE; // Enable timer.
+    WRITE_UINT32(value, OS_TIMER_CTL_REG_ADDR);
+
+    (VOID)HalHwiCreate(OS_TIMER_IRQ_NUM, 0, 0, (HWI_PROC_FUNC)handler, 0);
+    LOS_IntRestore(intSave);
+
+    return LOS_OK;
+}
+
+STATIC VOID HalClockIrqClear(VOID)
+{
+    UINT32 mask = OS_TIMER_INT_MASK << OS_TIMER_INT_POS;
+    UINT32 status;
+
+    do {
+        WRITE_UINT32(mask, OS_TIMER_CTL_REG_ADDR);
+        READ_UINT32(status, OS_TIMER_CTL_REG_ADDR);
+    } while (status & mask);
+}
+
+WEAK VOID HalSysTickReload(UINT64 nextResponseTime)
+{
+    HalTickLock();
+    WRITE_UINT32(nextResponseTime, OS_TIMER_PERIOD_REG_ADDR);
+    HalClockIrqClear();
+    HalTickUnlock();
+}
+
+WEAK UINT64 HalGetTickCycle(UINT32 *period)
+{
+    UINT32 val;
+
+    READ_UINT32(*period, OS_TIMER_PERIOD_REG_ADDR);
+
+    WRITE_UINT32(OS_TIMER_CNT_READ_BIT, OS_TIMER_READ_CTL_ADDR);
+    do {
+        READ_UINT32(val, OS_TIMER_READ_CTL_ADDR);
+    } while (val & OS_TIMER_CNT_READ_BIT); // Wait for the setting to take effect.
+
+    READ_UINT32(val, OS_TIMER_READ_VAL_ADDR);
+
+    return (UINT64)val;
+}
+
+WEAK VOID HalTickLock(VOID)
+{
+    UINT32 value;
+
+    READ_UINT32(value, OS_TIMER_CTL_REG_ADDR);
+    value &= ~OS_TIMER_ENABLE;
+    value &= ~(OS_TIMER_INT_MASK << OS_TIMER_INT_POS);
+    value |= 0x1 << OS_TIMER_INT_POS;
+    WRITE_UINT32(value, OS_TIMER_CTL_REG_ADDR);
+}
+
+WEAK VOID HalTickUnlock(VOID)
+{
+    UINT32 value;
+
+    READ_UINT32(value, OS_TIMER_CTL_REG_ADDR);
+    value |= OS_TIMER_ENABLE;
+    value &= ~(OS_TIMER_INT_MASK << OS_TIMER_INT_POS);
+    value |= 0x1 << OS_TIMER_INT_POS;
+    WRITE_UINT32(value, OS_TIMER_CTL_REG_ADDR);
+}
+#endif
+
+VOID HalEnterSleep(LOS_SysSleepEnum sleep)
+{
+	os_null_printf("[wzl]HalEnterSleep\r\n");
+	
+#if (LOSCFG_BASE_CORE_SCHED_SLEEP == 1)
+    if (sleep == OS_SYS_DEEP_SLEEP) {
+        OsSchedToSleep();
+    }
+#endif
+
+#if (0 == CFG_JTAG_ENABLE)
+    dsb();
+    wfi();
+    isb();
+#endif
+}
+// eof
+
diff --git a/kernel/liteos_m/kernel/arch/arm/arm9/gcc/reset_vector.S b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/reset_vector.S
new file mode 100644
index 0000000..ca015a1
--- /dev/null
+++ b/kernel/liteos_m/kernel/arch/arm/arm9/gcc/reset_vector.S
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+    .equ CPSR_IRQ_DISABLE,  0x80U
+    .equ CPSR_FIQ_DISABLE,  0x40U
+    .equ CPSR_THUMB_ENABLE, 0x20U
+    .equ CPSR_USER_MODE,    0x10U
+    .equ CPSR_FIQ_MODE,     0x11U
+    .equ CPSR_IRQ_MODE,     0x12U
+    .equ CPSR_SVC_MODE,     0x13U
+    .equ CPSR_ABT_MODE,     0x17U
+    .equ CPSR_UNDEF_MODE,   0x1BU
+
+    .global __exc_stack_top
+    .global __irq_stack_top
+    .global __fiq_stack_top
+    .global __svc_stack_top
+    .global __abt_stack_top
+    .global __undef_stack_top
+    .global __exc_stack
+    .global __irq_stack
+    .global __fiq_stack
+    .global __svc_stack
+    .global __abt_stack
+    .global __undef_stack
+    .global main
+
+    .extern HalExceptFiqHdl
+    .extern HalExceptAddrAbortHdl
+    .extern HalExceptDataAbortHdl
+    .extern HalExceptPrefetchAbortHdl
+    .extern HalExceptSwiHdl
+    .extern HalExceptUndefInstrHdl
+    .extern HalExceptIrqHdl
+    .extern _bss_start
+    .extern _bss_end
+
+    .code 32
+    .text
+
+    .section ".vectors", "ax"
+    .global _vector_start
+
+_vector_start:
+    B     HalResetVector
+    B     HalExceptUndefInstrHdl
+    B     HalExceptSwiHdl
+    B     HalExceptPrefetchAbortHdl
+    B     HalExceptDataAbortHdl
+    B     HalExceptAddrAbortHdl
+    B     HalExceptIrqHdl
+    B     HalExceptFiqHdl
+
+    .globl  HalResetVector
+    .section ".boot", "ax"
+
+HalResetVector:
+    MOV    R0, #(CPSR_IRQ_DISABLE | CPSR_FIQ_DISABLE | CPSR_IRQ_MODE)
+    MSR    CPSR, R0
+    LDR    SP, =__irq_stack_top
+
+    MOV    R0, #(CPSR_IRQ_DISABLE | CPSR_FIQ_DISABLE | CPSR_UNDEF_MODE)
+    MSR    CPSR, R0
+    LDR    SP, =__undef_stack_top
+
+    MOV    R0, #(CPSR_IRQ_DISABLE | CPSR_FIQ_DISABLE | CPSR_ABT_MODE)
+    MSR    CPSR, R0
+    LDR    SP, =__abt_stack_top
+
+    MOV    R0, #(CPSR_IRQ_DISABLE | CPSR_FIQ_DISABLE | CPSR_FIQ_MODE)
+    MSR    CPSR, R0
+    LDR    SP, =__fiq_stack_top
+
+    MOV    R0, #(CPSR_IRQ_DISABLE | CPSR_FIQ_DISABLE | CPSR_SVC_MODE)
+    MSR    CPSR, R0
+    MSR    SPSR, R0
+    LDR    SP, =__svc_stack_top
+
+    BL     OsBssInit
+
+    B      main
+    B      .
+
+OsBssInit:
+    LDR     R0, =_bss_start
+    LDR     R1, =_bss_end
+
+    MOV     R3, R1
+    MOV     R4, R0
+    MOV     R2, #0
+1:  CMP     R4, R3
+    STRLO   R2, [R4], #4
+    BLO     1b
+    BX      LR
+
+    .section ".bss", "wa", %nobits
+    .align 3
+__undef_stack:
+    .space  32
+__undef_stack_top:
+
+__abt_stack:
+    .space  32
+__abt_stack_top:
+
+__irq_stack:
+    .space  1024
+__irq_stack_top:
+
+__fiq_stack:
+    .space  1024
+__fiq_stack_top:
+
+__svc_stack:
+    .space  1024
+__svc_stack_top:
+
+__exc_stack:
+    .space  512
+__exc_stack_top:
+
diff --git a/kernel/liteos_m/kernel/arch/include/los_arch.h b/kernel/liteos_m/kernel/arch/include/los_arch.h
old mode 100755
new mode 100644
index 7ba4f7a..af75363
--- a/kernel/liteos_m/kernel/arch/include/los_arch.h
+++ b/kernel/liteos_m/kernel/arch/include/los_arch.h
@@ -38,16 +38,16 @@
 #ifdef __cplusplus
 #if __cplusplus
 extern "C" {
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
+#endif /* __cplusplus */
+#endif /* __cplusplus */
 
 VOID HalArchInit(VOID);
 
 #ifdef __cplusplus
 #if __cplusplus
 }
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
+#endif /* __cplusplus */
+#endif /* __cplusplus */
 
 #endif /* _LOS_ARCH_H */
 
diff --git a/kernel/liteos_m/kernel/arch/include/los_atomic.h b/kernel/liteos_m/kernel/arch/include/los_atomic.h
index 1fc1491..b0dae42 100644
--- a/kernel/liteos_m/kernel/arch/include/los_atomic.h
+++ b/kernel/liteos_m/kernel/arch/include/los_atomic.h
@@ -29,8 +29,8 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef LOS_ATOMIC_H
-#define LOS_ATOMIC_H
+#ifndef _LOS_ATOMIC_H
+#define _LOS_ATOMIC_H
 
 #include "los_compiler.h"
 
@@ -47,5 +47,5 @@ extern "C" {
 #endif /* __cplusplus */
 #endif /* __cplusplus */
 
-#endif /* LOS_ATOMIC_H */
+#endif /* _LOS_ATOMIC_H */
 
diff --git a/kernel/liteos_m/kernel/arch/include/los_context.h b/kernel/liteos_m/kernel/arch/include/los_context.h
index 058d710..9fc30c6 100644
--- a/kernel/liteos_m/kernel/arch/include/los_context.h
+++ b/kernel/liteos_m/kernel/arch/include/los_context.h
@@ -30,12 +30,12 @@
  */
 
 /**
- * @defgroup los_hw hardware
+ * @defgroup los_context hardware
  * @ingroup kernel
  */
 
-#ifndef _LOS_HW_H
-#define _LOS_HW_H
+#ifndef _LOS_CONTEXT_H
+#define _LOS_CONTEXT_H
 
 #include "los_compiler.h"
 
@@ -45,8 +45,8 @@ extern "C" {
 #endif /* __cplusplus */
 #endif /* __cplusplus */
 
-/* *
- * @ingroup  los_hw
+/**
+ * @ingroup  los_context
  * @brief: Task stack initialization.
  *
  * @par Description:
@@ -61,12 +61,13 @@ extern "C" {
  *
  * @retval: context Type#TaskContext *.
  * @par Dependency:
- * <ul><li>los_hw.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_context.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern VOID *HalTskStackInit(UINT32 taskID, UINT32 stackSize, VOID *topStack);
+
 /**
- * @ingroup  los_hw
+ * @ingroup  los_context
  * @brief: Function to sys exit.
  *
  * @par Description:
@@ -79,12 +80,12 @@ extern VOID *HalTskStackInit(UINT32 taskID, UINT32 stackSize, VOID *topStack);
  *
  * @retval: None.
  * @par Dependency:
- * <ul><li>los_hw.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_context.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
-LITE_OS_SEC_TEXT_MINOR VOID HalSysExit(VOID);
+LITE_OS_SEC_TEXT_MINOR NORETURN VOID HalSysExit(VOID);
 
-/* *
+/**
  * @ingroup  los_context
  * @brief: Task scheduling Function.
  *
@@ -106,22 +107,10 @@ extern VOID HalTaskSchedule(VOID);
 typedef VOID (*OS_TICK_HANDLER)(VOID);
 UINT32 HalStartSchedule(OS_TICK_HANDLER handler);
 
-UINTPTR HalIntLock(VOID);
-#define LOS_IntLock HalIntLock
-
-VOID HalIntRestore(UINTPTR intSave);
-#define LOS_IntRestore HalIntRestore
-
-UINTPTR HalIntUnLock(VOID);
-#define LOS_IntUnLock HalIntUnLock
-
-
-
 #ifdef __cplusplus
 #if __cplusplus
 }
 #endif /* __cplusplus */
 #endif /* __cplusplus */
 
-#endif /* _LOS_HW_H */
-
+#endif /* _LOS_CONTEXT_H */
diff --git a/kernel/liteos_m/kernel/arch/include/los_interrupt.h b/kernel/liteos_m/kernel/arch/include/los_interrupt.h
old mode 100755
new mode 100644
index fb13b5d..56a4abb
--- a/kernel/liteos_m/kernel/arch/include/los_interrupt.h
+++ b/kernel/liteos_m/kernel/arch/include/los_interrupt.h
@@ -41,7 +41,7 @@ extern "C" {
 #endif /* __cplusplus */
 
 /* *
- * @ingroup los_config
+ * @ingroup los_interrupt
  * Configuration item for interrupt with argument
  */
 #ifndef OS_HWI_WITH_ARG
@@ -49,11 +49,8 @@ extern "C" {
 #endif
 
 typedef UINT32 HWI_HANDLE_T;
-
 typedef UINT16 HWI_PRIOR_T;
-
 typedef UINT16 HWI_MODE_T;
-
 typedef UINT32 HWI_ARG_T;
 
 #if (OS_HWI_WITH_ARG == 1)
@@ -62,12 +59,28 @@ typedef VOID (*HWI_PROC_FUNC)(VOID *parm);
 typedef VOID (*HWI_PROC_FUNC)(void);
 #endif
 
-UINT32 HalIsIntAcvive(VOID);
-#define OS_INT_ACTIVE    (HalIsIntAcvive())
+/* stack protector */
+extern UINT32 __stack_chk_guard;
+
+extern VOID __stack_chk_fail(VOID);
+
+UINT32 HalIsIntActive(VOID);
+#define OS_INT_ACTIVE    (HalIsIntActive())
 #define OS_INT_INACTIVE  (!(OS_INT_ACTIVE))
+#define LOS_HwiCreate HalHwiCreate
+#define LOS_HwiDelete HalHwiDelete
 
-/* *
- * @ingroup  los_hwi
+UINT32 HalIntLock(VOID);
+#define LOS_IntLock HalIntLock
+
+VOID HalIntRestore(UINT32 intSave);
+#define LOS_IntRestore HalIntRestore
+
+UINT32 HalIntUnLock(VOID);
+#define LOS_IntUnLock HalIntUnLock
+
+/**
+ * @ingroup  los_interrupt
  * @brief Delete hardware interrupt.
  *
  * @par Description:
@@ -86,13 +99,13 @@ UINT32 HalIsIntAcvive(VOID);
  * @retval #OS_ERRNO_HWI_NUM_INVALID              0x02000900: Invalid interrupt number.
  * @retval #LOS_OK                                0         : The interrupt is successfully delete.
  * @par Dependency:
- * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_interrupt.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 HalHwiDelete(HWI_HANDLE_T hwiNum);
 
-/* *
- * @ingroup  los_hwi
+/**
+ * @ingroup  los_interrupt
  * @brief Create a hardware interrupt.
  *
  * @par Description:
@@ -118,7 +131,7 @@ extern UINT32 HalHwiDelete(HWI_HANDLE_T hwiNum);
  * @retval #OS_ERRNO_HWI_ALREADY_CREATED              0x02000904: The interrupt handler being created has already been created.
  * @retval #LOS_OK                                    0         : The interrupt is successfully created.
  * @par Dependency:
- * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_interrupt.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 HalHwiCreate(HWI_HANDLE_T hwiNum,
@@ -134,4 +147,3 @@ extern UINT32 HalHwiCreate(HWI_HANDLE_T hwiNum,
 #endif /* __cplusplus */
 
 #endif /* _LOS_INTERRUPT_H */
-
diff --git a/kernel/liteos_m/kernel/arch/include/los_mpu.h b/kernel/liteos_m/kernel/arch/include/los_mpu.h
old mode 100755
new mode 100644
index 17f1cc7..82a565f
--- a/kernel/liteos_m/kernel/arch/include/los_mpu.h
+++ b/kernel/liteos_m/kernel/arch/include/los_mpu.h
@@ -83,6 +83,7 @@ VOID HalMpuEnable(UINT32 defaultRegionEnable);
 VOID HalMpuDisable();
 UINT32 HalMpuSetRegion(UINT32 regionId, MPU_CFG_PARA *para);
 UINT32 HalMpuDisableRegion(UINT32 regionId);
+INT32 HalMpuUnusedRegionGet(VOID);
 
 #ifdef __cplusplus
 #if __cplusplus
diff --git a/kernel/liteos_m/kernel/arch/include/los_timer.h b/kernel/liteos_m/kernel/arch/include/los_timer.h
old mode 100755
new mode 100644
index e216c3f..8d6020b
--- a/kernel/liteos_m/kernel/arch/include/los_timer.h
+++ b/kernel/liteos_m/kernel/arch/include/los_timer.h
@@ -29,10 +29,11 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef LOS_TIMER_H
-#define LOS_TIMER_H
+#ifndef _LOS_TIMER_H
+#define _LOS_TIMER_H
 
 #include "los_compiler.h"
+#include "los_pm.h"
 
 #ifdef __cplusplus
 #if __cplusplus
@@ -52,57 +53,34 @@ extern "C" {
 #define RTC_CALIBRATE_SLEEP_TIME 8
 #define MACHINE_CYCLE_DEALAY_TIMES (LOSCFG_BASE_CORE_TICK_PER_SECOND << 2)
 
-typedef enum {
-    OS_SYS_NORMAL_SLEEP = 0,
-    OS_SYS_DEEP_SLEEP,
-} LOS_SysSleepEnum;
-
 VOID HalTickLock(VOID);
-
 VOID HalTickUnlock(VOID);
-
-BOOL HalGetSysSleepFlag(VOID);
-
-VOID HalClearSysSleepFlag(VOID);
-
 VOID HalEnterSleep(LOS_SysSleepEnum sleep);
 
-VOID HalDelay(UINT32 ticks);
-
-UINT64 HalGetExpandTick(VOID);
-
-INT32 HalGetRtcTime(UINT64 *usec);
-
-INT32 HalGetRtcTimeZone(INT32 *timeZone);
-
-INT32 HalSetRtcTime(UINT64 utcTime, UINT64 *usec);
-
-INT32 HalSetRtcTimeZone(INT32 timeZone);
-
- /**
+/**
  * @ingroup los_timer
- * @brief Configure Tick Interrupt Start.
+ * @brief Get systick cycle.
  *
  * @par Description:
- * This API is used to configure Tick Interrupt Start while macro LOSCFG_BASE_CORE_TICK_HW_TIME is No.
+ * This API is used to get systick cycle and return current tick period.
  *
  * @attention
  * <ul>
  * <li>None.</li>
  * </ul>
  *
- * @param: None.
+ * @param: period [OUT] current tick period.
  *
- * @retval #LOS_OK                               0:configure Tick Interrupt success.
- * @retval #LOS_ERRNO_TICK_CFG_INVALID           0x02000400:configure Tick Interrupt failed.
+ * @retval current tick count.
  *
  * @par Dependency:
- * <ul><li>los_config.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_timer.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
+UINT64 HalGetTickCycle(UINT32 *period);
 
 /**
- * @ingroup los_hwi
+ * @ingroup los_timer
  * @brief reconfig systick, and clear SysTick_IRQn.
  *
  * @par Description:
@@ -114,103 +92,14 @@ INT32 HalSetRtcTimeZone(INT32 timeZone);
  * <li>None.</li>
  * </ul>
  *
- * @param  cyclesPerTick  [IN] Cycles Per Tick
+ * @param  nextResponseTime  [IN] tick period
  *
  * @retval None.
  * @par Dependency:
- * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_timer.h: the header file that contains the API declaration.</li></ul>
  * @see None
  */
-extern VOID HalSysTickReload(UINT32 cyclesPerTick);
-
-/**
- * @ingroup los_hwi
- * @brief Get System cycle count.
- *
- * @par Description:
- * <ul>
- * <li>This API is used to Get System cycle count.</li>
- * </ul>
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param  None.
- *
- * @retval: The value of the system cycle count.
- * @par Dependency:
- * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_IntRestore
- */
-extern UINT32 HalSysTickCurrCycleGet(VOID);
-
-
-/* *
- * @ingroup los_hwi
- * @brief Get value from xPSR register.
- *
- * @par Description:
- * <ul>
- * <li>This API is used to Get value from xPSR register.</li>
- * </ul>
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param  cntHi  [IN] CpuTick High 4 byte
- * @param  cntLo  [IN] CpuTick Low 4 byte
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_IntRestore
- */
-extern VOID HalGetCpuCycle(UINT32 *cntHi, UINT32 *cntLo);
-
-
-
-extern VOID HalGetSystickCycle(UINT32 *puwCntHi, UINT32 *puwCntLo);
-
-/**
- * @ingroup  los_tickless
- * @brief enable the tickless mode.
- *
- * @par Description:
- * This API is used to enable the tickless mode. System can change from periodic clock mode to dynamic clock mode.
- *
- * @attention
- * <ul>
- * </ul>
- *
- * @param  None.
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_tickless.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_TicklessDisable
- */
-extern VOID HalTicklessEnable(VOID);
-/**
- * @ingroup  los_tickless
- * @brief disable the tickless mode.
- *
- * @par Description:
- * This API is used to diable the tickless mode. System will not change from periodic clock mode to dynamic clock mode.
- *
- * @attention
- * <ul>
- * </ul>
- *
- * @param  None.
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_tickless.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_TicklessEnable
- */
-extern VOID HalTicklessDisable(VOID);
+extern VOID HalSysTickReload(UINT64 nextResponseTime);
 
 #ifdef __cplusplus
 #if __cplusplus
@@ -218,4 +107,4 @@ extern VOID HalTicklessDisable(VOID);
 #endif /* __cplusplus */
 #endif /* __cplusplus */
 
-#endif
\ No newline at end of file
+#endif /* _LOS_TIMER_H */
diff --git a/kernel/liteos_m/kernel/include/los_config.h b/kernel/liteos_m/kernel/include/los_config.h
old mode 100755
new mode 100644
index 04290cd..ec7029d
--- a/kernel/liteos_m/kernel/include/los_config.h
+++ b/kernel/liteos_m/kernel/include/los_config.h
@@ -49,6 +49,25 @@ extern "C" {
 /* =============================================================================
                                         System clock module configuration
 ============================================================================= */
+#ifndef LOS_BEKEN
+#define LOS_BEKEN              1
+#endif
+
+#if LOS_BEKEN
+#include "sys_config.h"
+
+#if (CFG_SOC_NAME == SOC_BK7231N)
+#define LOSCFG_SYS_HEAP_ADDR_END      (void*)(0x00400000 + 192 * 1024)
+#elif (CFG_SOC_NAME == SOC_BK7236) // TBD: mem size for bk7236
+#define LOSCFG_SYS_HEAP_ADDR_END      (void*)(0x00400000 + 192 * 1024)
+#elif (CFG_SOC_NAME == SOC_BK7271)
+#define LOSCFG_SYS_HEAP_ADDR_END      (void*)(0x00400000 + 512 * 1024)
+#else
+#define LOSCFG_SYS_HEAP_ADDR_END      (void*)(0x00400000 + 256 * 1024)
+#endif // CFG_SOC_NAME
+
+#endif // LOS_BEKEN
+
 /**
  * @ingroup los_config
  * System clock (unit: HZ)
@@ -103,6 +122,22 @@ extern "C" {
 #define LOSCFG_BASE_CORE_TICK_HW_TIME                       0
 #endif
 
+/**
+ * @ingroup los_config
+ * System timer is a 64/128 bit timer
+ */
+#ifndef LOSCFG_BASE_CORE_TICK_WTIMER
+#define LOSCFG_BASE_CORE_TICK_WTIMER                        0
+#endif
+
+/**
+ * @ingroup los_config
+ * System timer count maximum
+ */
+#ifndef LOSCFG_BASE_CORE_TICK_RESPONSE_MAX
+#define LOSCFG_BASE_CORE_TICK_RESPONSE_MAX                       0
+#endif
+
 /* =============================================================================
                                         Hardware interrupt module configuration
 ============================================================================= */
@@ -166,7 +201,7 @@ extern "C" {
  * Maximum supported number of tasks except the idle task rather than the number of usable tasks
  */
 #ifndef LOSCFG_BASE_CORE_TSK_LIMIT
-#define LOSCFG_BASE_CORE_TSK_LIMIT                          5
+#define LOSCFG_BASE_CORE_TSK_LIMIT                          16
 #endif
 
 /**
@@ -190,7 +225,7 @@ extern "C" {
  * Configuration item for task Robin tailoring
  */
 #ifndef LOSCFG_BASE_CORE_TIMESLICE
-#define LOSCFG_BASE_CORE_TIMESLICE                          1
+#define LOSCFG_BASE_CORE_TIMESLICE                         1
 #endif
 
 /**
@@ -198,7 +233,7 @@ extern "C" {
  * Longest execution time of tasks with the same priorities
  */
 #ifndef LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT
-#define LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT                  10
+#define LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT                  20000 /* 20ms */
 #endif
 
 /**
@@ -217,6 +252,14 @@ extern "C" {
 #define LOSCFG_BASE_CORE_EXC_TSK_SWITCH                     0
 #endif
 
+/*
+ * @ingroup los_config
+ * Configuration item for task context switch hook
+ */
+#ifndef LOSCFG_BASE_CORE_TSK_SWITCH_HOOK
+#define LOSCFG_BASE_CORE_TSK_SWITCH_HOOK()
+#endif
+
 /**
  * @ingroup los_config
  * Define a usable task priority.Highest task priority.
@@ -268,6 +311,14 @@ extern "C" {
 #define LOSCFG_BASE_IPC_SEM_LIMIT                           6
 #endif
 
+/**
+ * @ingroup los_config
+ * Maximum number of semaphores.
+ */
+#ifndef OS_SEM_COUNTING_MAX_COUNT
+#define OS_SEM_COUNTING_MAX_COUNT                           0xFFFF
+#endif
+
 /* =============================================================================
                                        Mutex module configuration
 ============================================================================= */
@@ -303,7 +354,7 @@ extern "C" {
  * Maximum supported number of queues rather than the number of usable queues
  */
 #ifndef LOSCFG_BASE_IPC_QUEUE_LIMIT
-#define LOSCFG_BASE_IPC_QUEUE_LIMIT                         6
+#define LOSCFG_BASE_IPC_QUEUE_LIMIT                         32
 #endif
 
 
@@ -435,12 +486,16 @@ extern UINT8 *m_aucSysMem0;
  * Configuration memory leak detection
  * @attention
  * Need to enable backtrace module synchronously by configuration LOSCFG_BACKTRACE_TYPE,
- * and call LOS_BackTraceInit to complete initialization before the memory pool is initialized.
+ * and call OSBackTraceInit to complete initialization before the memory pool is initialized.
  */
 #ifndef LOSCFG_MEM_LEAKCHECK
 #define LOSCFG_MEM_LEAKCHECK                                0
 #endif
 
+#if (LOSCFG_MEM_LEAKCHECK == 1) && (LOSCFG_BACKTRACE_TYPE == 0)
+    #error "if LOSCFG_MEM_LEAKCHECK is set to 1, then LOSCFG_BACKTRACE_TYPE must be set to 1, 2 or 3."
+#endif
+
 /**
  * @ingroup los_config
  * The default is 4, which means that the function call stack is recorded from the kernel interface,
@@ -517,12 +572,12 @@ extern UINT8 *m_aucSysMem0;
  * @ingroup los_config
  * Configuration of hardware stack protection
  */
-#ifndef LOSCFG_EXC_HRADWARE_STACK_PROTECTION
-#define LOSCFG_EXC_HRADWARE_STACK_PROTECTION                0
+#ifndef LOSCFG_EXC_HARDWARE_STACK_PROTECTION
+#define LOSCFG_EXC_HARDWARE_STACK_PROTECTION                0
 #endif
 
 /* =============================================================================
-                                        CPUP configuration
+                                        CPUP module configuration
 ============================================================================= */
 /**
  * @ingroup los_config
@@ -539,6 +594,9 @@ extern UINT8 *m_aucSysMem0;
  * @ingroup los_config
  * Configuration test case to open
  */
+#ifndef LOSCFG_TEST
+#define LOSCFG_TEST                                         0
+#endif
 
 /**
  * @ingroup los_config
@@ -549,14 +607,64 @@ extern UINT8 *m_aucSysMem0;
 #endif
 
 /* =============================================================================
-                                       trace configuration
+                                       Fs module configuration
+============================================================================= */
+#ifndef LOSCFG_SUPPORT_FATFS
+#define LOSCFG_SUPPORT_FATFS                                0
+#endif
+
+#ifndef LOSCFG_SUPPORT_LITTLEFS
+#define LOSCFG_SUPPORT_LITTLEFS                             1
+#endif
+
+#ifndef LOSCFG_LFS_MAX_MOUNT_SIZE
+#define LOSCFG_LFS_MAX_MOUNT_SIZE                           3
+#endif
+
+/* =============================================================================
+                                       Trace module configuration
 ============================================================================= */
 /**
  * @ingroup los_config
- * Configuration liteos trace
+ * Configuration trace tool
  */
-#ifndef LOSCFG_KERNEL_TRACE
-#define LOSCFG_KERNEL_TRACE                                 0
+#ifndef LOSCFG_DEBUG_HOOK
+#define LOSCFG_DEBUG_HOOK                                   0
+#endif
+
+/* =============================================================================
+                                       PM module configuration
+============================================================================= */
+/**
+ * @ingroup los_config
+ * Configuration item for low power frame tailoring
+ */
+#ifndef LOSCFG_KERNEL_PM
+#define LOSCFG_KERNEL_PM                                     1
+#endif
+
+/**
+ * @ingroup los_config
+ * Configuration item for priority of low-power task.
+ */
+#ifndef LOSCFG_KERNEL_PM_TASK_PTIORITY
+#define LOSCFG_KERNEL_PM_TASK_PTIORITY                       1
+#endif
+
+/**
+ * @ingroup los_config
+ * Configuration item for stack size of low-power task.
+ */
+#ifndef LOSCFG_KERNEL_PM_TASK_STACKSIZE
+#define LOSCFG_KERNEL_PM_TASK_STACKSIZE                      0x800
+#endif
+
+/**
+ * @ingroup los_config
+ * Configuration item for low power frame debug tailoring
+ */
+#ifndef LOSCFG_KERNEL_PM_DEBUG
+#define LOSCFG_KERNEL_PM_DEBUG                               0
 #endif
 
 /* =============================================================================
@@ -577,8 +685,9 @@ extern UINT8 *m_aucSysMem0;
  * @ingroup los_config
  * Configuration backtrace type
  * 0: Close stack analysis module.
- * 1: Call stack analysis for cortex-m series.
- * 2: Call stack analysis for risc-v.
+ * 1: Call stack analysis for cortex-m series by scanning the stack.
+ * 2: Call stack analysis for risc-v by using frame pointer.
+ * 3: Call stack analysis for risc-v by scanning the stack.
  * others: Not currently supported.
  */
 #ifndef LOSCFG_BACKTRACE_TYPE
@@ -593,6 +702,26 @@ extern UINT8 *m_aucSysMem0;
 #define LOSCFG_BACKTRACE_DEPTH                               15
 #endif
 
+/* =============================================================================
+                                       trustzone configuration
+============================================================================= */
+/**
+ * @ingroup los_config
+ * Configuration trustzone secure heap size.
+ */
+#ifndef LOSCFG_SECURE_HEAP_SIZE
+#define LOSCFG_SECURE_HEAP_SIZE                              2048
+#endif
+
+/**
+ * @ingroup los_config
+ * Configuration trustzone secure stack default size.
+ * The secure stack must be allocated before the task calls non-secure callble functions.
+ */
+#ifndef LOSCFG_SECURE_STACK_DEFAULT_SIZE
+#define LOSCFG_SECURE_STACK_DEFAULT_SIZE                     512
+#endif
+
 #ifdef __cplusplus
 #if __cplusplus
 }
diff --git a/kernel/liteos_m/kernel/include/los_event.h b/kernel/liteos_m/kernel/include/los_event.h
index 933215a..4df94aa 100644
--- a/kernel/liteos_m/kernel/include/los_event.h
+++ b/kernel/liteos_m/kernel/include/los_event.h
@@ -147,13 +147,13 @@ extern "C" {
 
 /**
  * @ingroup los_event
- * Event reading error code: should not be distory.
+ * Event reading error code: should not be destroyed.
  *
  * Value: 0x02001c08
  *
  * Solution: Check whether the event list is not empty.
  */
-#define LOS_ERRNO_EVENT_SHOULD_NOT_DESTORY LOS_ERRNO_OS_ERROR(LOS_MOD_EVENT, 0x08)
+#define LOS_ERRNO_EVENT_SHOULD_NOT_DESTROYED LOS_ERRNO_OS_ERROR(LOS_MOD_EVENT, 0x08)
 
 /**
  * @ingroup los_event
@@ -274,7 +274,7 @@ extern UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events);
 
 /**
  * @ingroup los_event
- * @brief Clear the event occurring in a specified task.
+ * @brief Clear the event of the eventCB by a specified eventMask.
  *
  * @par Description:
  * <ul>
@@ -287,7 +287,7 @@ extern UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events);
  * </ul>
  *
  * @param eventCB     [IN/OUT] Pointer to the event control block to be cleared.
- * @param events      [IN]     Mask of the event to be cleared.
+ * @param eventMask   [IN]     Mask of the event to be cleared.
  *
  * @retval #LOS_ERRNO_EVENT_PTR_NULL  Null pointer.
  * @retval #LOS_OK                    The event is successfully cleared.
@@ -295,15 +295,15 @@ extern UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events);
  * <ul><li>los_event.h: the header file that contains the API declaration.</li></ul>
  * @see LOS_EventPoll | LOS_EventRead | LOS_EventWrite
  */
-extern UINT32 LOS_EventClear(PEVENT_CB_S eventCB, UINT32 events);
+extern UINT32 LOS_EventClear(PEVENT_CB_S eventCB, UINT32 eventMask);
 
 /**
  * @ingroup los_event
- * @brief Destroy a event.
+ * @brief Destroy an event.
  *
  * @par Description:
  * <ul>
- * <li>This API is used to Destroy a event.</li>
+ * <li>This API is used to Destroy an event.</li>
  * </ul>
  * @attention
  * <ul>
diff --git a/kernel/liteos_m/kernel/include/los_membox.h b/kernel/liteos_m/kernel/include/los_membox.h
old mode 100755
new mode 100644
index cc65225..9093aca
--- a/kernel/liteos_m/kernel/include/los_membox.h
+++ b/kernel/liteos_m/kernel/include/los_membox.h
@@ -82,14 +82,14 @@ UINT32 OsMemboxExcInfoGet(UINT32 memNumMax, MemInfoCB *memExcInfo);
  * @ingroup los_membox
  * Memory pool alignment
  */
-#define LOS_MEMBOX_ALLIGNED(memAddr) (((UINTPTR)(memAddr) + sizeof(UINTPTR) - 1) & (~(sizeof(UINTPTR) - 1)))
+#define LOS_MEMBOX_ALIGNED(memAddr) (((UINTPTR)(memAddr) + sizeof(UINTPTR) - 1) & (~(sizeof(UINTPTR) - 1)))
 
 /**
  * @ingroup los_membox
  * Memory pool size
  */
 #define LOS_MEMBOX_SIZE(blkSize, blkNum) \
-    (sizeof(LOS_MEMBOX_INFO) + (LOS_MEMBOX_ALLIGNED((blkSize) + OS_MEMBOX_NODE_HEAD_SIZE) * (blkNum)))
+    (sizeof(LOS_MEMBOX_INFO) + (LOS_MEMBOX_ALIGNED((blkSize) + OS_MEMBOX_NODE_HEAD_SIZE) * (blkNum)))
 
 /**
  * @ingroup los_membox
diff --git a/kernel/liteos_m/kernel/include/los_memory.h b/kernel/liteos_m/kernel/include/los_memory.h
old mode 100755
new mode 100644
diff --git a/kernel/liteos_m/kernel/include/los_mux.h b/kernel/liteos_m/kernel/include/los_mux.h
index 8e5a129..334c876 100644
--- a/kernel/liteos_m/kernel/include/los_mux.h
+++ b/kernel/liteos_m/kernel/include/los_mux.h
@@ -330,7 +330,7 @@ extern LosMuxCB *g_allMux;
  *
  * @retval UINT32     Initialization result.
  * @par Dependency:
- * <ul><li>los_mux_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_mux.h: the header file that contains the API declaration.</li></ul>
  * @see LOS_MuxDelete
  */
 extern UINT32 OsMuxInit(VOID);
diff --git a/kernel/liteos_m/kernel/include/los_queue.h b/kernel/liteos_m/kernel/include/los_queue.h
index 68c1cc5..c3aebc0 100644
--- a/kernel/liteos_m/kernel/include/los_queue.h
+++ b/kernel/liteos_m/kernel/include/los_queue.h
@@ -355,7 +355,7 @@ typedef struct tagQueueInfo {
  * This API is used to create a message queue.
  * @attention
  * <ul>
- * <li>Threre are LOSCFG_BASE_IPC_QUEUE_LIMIT queues available, change it's value when necessory.</li>
+ * <li>There are LOSCFG_BASE_IPC_QUEUE_LIMIT queues available, change it's value when necessary.</li>
  * </ul>
  * @param queueName        [IN]    Message queue name. Reserved parameter, not used for now.
  * @param len              [IN]    Queue length. The value range is [1,0xffff].
@@ -402,7 +402,7 @@ extern UINT32 LOS_QueueCreate(CHAR *queueName,
  * [1,LOSCFG_BASE_IPC_QUEUE_LIMIT].
  * @param bufferAddr     [OUT]    Starting address that stores the obtained data. The starting address must not be
  * null.
- * @param bufferSize     [IN/OUT] Where to maintain the buffer wantted-size before read, and the real-size after read.
+ * @param bufferSize     [IN/OUT] Where to maintain the buffer expected-size before read, and the real-size after read.
  * @param timeOut        [IN]     Expiry time. The value range is [0,LOS_WAIT_FOREVER](unit: Tick).
  *
  * @retval   #LOS_OK                              The queue is successfully read.
@@ -827,7 +827,7 @@ extern LosQueueCB *g_allQueue;
  * @retval   #NULL                    The memory allocation is failed.
  * @retval   #mem                     The address of alloc memory.
  * @par Dependency:
- * <ul><li>los_queue_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_queue.h: the header file that contains the API declaration.</li></ul>
  * @see OsQueueMailFree
  */
 extern VOID *OsQueueMailAlloc(UINT32 queueID, VOID *mailPool, UINT32 timeOut);
@@ -853,7 +853,7 @@ extern VOID *OsQueueMailAlloc(UINT32 queueID, VOID *mailPool, UINT32 timeOut);
  * @retval   #OS_ERRNO_QUEUE_MAIL_PTR_INVALID        0x0200061a: The pointer to the memory to be freed is null.
  * @retval   #OS_ERRNO_QUEUE_MAIL_FREE_ERROR         0x0200061b: The memory for the queue fails to be freed.
  * @par Dependency:
- * <ul><li>los_queue_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_queue.h: the header file that contains the API declaration.</li></ul>
  * @see OsQueueMailAlloc
  */
 extern UINT32 OsQueueMailFree(UINT32 queueID, VOID *mailPool, VOID *mailMem);
@@ -873,7 +873,7 @@ extern UINT32 OsQueueMailFree(UINT32 queueID, VOID *mailPool, VOID *mailMem);
  *
  * @retval   UINT32  Initialization result.
  * @par Dependency:
- * <ul><li>los_queue_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_queue.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsQueueInit(VOID);
@@ -897,7 +897,7 @@ extern UINT32 OsQueueInit(VOID);
  *
  * @retval   UINT32  Handle result.
  * @par Dependency:
- * <ul><li>los_queue_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_queue.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsQueueOperate(UINT32 queueID, UINT32 operateType, VOID *bufferAddr, UINT32 *bufferSize,
diff --git a/kernel/liteos_m/kernel/include/los_sched.h b/kernel/liteos_m/kernel/include/los_sched.h
new file mode 100644
index 0000000..94acad0
--- /dev/null
+++ b/kernel/liteos_m/kernel/include/los_sched.h
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_SCHED_H
+#define _LOS_SCHED_H
+
+#include "los_task.h"
+#include "los_interrupt.h"
+#include "los_timer.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define OS_SCHED_MAX_RESPONSE_TIME (UINT64)(((UINT64)-1) - 1U)
+
+extern UINT32 g_taskScheduled;
+typedef BOOL (*SchedScan)(VOID);
+
+VOID OsSchedUpdateSchedTimeBase(VOID);
+
+UINT64 OsGetCurrSchedTimeCycle(VOID);
+
+VOID OsSchedSetIdleTaskSchedParam(LosTaskCB *idleTask);
+
+UINT32 OsSchedSwtmrScanRegister(SchedScan func);
+
+VOID OsSchedUpdateExpireTime(UINT64 startTime, BOOL timeUpdate);
+
+VOID OsSchedTaskDeQueue(LosTaskCB *taskCB);
+
+VOID OsSchedTaskEnQueue(LosTaskCB *taskCB);
+
+VOID OsSchedTaskWait(LOS_DL_LIST *list, UINT32 timeout);
+
+VOID OsSchedTaskWake(LosTaskCB *resumedTask);
+
+BOOL OsSchedModifyTaskSchedParam(LosTaskCB *taskCB, UINT16 priority);
+
+VOID OsSchedDelay(LosTaskCB *runTask, UINT32 tick);
+
+VOID OsSchedYield(VOID);
+
+VOID OsSchedTaskExit(LosTaskCB *taskCB);
+
+VOID OsSchedTick(VOID);
+
+UINT32 OsSchedInit(VOID);
+
+VOID OsSchedStart(VOID);
+
+BOOL OsSchedTaskSwitch(VOID);
+
+LosTaskCB *OsGetTopTask(VOID);
+
+UINT32 OsSchedRealSleepTimeSet(VOID (*func)(UINT64));
+
+VOID OsSchedTimerBaseReset(UINT64 currTime);
+
+/**
+ * @ingroup los_sched
+ * @brief Get the time, in nanoseconds, remaining before the next tick interrupt response.
+ *
+ * @par Description:
+ * This API is used to get the time, in nanoseconds, remaining before the next tick interrupt response.
+ *
+ * @attention None.
+ *
+ * @param  None.
+ *
+ * @retval #time, in nanoseconds.
+ * @par Dependency:
+ * <ul><li>los_sched.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+extern UINT64 LOS_SchedTickTimeoutNsGet(VOID);
+
+/**
+ * @ingroup los_sched
+ * @brief The system-provided tick interrupt handler.
+ *
+ * @par Description:
+ * This API is used to wake up a task that is blocked by time.
+ *
+ * @attention None.
+ *
+ * @param  None.
+ *
+ * @retval None.
+ * @par Dependency:
+ * <ul><li>los_sched.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+extern VOID LOS_SchedTickHandler(VOID);
+
+/**
+ * @ingroup los_sched
+ * @brief Trigger a system dispatch.
+ *
+ * @par Description:
+ * This API is used to trigger a system dispatch.
+ *
+ * @attention None.
+ *
+ * @param  None.
+ *
+ * @retval None.
+ * @par Dependency:
+ * <ul><li>los_sched.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+extern VOID LOS_Schedule(VOID);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_SCHED_H */
diff --git a/kernel/liteos_m/kernel/include/los_sem.h b/kernel/liteos_m/kernel/include/los_sem.h
index ebe148c..cd40368 100644
--- a/kernel/liteos_m/kernel/include/los_sem.h
+++ b/kernel/liteos_m/kernel/include/los_sem.h
@@ -285,10 +285,7 @@ extern UINT32 LOS_SemPend(UINT32 semHandle, UINT32 timeout);
  */
 extern UINT32 LOS_SemPost(UINT32 semHandle);
 
-enum LosSemMaxCount {
-    OS_SEM_COUNTING_MAX_COUNT = 0xFFFF, /**< Max count of counting semaphores */
-    OS_SEM_BINARY_MAX_COUNT = 1         /**< Max count of binary semaphores */
-};
+extern UINT32 LOS_SemGetValue(UINT32 semHandle, INT32 *currVal);
 
 /**
  * @ingroup los_sem
@@ -302,24 +299,30 @@ typedef struct {
     LOS_DL_LIST semList; /**< Queue of tasks that are waiting on a semaphore */
 } LosSemCB;
 
+/**
+ * @ingroup los_config
+ * Max count of binary semaphores.
+ */
+#define OS_SEM_BINARY_MAX_COUNT     1
+
 /**
  * @ingroup los_sem
  * The semaphore is not in use.
- *
  */
-#define OS_SEM_UNUSED 0
+#define OS_SEM_UNUSED               0
+
 /**
  * @ingroup los_sem
  * The semaphore is used.
- *
  */
-#define OS_SEM_USED   1
+#define OS_SEM_USED                 1
+
 /**
  * @ingroup los_sem
  * Obtain the head node in a semaphore doubly linked list.
- *
  */
 #define GET_SEM_LIST(ptr) LOS_DL_LIST_ENTRY(ptr, LosSemCB, semList)
+
 extern LosSemCB *g_allSem;
 /**
  * @ingroup los_sem
@@ -343,7 +346,7 @@ extern LosSemCB *g_allSem;
  *
  * @retval UINT32   Initialization result.
  * @par Dependency:
- * <ul><li>los_sem_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_sem.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsSemInit(VOID);
@@ -365,7 +368,7 @@ extern UINT32 OsSemInit(VOID);
  *
  * @retval UINT32   Create result.
  * @par Dependency:
- * <ul><li>los_sem_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_sem.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 UINT32 OsSemCreate(UINT16 count, UINT16 maxCount, UINT32 *semHandle);
diff --git a/kernel/liteos_m/kernel/include/los_sortlink.h b/kernel/liteos_m/kernel/include/los_sortlink.h
new file mode 100644
index 0000000..d3ae9ac
--- /dev/null
+++ b/kernel/liteos_m/kernel/include/los_sortlink.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_SORTLINK_H
+#define _LOS_SORTLINK_H
+
+#include "los_compiler.h"
+#include "los_list.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+typedef enum {
+    OS_SORT_LINK_TASK = 1,
+    OS_SORT_LINK_SWTMR = 2,
+} SortLinkType;
+
+typedef struct {
+    LOS_DL_LIST sortLinkNode;
+    UINT64      responseTime;
+} SortLinkList;
+
+typedef struct {
+    LOS_DL_LIST sortLink;
+} SortLinkAttribute;
+
+#define OS_SORT_LINK_INVALID_TIME ((UINT64)-1)
+#define SET_SORTLIST_VALUE(sortList, value) (((SortLinkList *)(sortList))->responseTime = (value))
+
+SortLinkAttribute *OsGetSortLinkAttribute(SortLinkType type);
+UINT64 OsGetNextExpireTime(UINT64 startTime);
+UINT32 OsSortLinkInit(SortLinkAttribute *sortLinkHeader);
+VOID OsDeleteNodeSortLink(SortLinkAttribute *sortLinkHeader, SortLinkList *sortList);
+VOID OsAdd2SortLink(SortLinkList *node, UINT64 startTime, UINT32 waitTicks, SortLinkType type);
+VOID OsDeleteSortLink(SortLinkList *node, SortLinkType type);
+UINT32 OsSortLinkGetTargetExpireTime(UINT64 currTime, const SortLinkList *targetSortList);
+UINT32 OsSortLinkGetNextExpireTime(const SortLinkAttribute *sortLinkHeader);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_SORTLINK_H */
diff --git a/kernel/liteos_m/kernel/include/los_swtmr.h b/kernel/liteos_m/kernel/include/los_swtmr.h
index 9842e48..b86f1bf 100644
--- a/kernel/liteos_m/kernel/include/los_swtmr.h
+++ b/kernel/liteos_m/kernel/include/los_swtmr.h
@@ -37,6 +37,8 @@
 #ifndef _LOS_SWTMR_H
 #define _LOS_SWTMR_H
 
+#include "los_config.h"
+#include "los_sortlink.h"
 
 #ifdef __cplusplus
 #if __cplusplus
@@ -279,6 +281,7 @@ typedef struct tagSwTmrCtrl {
     UINT32              uwArg;          /* Parameter passed in when the callback function
                                            that handles software timer timeout is called         */
     SWTMR_PROC_FUNC     pfnHandler;     /* Callback function that handles software timer timeout */
+    SortLinkList        stSortList;
 } SWTMR_CTRL_S;
 
 
@@ -365,7 +368,7 @@ extern UINT32 LOS_SwtmrTimeGet(UINT32 swtmrID, UINT32 *tick);
  * @attention
  * <ul>
  * <li>Do not use the delay interface in the callback function that handles software timer timeout.</li>
- * <li>Threre are LOSCFG_BASE_CORE_SWTMR_LIMIT timers available, change it's value when necessory.</li>
+ * <li>There are LOSCFG_BASE_CORE_SWTMR_LIMIT timers available, change it's value when necessary.</li>
  * </ul>
  *
  * @param  interval     [IN] Timing duration of the software timer to be created (unit: ms).
@@ -451,29 +454,6 @@ extern SWTMR_CTRL_S *g_swtmrCBArray;
 
 #define OS_SWT_FROM_SID(swtmrId)    ((SWTMR_CTRL_S *)g_swtmrCBArray + ((swtmrId) % LOSCFG_BASE_CORE_SWTMR_LIMIT))
 
-/**
- * @ingroup los_swtmr
- * @brief Scan a software timer.
- *
- * @par Description:
- * <ul>
- * <li>This API is used to scan a software timer when a Tick interrupt occurs and determine whether the software timer
-   expires.</li>
- * </ul>
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param  None.
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_swtmr_pri.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_SwtmrStop
- */
-extern UINT32 OsSwtmrScan(VOID);
-
 /**
  * @ingroup los_swtmr
  * @brief Initialization software timer.
@@ -491,7 +471,7 @@ extern UINT32 OsSwtmrScan(VOID);
  *
  * @retval None.
  * @par Dependency:
- * <ul><li>los_swtmr_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_swtmr.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsSwtmrInit(VOID);
@@ -513,7 +493,7 @@ extern UINT32 OsSwtmrInit(VOID);
  *
  * @retval None.
  * @par Dependency:
- * <ul><li>los_swtmr_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_swtmr.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsSwtmrGetNextTimeout(VOID);
@@ -535,7 +515,7 @@ extern UINT32 OsSwtmrGetNextTimeout(VOID);
  *
  * @retval UINT32    Sleep time.
  * @par Dependency:
- * <ul><li>los_swtmr_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_swtmr.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern VOID OsSwtmrAdjust(UINT32 sleepTime);
diff --git a/kernel/liteos_m/kernel/include/los_task.h b/kernel/liteos_m/kernel/include/los_task.h
index 5ef1a69..7cc5a81 100644
--- a/kernel/liteos_m/kernel/include/los_task.h
+++ b/kernel/liteos_m/kernel/include/los_task.h
@@ -37,9 +37,11 @@
 #ifndef _LOS_TASK_H
 #define _LOS_TASK_H
 
-#include "los_tick.h"
+#include "los_config.h"
 #include "los_context.h"
 #include "los_event.h"
+#include "los_tick.h"
+#include "los_sortlink.h"
 
 #ifdef __cplusplus
 #if __cplusplus
@@ -367,19 +369,7 @@ extern "C" {
  */
 #define LOS_ERRNO_TSK_OPERATE_SWTMR                 LOS_ERRNO_OS_ERROR(LOS_MOD_TSK, 0x22)
 
-/**
- * @ingroup los_task
- * Define the type of the task switching hook function.
- *
- */
-typedef VOID (*TSKSWITCHHOOK)(VOID);
-
-/**
- * @ingroup los_task
- * User task switching hook function.
- *
- */
-extern TSKSWITCHHOOK g_pfnUsrTskSwitchHook;
+#define LOS_ERRNO_TSK_TIMEOUT                       LOS_ERRNO_OS_ERROR(LOS_MOD_TSK, 0x23)
 
 /**
  * @ingroup los_task
@@ -435,24 +425,20 @@ typedef struct tagTskInfo {
     BOOL                bOvf;                       /**< Flag that indicates whether a task stack overflow occurs */
 } TSK_INFO_S;
 
-
-
 /**
- * @ingroup los_base
+ * @ingroup los_task
  * Define the timeout interval as LOS_NO_WAIT.
  */
 #define LOS_NO_WAIT                      0
 
 /**
- * @ingroup los_base
+ * @ingroup los_task
  * Define the timeout interval as LOS_WAIT_FOREVER.
  */
 #define LOS_WAIT_FOREVER                 0xFFFFFFFF
 
-
-
 /**
- * @ingroup los_base
+ * @ingroup los_task
  * @brief Sleep the current task.
  *
  * @par Description:
@@ -474,13 +460,13 @@ typedef struct tagTskInfo {
  *
  * @retval None
  * @par Dependency:
- * <ul><li>los_base.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see None
  */
 extern VOID LOS_Msleep(UINT32 mSecs);
 
 /**
- * @ingroup los_base
+ * @ingroup los_task
  * @brief System kernel initialization function.
  *
  * @par Description:
@@ -500,12 +486,11 @@ extern VOID LOS_Msleep(UINT32 mSecs);
  * @see
  */
 extern UINT32 LOS_Start(VOID);
-extern VOID LOS_Reboot(VOID);
-extern VOID LOS_Panic(const CHAR *fmt, ...);
-
+extern NORETURN VOID LOS_Reboot(VOID);
+extern NORETURN VOID LOS_Panic(const CHAR *fmt, ...);
 
 /**
- * @ingroup los_base
+ * @ingroup los_task
  * @brief System kernel initialization function.
  *
  * @par Description:
@@ -1053,7 +1038,7 @@ extern BOOL LOS_TaskIsRunning(VOID);
  * @brief Obtain current new task ID.
  *
  * @par Description:
- * This API is used to obtain the ID of new  task.
+ * This API is used to obtain the ID of new task.
  *
  * @attention None.
  *
@@ -1067,10 +1052,10 @@ extern BOOL LOS_TaskIsRunning(VOID);
 extern  UINT32 LOS_NewTaskIDGet(VOID);
  /**
   * @ingroup  los_task
-  * @brief Obtain current new task name.
+  * @brief Obtain the task name.
   *
   * @par Description:
-  * This API is used to obtain the name of new  task.
+  * This API is used to obtain the task name.
   *
   * @attention None.
   *
@@ -1084,279 +1069,24 @@ extern  UINT32 LOS_NewTaskIDGet(VOID);
   */
 extern CHAR* LOS_TaskNameGet(UINT32 taskID);
 
-
 /* *
- * @ingroup  los_hw
- * @brief: Function to determine whether task scheduling is required.
+ * @ingroup  los_task
+ * @brief: cpu delay.
  *
  * @par Description:
- * This API is used to Judge and entry task scheduling.
+ * This API is used to cpu delay, no task switching.
  *
  * @attention:
  * <ul><li>None.</li></ul>
  *
- * @param  None.
+ * @param  UINT64  [IN] delay times, microseconds.
  *
  * @retval: None.
  * @par Dependency:
- * <ul><li>los_hw.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
-extern VOID LOS_Schedule(VOID);
-
-extern UINT32 OsTaskNextSwitchTimeGet(VOID);
-
-
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The request for memory fails.
-*
-* Value: 0x02001e00
-*
-* Solution: Decrease the maximum number of tasks.
-*/
-#define LOS_ERRNO_CPUP_NO_MEMORY             LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x00)
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The pointer to an input parameter is NULL.
-*
-* Value: 0x02001e01
-*
-* Solution: Check whether the pointer to the input parameter is usable.
-*/
-#define LOS_ERRNO_CPUP_TASK_PTR_NULL         LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x01)
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The CPU usage is not initialized.
-*
-* Value: 0x02001e02
-*
-* Solution: Check whether the CPU usage is initialized.
-*/
-#define LOS_ERRNO_CPUP_NO_INIT               LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x02)
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The number of threads is invalid.
-*
-* Value: 0x02001e03
-*
-* Solution: Check whether the number of threads is applicable for the current operation.
-*/
-#define LOS_ERRNO_CPUP_MAXNUM_INVALID        LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x03)
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The target thread is not created.
-*
-* Value: 0x02001e04
-*
-* Solution: Check whether the target thread is created.
-*/
-#define LOS_ERRNO_CPUP_THREAD_NO_CREATED     LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x04)
-
-/**
-* @ingroup los_cpup
-* CPU usage error code: The target task ID is invalid.
-*
-* Value: 0x02001e05
-*
-* Solution: Check whether the target task ID is applicable for the current operation.
-*/
-#define LOS_ERRNO_CPUP_TSK_ID_INVALID        LOS_ERRNO_OS_ERROR(LOS_MOD_CPUP, 0x05)
-
-/**
-* @ingroup los_cpup
-* Sum of cpup with all tasks. It means the value of cpup is a permillage.
-*/
-#define LOS_CPUP_PRECISION                   1000
-
-/**
-* @ingroup los_cpup
-* Multiple of current cpup precision change to percent.
-*/
-#define LOS_CPUP_PRECISION_MULT              (LOS_CPUP_PRECISION / 100)
-
-/**
- * @ingroup los_cpup
- * Count the CPU usage structures of all tasks.
- */
-typedef struct tagCpupInfo {
-    UINT16 usStatus;            /**< save the cur task status     */
-    UINT32 uwUsage;             /**< Usage. The value range is [0,1000].   */
-} CPUP_INFO_S;
-
-/**
- * @ingroup los_monitor
- * Type of the CPU usage query.
- */
-typedef enum {
-    SYS_CPU_USAGE = 0,   /* system cpu occupancy rate */
-    TASK_CPU_USAGE,      /* task cpu occupancy rate */
-} CPUP_TYPE_E;
-
-/**
- * @ingroup los_monitor
- * Mode of the CPU usage query.
- */
-typedef enum {
-    CPUP_IN_10S = 0,     /* cpu occupancy rate in 10s */
-    CPUP_IN_1S,          /* cpu occupancy rate in 1s */
-    CPUP_LESS_THAN_1S,   /* cpu occupancy rate less than 1s, if the input mode is none of them, it will be this. */
-} CPUP_MODE_E;
-
-/**
- * @ingroup los_cpup
- * @brief Obtain the current CPU usage.
- *
- * @par Description:
- * This API is used to obtain the current CPU usage.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise, error codes will be returned.</li>
- * <li> The precision of the CPU usage can be adjusted by changing the value of the CPUP_PRECISION macro.</li>
- * </ul>
- *
- * @param None.
- *
- * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
- * @retval #cpup                            [0,100], current CPU usage, of which the precision is adjustable.
- * @par Dependency:
- * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_SysCpuUsage
- */
-extern UINT32 LOS_SysCpuUsage(VOID);
-
-/**
- * @ingroup los_cpup
- * @brief Obtain the historical CPU usage.
- *
- * @par Description:
- * This API is used to obtain the historical CPU usage.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
- * </ul>
- *
- * @param  mode     [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s will be
- * obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained. Other values
- * indicate that the CPU usage in the period that is less than 1s will be obtained.
- *
- * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
- * @retval #cpup                            [0,100], historical CPU usage, of which the precision is adjustable.
- * @par Dependency:
- * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_HistoryTaskCpuUsage
- */
-extern UINT32 LOS_HistorySysCpuUsage(UINT16 mode);
-
-/**
- * @ingroup los_cpup
- * @brief Obtain the CPU usage of a specified task.
- *
- * @par Description:
- * This API is used to obtain the CPU usage of a task specified by a passed-in task ID.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
- * <li>The passed-in task ID must be valid and the task specified by the task ID must be created. Otherwise,
- * the CPU usage fails to be obtained.</li>
- * </ul>
- *
- * @param taskID   [IN] UINT32. Task ID.
- *
- * @retval #OS_ERRNO_CPUP_NO_INIT             0x02001e02: The CPU usage is not initialized.
- * @retval #OS_ERRNO_CPUP_TSK_ID_INVALID      0x02001e05: The target task ID is invalid.
- * @retval #OS_ERRNO_CPUP_THREAD_NO_CREATED   0x02001e04: The target thread is not created.
- * @retval #cpup                              [0,100], CPU usage of the specified task.
- * @par Dependency:
- * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_HistoryTaskCpuUsage
- */
-extern UINT32 LOS_TaskCpuUsage(UINT32 taskID);
-
-/**
- * @ingroup los_cpup
- * @brief  Obtain the historical CPU usage of a specified task.
- *
- * @par Description:
- * This API is used to obtain the historical CPU usage of a task specified by a passed-in task ID.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise,
- * the CPU usage fails to be obtained.</li>
- * <li>The passed-in task ID must be valid and the task specified by the task ID must be created. Otherwise,
- * the CPU usage fails to be obtained.</li>
- * </ul>
- *
- * @param taskID   [IN] UINT32. Task ID.
- * @param mode     [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s
- * will be obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained.
- * Other values indicate that the CPU usage in the period that is less than 1s will be obtained.
- *
- * @retval #OS_ERRNO_CPUP_NO_INIT             0x02001e02: The CPU usage is not initialized.
- * @retval #OS_ERRNO_CPUP_TSK_ID_INVALID      0x02001e05: The target task ID is invalid.
- * @retval #OS_ERRNO_CPUP_THREAD_NO_CREATED   0x02001e04: The target thread is not created.
- * @retval #cpup                              [0,100], CPU usage of the specified task.
- * @par Dependency:
- * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_HistorySysCpuUsage
- */
-extern UINT32 LOS_HistoryTaskCpuUsage(UINT32 taskID, UINT16 mode);
-
-/**
- * @ingroup los_cpup
- * @brief Obtain the CPU usage of all tasks.
- *
- * @par Description:
- * This API is used to obtain the CPU usage of all tasks according to maximum number of threads.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise, the CPU usage fails to be obtained.</li>
- * <li>The input parameter pointer must not be NULL, Otherwise, the CPU usage fails to be obtained.</li>
- * </ul>
- *
- * @param cpupInfo    [OUT]Type.   CPUP_INFO_S* Pointer to the task CPUP information structure to be obtained.
- * @param mode        [IN] UINT16. Task mode. The parameter value 0 indicates that the CPU usage within 10s
- * will be obtained, and the parameter value 1 indicates that the CPU usage in the former 1s will be obtained.
- * Other values indicate that the CPU usage in the period that is less than 1s will be obtained.
- *
- * @retval #OS_ERRNO_CPUP_NO_INIT           0x02001e02: The CPU usage is not initialized.
- * @retval #OS_ERRNO_CPUP_TASK_PTR_NULL     0x02001e01: The input parameter pointer is NULL.
- * @retval #LOS_OK                          0x00000000: The CPU usage of all tasks is successfully obtained.
- * @par Dependency:
- * <ul><li>los_cpup.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_SysCpuUsage
- */
-extern UINT32 LOS_AllTaskCpuUsage(CPUP_INFO_S *cpupInfo, UINT16 mode);
-
-/**
- * @ingroup los_monitor
- * @brief Obtain CPU usage history of certain task.
- *
- * @par Description:
- * This API is used to obtain CPU usage history of certain task.
- * @attention
- * <ul>
- * <li>This API can be called only after the CPU usage is initialized. Otherwise, -1 will be returned.</li>
- * <li> Only in SYS_CPU_USAGE type, uwTaskID is invalid.</li>
- * </ul>
- *
- * @param type        [IN] cpup type, SYS_CPU_USAGE and TASK_CPU_USAGE
- * @param mode        [IN] mode,CPUP_IN_10S = usage in 10s,CPUP_IN_1S = usage in last 1s,
- * CPUP_LESS_THAN_1S = less than 1s, if the inpuit mode is none of them, it will be as CPUP_LESS_THAN_1S.
- * @param taskID      [IN] task ID, Only in SYS_CPU_USAGE type, taskID is invalid
- *
- * @retval #OS_ERROR           -1:CPU usage info obtain failed.
- * @retval #LOS_OK              0:CPU usage info is successfully obtained.
- * @par Dependency:
- * <ul><li>los_monitor.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_CpupUsageMonitor
- */
-extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 taskID);
+extern VOID LOS_UDelay(UINT64 microseconds);
 
 /**
  * @ingroup los_task
@@ -1441,33 +1171,9 @@ extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 ta
  * @ingroup los_task
  * Flag that indicates the task or task control block status.
  *
- * The task is waiting for an event to occur.
- */
-#define OS_TASK_STATUS_EVENT                        0x0400
-
-/**
- * @ingroup los_task
- * Flag that indicates the task or task control block status.
- *
- * The task is reading an event.
- */
-#define OS_TASK_STATUS_EVENT_READ                   0x0800
-
-/**
- * @ingroup los_task
- * Flag that indicates the task or task control block status.
- *
- * A software timer is waiting for an event to occur.
+ * The task is blocked on a time.
  */
-#define OS_TASK_STATUS_SWTMR_WAIT                   0x1000
-
-/**
- * @ingroup los_task
- * Flag that indicates the task or task control block status.
- *
- * The task is blocked on a queue.
- */
-#define OS_TASK_STATUS_PEND_QUEUE                   0x2000
+#define OS_TASK_STATUS_PEND_TIME                    0x0080
 
 /**
  * @ingroup los_task
@@ -1551,13 +1257,13 @@ extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 ta
  * @ingroup los_task
  * @brief the high-order mask of roll num.
  */
-#define OS_TSK_HIGH_BITS_MASK  (OS_TSK_SORTLINK_MASK << OS_TSK_LOW_BITS)
+#define OS_TSK_HIGH_BITS_MASK                       (OS_TSK_SORTLINK_MASK << OS_TSK_LOW_BITS)
 
 /**
  * @ingroup los_task
  * @brief the low-order mask of roll num.
  */
-#define OS_TSK_LOW_BITS_MASK   (~OS_TSK_HIGH_BITS_MASK)
+#define OS_TSK_LOW_BITS_MASK                        (~OS_TSK_HIGH_BITS_MASK)
 
 /**
  * @ingroup los_task
@@ -1567,20 +1273,20 @@ extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 ta
 
 /**
  * @ingroup  los_task
- * @brief Check whether a task ID is valid.
+ * @brief Get the real task ID.
  *
  * @par Description:
- * This API is used to check whether a task ID, excluding the idle task ID, is valid.
+ * This API is used to get the real task ID.
  * @attention None.
  *
  * @param  taskID [IN] Task ID.
  *
- * @retval 0 or 1. One indicates that the task ID is invalid, whereas zero indicates that the task ID is valid.
+ * @retval  real task ID.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
-#define OS_TSK_GET_INDEX(taskID)                      (taskID)
+#define OS_TSK_GET_INDEX(taskID)                        (taskID)
 
 /**
  * @ingroup  los_task
@@ -1594,7 +1300,7 @@ extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 ta
  *
  * @retval Pointer to the task control block.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 #define OS_TCB_FROM_PENDLIST(ptr)                       LOS_DL_LIST_ENTRY(ptr, LosTaskCB, pendList)
@@ -1611,11 +1317,11 @@ extern UINT32 LOS_CpupUsageMonitor(CPUP_TYPE_E type, CPUP_MODE_E mode, UINT32 ta
  *
  * @retval Pointer to the task control block.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
-#define OS_TCB_FROM_TID(taskID)                       (((LosTaskCB *)g_taskCBArray) + (taskID))
-#define OS_IDLE_TASK_ENTRY                            ((TSK_ENTRY_FUNC)OsIdleTask)
+#define OS_TCB_FROM_TID(taskID)                         (((LosTaskCB *)g_taskCBArray) + (taskID))
+#define OS_IDLE_TASK_ENTRY                              ((TSK_ENTRY_FUNC)OsIdleTask)
 
 
 /**
@@ -1626,6 +1332,10 @@ typedef struct {
     VOID                        *stackPointer;            /**< Task stack pointer */
     UINT16                      taskStatus;
     UINT16                      priority;
+    INT32                       timeSlice;
+    UINT32                      waitTimes;
+    SortLinkList                sortList;
+    UINT64                      startTime;
     UINT32                      stackSize;                /**< Task stack size */
     UINT32                      topOfStack;               /**< Task stack top */
     UINT32                      taskID;                   /**< Task ID */
@@ -1636,7 +1346,6 @@ typedef struct {
     CHAR                        *taskName;                /**< Task name */
     LOS_DL_LIST                 pendList;
     LOS_DL_LIST                 timerList;
-    UINT32                      idxRollNum;
     EVENT_CB_S                  event;
     UINT32                      eventMask;                /**< Event mask */
     UINT32                      eventMode;                /**< Event mode */
@@ -1699,8 +1408,7 @@ extern UINT16               g_losTaskLock;
  * @ingroup los_hw
  * Check task schedule.
  */
-#define LOS_CHECK_SCHEDULE ((!g_losTaskLock))
-
+#define LOS_CHECK_SCHEDULE (!g_losTaskLock)
 
 /**
  * @ingroup los_task
@@ -1744,50 +1452,6 @@ extern LOS_DL_LIST          g_losFreeTask;
  */
 extern LOS_DL_LIST          g_taskRecyleList;
 
-/**
- * @ingroup  los_task
- * @brief Modify the priority of task.
- *
- * @par Description:
- * This API is used to modify the priority of task.
- *
- * @attention
- * <ul>
- * <li>The taskCB should be a correct pointer to task control block structure.</li>
- * <li>the priority should be in [0, OS_TASK_PRIORITY_LOWEST].</li>
- * </ul>
- *
- * @param  taskCB    [IN] Type #LosTaskCB * pointer to task control block structure.
- * @param  priority  [IN] Type #UINT16 the priority of task.
- *
- * @retval  None.
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see
- */
-extern VOID OsTaskPriModify(LosTaskCB *taskCB, UINT16 priority);
-
-/**
- * @ingroup  los_task
- * @brief Scan a task.
- *
- * @par Description:
- * This API is used to scan a task.
- *
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param  None.
- *
- * @retval  None.
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see
- */
-extern VOID OsTaskScan(VOID);
-
 /**
  * @ingroup  los_task
  * @brief Initialization a task.
@@ -1804,7 +1468,7 @@ extern VOID OsTaskScan(VOID);
  *
  * @retval  UINT32    Initialization result.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 extern UINT32 OsTaskInit(VOID);
@@ -1825,7 +1489,7 @@ extern UINT32 OsTaskInit(VOID);
  *
  * @retval  UINT32   Create result.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 extern UINT32 OsIdleTaskCreate(VOID);
@@ -1846,7 +1510,7 @@ extern UINT32 OsIdleTaskCreate(VOID);
  *
  * @retval  None.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 extern VOID OsTaskSwitchCheck(VOID);
@@ -1867,7 +1531,7 @@ extern VOID OsTaskSwitchCheck(VOID);
  *
  * @retval  None.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 extern VOID OsTaskMonInit(VOID);
@@ -1888,57 +1552,11 @@ extern VOID OsTaskMonInit(VOID);
  *
  * @retval  None.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see
  */
 extern VOID OsTaskEntry(UINT32 taskID);
 
-/**
- * @ingroup  los_task
- * @brief pend running task to pendlist
- *
- * @par Description:
- * This API is used to pend task to  pendlist and add to sorted delay list.
- *
- * @attention
- * <ul>
- * <li>The pstList should be a vaild pointer to pendlist.</li>
- * </ul>
- *
- * @param  list       [IN] Type #LOS_DL_LIST * pointer to list which running task will be pended.
- * @param  taskStatus [IN] Type #UINT32  Task Status.
- * @param  timeOut    [IN] Type #UINT32  Expiry time. The value range is [0,LOS_WAIT_FOREVER].
- *
- * @retval  LOS_OK       wait success
- * @retval  LOS_NOK      pend out
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see OsTaskWake
- */
-extern VOID OsTaskWait(LOS_DL_LIST *list, UINT32 taskStatus, UINT32 timeOut);
-
-/**
- * @ingroup  los_task
- * @brief delete task from pendlist.
- *
- * @par Description:
- * This API is used to delete task from pendlist and also add to the priqueue.
- *
- * @attention
- * <ul>
- * <li>The pstList should be a vaild pointer to pend list.</li>
- * </ul>
- *
- * @param  resumedTask [IN] Type #LosTaskCB * pointer to the task which will be add to priqueue.
- * @param  taskStatus  [IN] Type #UINT32  Task Status.
- *
- * @retval  None.
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see OsTaskWait
- */
-extern VOID OsTaskWake(LosTaskCB *resumedTask, UINT32 taskStatus);
-
 /**
  * @ingroup  los_task
  * @brief Get the task water line.
@@ -1955,7 +1573,7 @@ extern VOID OsTaskWake(LosTaskCB *resumedTask, UINT32 taskStatus);
  *
  * @retval  UINT32  Task water line.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsGetTaskWaterLine(UINT32 taskID);
@@ -1976,54 +1594,11 @@ extern UINT32 OsGetTaskWaterLine(UINT32 taskID);
  *
  * @retval  UINT8 *  String.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT8 *OsConvertTskStatus(UINT16 taskStatus);
 
-/**
- * @ingroup  los_task
- * @brief Add task to sorted delay list.
- *
- * @par Description:
- * This API is used to add task to sorted delay list.
- *
- * @attention
- * <ul>
- * <li>The taskCB should be a correct pointer to task control block structure.</li>
- * </ul>
- *
- * @param  taskCB     [IN] Type #LosTaskCB * pointer to task control block structure.
- * @param  timeout    [IN] Type #UINT32 wait time, ticks.
- *
- * @retval  None.
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see OsTimerListDelete
- */
-extern VOID OsTaskAdd2TimerList(LosTaskCB *taskCB, UINT32 timeout);
-
-/**
- * @ingroup  los_task
- * @brief delete task from sorted delay list.
- *
- * @par Description:
- * This API is used to delete task from sorted delay list.
- *
- * @attention
- * <ul>
- * <li>The taskCB should be a correct pointer to task control block structure.</li>
- * </ul>
- *
- * @param  taskCB [IN] Type #LosTaskCB * pointer to task control block structure.
- *
- * @retval  None.
- * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
- * @see OsTaskAdd2TimerList
- */
-extern VOID OsTimerListDelete(LosTaskCB *taskCB);
-
 /**
  * @ingroup  los_task
  * @brief Get all task information.
@@ -2040,57 +1615,14 @@ extern VOID OsTimerListDelete(LosTaskCB *taskCB);
  *
  * @retval  UINT32  All task information.
  * @par Dependency:
- * <ul><li>los_task_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsGetAllTskInfo(VOID);
 
 extern VOID *OsTskUserStackInit(VOID* stackPtr, VOID* userSP, UINT32 userStackSize);
 
-/**
- * @ingroup los_timeslice
- * @brief Initialize time slices.
- *
- * @par Description:
- * <ul>
- * <li>This API is used to initialize time slices that defines the cycle of time slices according to
-   LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT.</li>
- * </ul>
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param None.
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_timeslice_pri.h: the header file that contains the API declaration.</li></ul>
- * @see None.
- */
-extern VOID OsTimesliceInit(VOID);
-
-/**
- * @ingroup los_timeslice
- * @brief Check time slices.
- *
- * @par Description:
- * <ul>
- * <li>This API is used to check time slices. If the number of Ticks equals to the time for task switch, tasks are switched. Otherwise, the Tick counting continues.</li>
- * </ul>
- * @attention
- * <ul>
- * <li>None.</li>
- * </ul>
- *
- * @param None.
- *
- * @retval None.
- * @par Dependency:
- * <ul><li>los_timeslice_pri.h: the header file that contains the API declaration.</li></ul>
- * @see None.
- */
-extern VOID OsTimesliceCheck(VOID);
+extern UINT32 OsPmEnterHandlerSet(VOID (*func)(BOOL));
 
 #ifdef __cplusplus
 #if __cplusplus
diff --git a/kernel/liteos_m/kernel/include/los_tick.h b/kernel/liteos_m/kernel/include/los_tick.h
index ea8f51d..a11931f 100644
--- a/kernel/liteos_m/kernel/include/los_tick.h
+++ b/kernel/liteos_m/kernel/include/los_tick.h
@@ -30,7 +30,7 @@
  */
 
 /**
- * @defgroup los_tick Tick
+ * @defgroup los_tick
  * @ingroup kernel
  */
 
@@ -79,41 +79,59 @@ extern "C" {
 
 /**
  *  @ingroup  los_tick
- *  @brief: System clock get function.
+ *  @brief: System timer cycles get function.
  *
  *  @par Description:
- *  This API is used to get system clock.
+ *  This API is used to get system timer cycles.
  *
  * @attention:
  * <ul><li>None.</li></ul>
  *
  * @param: None.
  *
- * @retval: system clock.
+ * @retval: current system cycles.
  *
  * @par Dependency:
  * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  *
  * */
-extern UINT32 LOS_SysClockGet(VOID);
-
-
+extern UINT64 LOS_SysCycleGet(VOID);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * Number of milliseconds in one second.
  */
 #define OS_SYS_MS_PER_SECOND   1000
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * Number of microseconds in one second.
  */
 #define OS_SYS_US_PER_SECOND   1000000
 
+#define OS_SYS_NS_PER_SECOND   1000000000
+
+#define OS_SYS_NS_PER_US       1000
+
+#define OS_CYCLE_PER_TICK      (OS_SYS_CLOCK / LOSCFG_BASE_CORE_TICK_PER_SECOND)
+
+#define OS_NS_PER_CYCLE        (OS_SYS_NS_PER_SECOND / OS_SYS_CLOCK)
+
+#define OS_MS_PER_TICK         (OS_SYS_MS_PER_SECOND / LOSCFG_BASE_CORE_TICK_PER_SECOND)
+
+#define OS_US_PER_TICK         (OS_SYS_US_PER_SECOND / LOSCFG_BASE_CORE_TICK_PER_SECOND)
+
+#define OS_NS_PER_TICK         (OS_SYS_NS_PER_SECOND / LOSCFG_BASE_CORE_TICK_PER_SECOND)
+
+#define OS_SYS_CYCLE_TO_NS(cycle, freq)  (((cycle) / (freq)) * OS_SYS_NS_PER_SECOND + \
+    ((cycle) % OS_SYS_CLOCK) * OS_SYS_NS_PER_SECOND / (freq))
+
+#define OS_SYS_NS_TO_CYCLE(time, freq) (((time) / OS_SYS_NS_PER_SECOND) * (freq) +     \
+    (time % OS_SYS_NS_PER_SECOND) * (freq) / OS_SYS_NS_PER_SECOND)
+
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * System time basic function error code: Null pointer.
  *
  * Value: 0x02000010
@@ -123,7 +141,7 @@ extern UINT32 LOS_SysClockGet(VOID);
 #define LOS_ERRNO_SYS_PTR_NULL                 LOS_ERRNO_OS_ERROR(LOS_MOD_SYS, 0x10)
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * System time basic function error code: Invalid system clock configuration.
  *
  * Value: 0x02000011
@@ -133,7 +151,7 @@ extern UINT32 LOS_SysClockGet(VOID);
 #define LOS_ERRNO_SYS_CLOCK_INVALID            LOS_ERRNO_OS_ERROR(LOS_MOD_SYS, 0x11)
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * System time basic function error code: This error code is not in use temporarily.
  *
  * Value: 0x02000012
@@ -143,7 +161,7 @@ extern UINT32 LOS_SysClockGet(VOID);
 #define LOS_ERRNO_SYS_MAXNUMOFCORES_IS_INVALID LOS_ERRNO_OS_ERROR(LOS_MOD_SYS, 0x12)
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * System time error code: This error code is not in use temporarily.
  *
  * Value: 0x02000013
@@ -153,7 +171,7 @@ extern UINT32 LOS_SysClockGet(VOID);
 #define LOS_ERRNO_SYS_PERIERRCOREID_IS_INVALID LOS_ERRNO_OS_ERROR(LOS_MOD_SYS, 0x13)
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * System time error code: This error code is not in use temporarily.
  *
  * Value: 0x02000014
@@ -163,10 +181,10 @@ extern UINT32 LOS_SysClockGet(VOID);
 #define LOS_ERRNO_SYS_HOOK_IS_FULL             LOS_ERRNO_OS_ERROR(LOS_MOD_SYS, 0x14)
 
 /**
- * @ingroup los_typedef
+ * @ingroup los_tick
  * system time structure.
  */
-typedef struct tagSysTime {
+typedef struct TagSysTime {
     UINT16  uwYear;    /**< value 1970 ~ 2038 or 1970 ~ 2100 */
     UINT8   ucMonth;   /**< value 1 - 12 */
     UINT8   ucDay;     /**< value 1 - 31 */
@@ -177,7 +195,7 @@ typedef struct tagSysTime {
 } SYS_TIME_S;
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Obtain the number of Ticks.
  *
  * @par Description:
@@ -191,13 +209,13 @@ typedef struct tagSysTime {
  *
  * @retval UINT64 The number of Ticks.
  * @par Dependency:
- * <ul><li>los_sys.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None
  */
 extern UINT64 LOS_TickCountGet(VOID);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Obtain the number of cycles in one second.
  *
  * @par Description:
@@ -211,13 +229,13 @@ extern UINT64 LOS_TickCountGet(VOID);
  *
  * @retval UINT32 Number of cycles obtained in one second.
  * @par Dependency:
- * <ul><li>los_sys.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None
  */
 extern UINT32 LOS_CyclePerTickGet(VOID);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert Ticks to milliseconds.
  *
  * @par Description:
@@ -232,13 +250,13 @@ extern UINT32 LOS_CyclePerTickGet(VOID);
  * @retval UINT32 Number of milliseconds obtained through the conversion. Ticks are successfully converted to
  * milliseconds.
  * @par  Dependency:
- * <ul><li>los_sys.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see LOS_MS2Tick
  */
 extern UINT32 LOS_Tick2MS(UINT32 ticks);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert milliseconds to Ticks.
  *
  * @par Description:
@@ -253,17 +271,11 @@ extern UINT32 LOS_Tick2MS(UINT32 ticks);
  *
  * @retval UINT32 Number of Ticks obtained through the conversion.
  * @par Dependency:
- * <ul><li>los_sys.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see LOS_Tick2MS
  */
 extern UINT32 LOS_MS2Tick(UINT32 millisec);
 
-/**
- * @ingroup los_tick
- * Count of Ticks
- */
-extern UINT64 g_ullTickCount;
-
 /**
  * @ingroup los_tick
  * Ticks per second
@@ -287,6 +299,7 @@ extern UINT32    g_cyclesPerTick;
  * System Clock
  */
 extern UINT32    g_sysClock;
+
 /**
  * @ingroup  los_tick
  * @brief Handle the system tick timeout.
@@ -303,58 +316,58 @@ extern UINT32    g_sysClock;
  *
  * @retval None.
  * @par Dependency:
- * <ul><li>los_tick_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern VOID OsTickHandler(VOID);
 
 /**
- * @ingroup los_base
+ * @ingroup los_tick
  * Define the CPU Tick structure.
  */
-typedef struct tagCpuTick {
+typedef struct TagCpuTick {
     UINT32 cntHi; /* < Upper 32 bits of the tick value */
     UINT32 cntLo; /* < Lower 32 bits of the tick value */
 } CpuTick;
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * Number of operable bits of a 32-bit operand
  */
 #define OS_SYS_MV_32_BIT       32
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * Number of milliseconds in one second.
  */
 #define OS_SYS_MS_PER_SECOND   1000
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * Number of microseconds in one second.
  */
 #define OS_SYS_US_PER_SECOND   1000000
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * The maximum length of name.
  */
 #define OS_SYS_APPVER_NAME_MAX 64
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * The magic word.
  */
 #define OS_SYS_MAGIC_WORD      0xAAAAAAAA
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * The initialization value of stack space.
  */
 #define OS_SYS_EMPTY_STACK     0xCACACACA
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert cycles to milliseconds.
  *
  * @par Description:
@@ -371,13 +384,13 @@ typedef struct tagCpuTick {
  * @retval #LOS_ERRNO_SYS_PTR_NULL    0x02000011: Invalid parameter.
  * @retval #LOS_OK                   0:  Cycles are successfully converted to microseconds.
  * @par Dependency:
- * <ul><li>los_sys_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsCpuTick2MS(CpuTick *cpuTick, UINT32 *msHi, UINT32 *msLo);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert cycles to microseconds.
  *
  * @par Description:
@@ -394,13 +407,13 @@ extern UINT32 OsCpuTick2MS(CpuTick *cpuTick, UINT32 *msHi, UINT32 *msLo);
  * @retval #LOS_ERRNO_SYS_PTR_NULL    0x02000011: Invalid parameter.
  * @retval #LOS_OK                   0: Cycles are successfully converted to microseconds.
  * @par Dependency:
- * <ul><li>los_sys_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 extern UINT32 OsCpuTick2US(CpuTick *cpuTick, UINT32 *usHi, UINT32 *usLo);
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert cycles to milliseconds.
  *
  * @par Description:
@@ -414,7 +427,7 @@ extern UINT32 OsCpuTick2US(CpuTick *cpuTick, UINT32 *usHi, UINT32 *usLo);
  *
  * @retval Number of milliseconds obtained through the conversion.    Cycles are successfully converted to milliseconds.
  * @par Dependency:
- * <ul><li>los_sys_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 STATIC_INLINE UINT64 OsCycle2MS(UINT64 cycle)
@@ -423,7 +436,7 @@ STATIC_INLINE UINT64 OsCycle2MS(UINT64 cycle)
 }
 
 /**
- * @ingroup los_sys
+ * @ingroup los_tick
  * @brief Convert cycles to microseconds.
  *
  * @par Description:
@@ -437,7 +450,7 @@ STATIC_INLINE UINT64 OsCycle2MS(UINT64 cycle)
  *
  * @retval Number of microseconds obtained through the conversion. Cycles are successfully converted to microseconds.
  * @par Dependency:
- * <ul><li>los_sys_pri.h: the header file that contains the API declaration.</li></ul>
+ * <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>
  * @see None.
  */
 STATIC_INLINE UINT64 OsCycle2US(UINT64 cycle)
diff --git a/kernel/liteos_m/kernel/src/los_event.c b/kernel/liteos_m/kernel/src/los_event.c
index f1ab2af..d2e5520 100644
--- a/kernel/liteos_m/kernel/src/los_event.c
+++ b/kernel/liteos_m/kernel/src/los_event.c
@@ -29,13 +29,12 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "los_task.h"
+#include "los_event.h"
+#include "los_hook.h"
 #include "los_interrupt.h"
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif
-#endif /* __cplusplus */
+#include "los_task.h"
+#include "los_sched.h"
+
 
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventInit(PEVENT_CB_S eventCB)
 {
@@ -44,13 +43,14 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventInit(PEVENT_CB_S eventCB)
     }
     eventCB->uwEventID = 0;
     LOS_ListInit(&eventCB->stEventList);
+    OsHookCall(LOS_HOOK_TYPE_EVENT_INIT, eventCB);
     return LOS_OK;
 }
 
 LITE_OS_SEC_TEXT UINT32 LOS_EventPoll(UINT32 *eventID, UINT32 eventMask, UINT32 mode)
 {
     UINT32 ret = 0;
-    UINTPTR intSave;
+    UINT32 intSave;
 
     if (eventID == NULL) {
         return LOS_ERRNO_EVENT_PTR_NULL;
@@ -97,7 +97,7 @@ LITE_OS_SEC_TEXT STATIC_INLINE UINT32 OsEventReadParamCheck(PEVENT_CB_S eventCB,
 LITE_OS_SEC_TEXT UINT32 LOS_EventRead(PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode, UINT32 timeOut)
 {
     UINT32 ret;
-    UINTPTR intSave;
+    UINT32 intSave;
     LosTaskCB *runTsk = NULL;
 
     ret = OsEventReadParamCheck(eventCB, eventMask, mode);
@@ -110,6 +110,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventRead(PEVENT_CB_S eventCB, UINT32 eventMask, UIN
     }
     intSave = LOS_IntLock();
     ret = LOS_EventPoll(&(eventCB->uwEventID), eventMask, mode);
+    OsHookCall(LOS_HOOK_TYPE_EVENT_READ, eventCB, eventMask, mode);
     if (ret == 0) {
         if (timeOut == 0) {
             LOS_IntRestore(intSave);
@@ -123,22 +124,21 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventRead(PEVENT_CB_S eventCB, UINT32 eventMask, UIN
         runTsk = g_losTask.runTask;
         runTsk->eventMask = eventMask;
         runTsk->eventMode = mode;
-        OsTaskWait(&eventCB->stEventList, OS_TASK_STATUS_PEND, timeOut);
+        OsSchedTaskWait(&eventCB->stEventList, timeOut);
         LOS_IntRestore(intSave);
         LOS_Schedule();
 
+        intSave = LOS_IntLock();
         if (runTsk->taskStatus & OS_TASK_STATUS_TIMEOUT) {
-            intSave = LOS_IntLock();
-            runTsk->taskStatus &= (~OS_TASK_STATUS_TIMEOUT);
+            runTsk->taskStatus &= ~OS_TASK_STATUS_TIMEOUT;
             LOS_IntRestore(intSave);
             return LOS_ERRNO_EVENT_READ_TIMEOUT;
         }
-        intSave = LOS_IntLock();
+
         ret = LOS_EventPoll(&eventCB->uwEventID, eventMask, mode);
-        LOS_IntRestore(intSave);
-    } else {
-        LOS_IntRestore(intSave);
     }
+
+    LOS_IntRestore(intSave);
     return ret;
 }
 
@@ -146,7 +146,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events)
 {
     LosTaskCB *resumedTask = NULL;
     LosTaskCB *nextTask = (LosTaskCB *)NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
     UINT8 exitFlag = 0;
     if (eventCB == NULL) {
         return LOS_ERRNO_EVENT_PTR_NULL;
@@ -159,6 +159,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events)
     }
     intSave = LOS_IntLock();
     eventCB->uwEventID |= events;
+    OsHookCall(LOS_HOOK_TYPE_EVENT_WRITE, eventCB);
     if (!LOS_ListEmpty(&eventCB->stEventList)) {
         for (resumedTask = LOS_DL_LIST_ENTRY((&eventCB->stEventList)->pstNext, LosTaskCB, pendList);
              &resumedTask->pendList != (&eventCB->stEventList);) {
@@ -169,7 +170,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events)
                  ((resumedTask->eventMask & eventCB->uwEventID) == resumedTask->eventMask))) {
                 exitFlag = 1;
 
-                OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
+                OsSchedTaskWake(resumedTask);
             }
             resumedTask = nextTask;
         }
@@ -187,7 +188,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events)
 
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventDestroy(PEVENT_CB_S eventCB)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     if (eventCB == NULL) {
         return LOS_ERRNO_EVENT_PTR_NULL;
     }
@@ -195,28 +196,25 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventDestroy(PEVENT_CB_S eventCB)
 
     if (!LOS_ListEmpty(&eventCB->stEventList)) {
         LOS_IntRestore(intSave);
-        return LOS_ERRNO_EVENT_SHOULD_NOT_DESTORY;
+        return LOS_ERRNO_EVENT_SHOULD_NOT_DESTROYED;
     }
     eventCB->stEventList.pstNext = (LOS_DL_LIST *)NULL;
     eventCB->stEventList.pstPrev = (LOS_DL_LIST *)NULL;
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_EVENT_DESTROY, eventCB);
     return LOS_OK;
 }
-LITE_OS_SEC_TEXT_MINOR UINT32 LOS_EventClear(PEVENT_CB_S eventCB, UINT32 events)
+LITE_OS_SEC_TEXT_MINOR UINT32 LOS_EventClear(PEVENT_CB_S eventCB, UINT32 eventMask)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     if (eventCB == NULL) {
         return LOS_ERRNO_EVENT_PTR_NULL;
     }
     intSave = LOS_IntLock();
-    eventCB->uwEventID &= events;
+    eventCB->uwEventID &= eventMask;
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_EVENT_CLEAR, eventCB);
     return LOS_OK;
 }
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif /* __cplusplus */
 
diff --git a/kernel/liteos_m/kernel/src/los_init.c b/kernel/liteos_m/kernel/src/los_init.c
old mode 100755
new mode 100644
index 50a344c..c6d3c54
--- a/kernel/liteos_m/kernel/src/los_init.c
+++ b/kernel/liteos_m/kernel/src/los_init.c
@@ -29,23 +29,19 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "los_config.h"
+#include "stdarg.h"
 #include "los_arch.h"
-#include "los_queue.h"
+#include "los_config.h"
+#include "los_debug.h"
 #include "los_memory.h"
 #include "los_mux.h"
+#include "los_queue.h"
 #include "los_sem.h"
-#include "los_debug.h"
-#include "stdarg.h"
 
 #if (LOSCFG_PLATFORM_HWI == 1)
 #include "los_interrupt.h"
 #endif
 
-#if (LOSCFG_KERNEL_TRACE == 1)
-#include "los_debug.h"
-#endif
-
 #if (LOSCFG_BASE_CORE_SWTMR == 1)
 #include "los_swtmr.h"
 #endif
@@ -58,11 +54,13 @@
 #include "los_exc_info.h"
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
+#if (LOSCFG_BACKTRACE_TYPE != 0)
+#include "los_backtrace.h"
+#endif
+
+#if (LOSCFG_KERNEL_PM == 1)
+#include "los_pm.h"
+#endif
 
 /*****************************************************************************
  Function    : LOS_Reboot
@@ -118,6 +116,10 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_KernelInit(VOID)
     UINT32 ret;
     PRINTK("entering kernel init...\n");
 
+#if (LOSCFG_BACKTRACE_TYPE != 0)
+    OSBackTraceInit();
+#endif
+
     OsRegister();
     ret = OsMemSystemInit();
     if (ret != LOS_OK) {
@@ -175,29 +177,25 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_KernelInit(VOID)
     }
 #endif
 
-#if (LOSCFG_BASE_CORE_TIMESLICE == 1)
-    OsTimesliceInit();
-#endif
-
     ret = OsIdleTaskCreate();
     if (ret != LOS_OK) {
         return ret;
     }
 
-#if (LOSCFG_KERNEL_TRACE == 1)
-    ret = LOS_TraceInit();
+#if (LOSCFG_KERNEL_PM == 1)
+    ret = OsPmInit();
     if (ret != LOS_OK) {
-        PRINT_ERR("LOS_TraceInit error\n");
+        PRINT_ERR("Pm init failed!\n");
         return ret;
     }
 #endif
 
-#ifdef LOSCFG_TEST
-    //ret = los_TestInit();
-    //if (ret != LOS_OK) {
-    //    PRINT_ERR("los_TestInit error\n");
-    //    return ret;
-    //}
+#if (LOSCFG_TEST == 1)
+    ret = los_TestInit();
+    if (ret != LOS_OK) {
+        PRINT_ERR("los_TestInit error\n");
+        return ret;
+    }
 #endif
 
 #if (LOSCFG_PLATFORM_EXC == 1)
@@ -207,8 +205,3 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_KernelInit(VOID)
     return LOS_OK;
 }
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cpluscplus */
-#endif /* __cpluscplus */
diff --git a/kernel/liteos_m/kernel/src/los_mux.c b/kernel/liteos_m/kernel/src/los_mux.c
index 87cdf5a..4f3f592 100644
--- a/kernel/liteos_m/kernel/src/los_mux.c
+++ b/kernel/liteos_m/kernel/src/los_mux.c
@@ -28,17 +28,15 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
+
+#include "los_mux.h"
 #include "los_config.h"
+#include "los_debug.h"
+#include "los_hook.h"
 #include "los_interrupt.h"
-#include "los_mux.h"
 #include "los_memory.h"
-#include "los_debug.h"
+#include "los_sched.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif
-#endif /* __cplusplus */
 
 #if (LOSCFG_BASE_IPC_MUX == 1)
 
@@ -46,11 +44,11 @@ LITE_OS_SEC_BSS       LosMuxCB*   g_allMux = NULL;
 LITE_OS_SEC_DATA_INIT LOS_DL_LIST g_unusedMuxList;
 
 /*****************************************************************************
- Funtion      : OsMuxInit
+ Function      : OsMuxInit
  Description  : Initializes the mutex
  Input        : None
  Output       : None
- Return       : LOS_OK on success ,or error code on failure
+ Return       : LOS_OK on success, or error code on failure
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 OsMuxInit(VOID)
 {
@@ -82,7 +80,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsMuxInit(VOID)
  Description  : Create a mutex
  Input        : None
  Output       : muxHandle ------ Mutex operation handle
- Return       : LOS_OK on success ,or error code on failure
+ Return       : LOS_OK on success, or error code on failure
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_MuxCreate(UINT32 *muxHandle)
 {
@@ -112,6 +110,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_MuxCreate(UINT32 *muxHandle)
     LOS_ListInit(&muxCreated->muxList);
     *muxHandle = (UINT32)muxCreated->muxID;
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_MUX_CREATE, muxCreated);
     return LOS_OK;
 ERR_HANDLER:
     OS_RETURN_ERROR_P2(errLine, errNo);
@@ -122,7 +121,7 @@ ERR_HANDLER:
  Description  : Delete a mutex
  Input        : muxHandle ------Mutex operation handle
  Output       : None
- Return       : LOS_OK on success ,or error code on failure
+ Return       : LOS_OK on success, or error code on failure
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_MuxDelete(UINT32 muxHandle)
 {
@@ -152,6 +151,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_MuxDelete(UINT32 muxHandle)
 
     LOS_IntRestore(intSave);
 
+    OsHookCall(LOS_HOOK_TYPE_MUX_DELETE, muxDeleted);
     return LOS_OK;
 ERR_HANDLER:
     OS_RETURN_ERROR_P2(errLine, errNo);
@@ -181,7 +181,7 @@ STATIC_INLINE UINT32 OsMuxValidCheck(LosMuxCB *muxPended)
  Input        : muxHandle ------ Mutex operation handleone
               : timeOut   ------- waiting time
  Output       : None
- Return       : LOS_OK on success ,or error code on failure
+ Return       : LOS_OK on success, or error code on failure
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_MuxPend(UINT32 muxHandle, UINT32 timeout)
 {
@@ -207,13 +207,13 @@ LITE_OS_SEC_TEXT UINT32 LOS_MuxPend(UINT32 muxHandle, UINT32 timeout)
         muxPended->owner = runningTask;
         muxPended->priority = runningTask->priority;
         LOS_IntRestore(intSave);
-        return LOS_OK;
+        goto HOOK;
     }
 
     if (muxPended->owner == runningTask) {
         muxPended->muxCount++;
         LOS_IntRestore(intSave);
-        return LOS_OK;
+        goto HOOK;
     }
 
     if (!timeout) {
@@ -224,21 +224,27 @@ LITE_OS_SEC_TEXT UINT32 LOS_MuxPend(UINT32 muxHandle, UINT32 timeout)
     runningTask->taskMux = (VOID *)muxPended;
 
     if (muxPended->owner->priority > runningTask->priority) {
-        OsTaskPriModify(muxPended->owner, runningTask->priority);
+        (VOID)OsSchedModifyTaskSchedParam(muxPended->owner, runningTask->priority);
     }
 
-    OsTaskWait(&muxPended->muxList, OS_TASK_STATUS_PEND, timeout);
+    OsSchedTaskWait(&muxPended->muxList, timeout);
 
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_MUX_PEND, muxPended);
     LOS_Schedule();
 
+    intSave = LOS_IntLock();
     if (runningTask->taskStatus & OS_TASK_STATUS_TIMEOUT) {
-        intSave = LOS_IntLock();
         runningTask->taskStatus &= (~OS_TASK_STATUS_TIMEOUT);
         retErr = LOS_ERRNO_MUX_TIMEOUT;
         goto ERROR_MUX_PEND;
     }
 
+    LOS_IntRestore(intSave);
+    return LOS_OK;
+
+HOOK:
+    OsHookCall(LOS_HOOK_TYPE_MUX_PEND, muxPended);
     return LOS_OK;
 
 ERROR_MUX_PEND:
@@ -251,7 +257,7 @@ ERROR_MUX_PEND:
  Description  : Specify the mutex V operation,
  Input        : muxHandle ------ Mutex operation handle
  Output       : None
- Return       : LOS_OK on success ,or error code on failure
+ Return       : LOS_OK on success, or error code on failure
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 muxHandle)
 {
@@ -276,11 +282,12 @@ LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 muxHandle)
 
     if (--(muxPosted->muxCount) != 0) {
         LOS_IntRestore(intSave);
+        OsHookCall(LOS_HOOK_TYPE_MUX_POST, muxPosted);
         return LOS_OK;
     }
 
     if ((muxPosted->owner->priority) != muxPosted->priority) {
-        OsTaskPriModify(muxPosted->owner, muxPosted->priority);
+        (VOID)OsSchedModifyTaskSchedParam(muxPosted->owner, muxPosted->priority);
     }
 
     if (!LOS_ListEmpty(&muxPosted->muxList)) {
@@ -291,9 +298,10 @@ LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 muxHandle)
         muxPosted->priority = resumedTask->priority;
         resumedTask->taskMux = NULL;
 
-        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
+        OsSchedTaskWake(resumedTask);
 
         LOS_IntRestore(intSave);
+        OsHookCall(LOS_HOOK_TYPE_MUX_POST, muxPosted);
         LOS_Schedule();
     } else {
         LOS_IntRestore(intSave);
@@ -303,8 +311,3 @@ LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 muxHandle)
 }
 #endif /* (LOSCFG_BASE_IPC_MUX == 1) */
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/los_queue.c b/kernel/liteos_m/kernel/src/los_queue.c
old mode 100755
new mode 100644
index c68ace3..ce6049a
--- a/kernel/liteos_m/kernel/src/los_queue.c
+++ b/kernel/liteos_m/kernel/src/los_queue.c
@@ -28,20 +28,18 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-#include "los_config.h"
+
 #include "los_queue.h"
 #include "securec.h"
+#include "los_config.h"
+#include "los_debug.h"
+#include "los_hook.h"
+#include "los_interrupt.h"
 #include "los_membox.h"
-#include "los_task.h"
 #include "los_memory.h"
-#include "los_interrupt.h"
-#include "los_debug.h"
+#include "los_task.h"
+#include "los_sched.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif
-#endif /* __cplusplus */
 
 #if (LOSCFG_BASE_IPC_QUEUE == 1)
 
@@ -86,7 +84,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsQueueInit(VOID)
  Function    : LOS_QueueCreate
  Description : Create a queue
  Input       : queueName  --- Queue name, less than 4 characters
-             : len        --- Queue lenth
+             : len        --- Queue length
              : flags      --- Queue type, FIFO or PRIO
              : maxMsgSize --- Maximum message size in byte
  Output      : queueID    --- Queue ID
@@ -99,7 +97,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_QueueCreate(CHAR *queueName,
                                              UINT16 maxMsgSize)
 {
     LosQueueCB *queueCB = NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
     LOS_DL_LIST *unusedQueue = NULL;
     UINT8 *queue = NULL;
     UINT16 msgSize;
@@ -152,6 +150,8 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_QueueCreate(CHAR *queueName,
 
     *queueID = queueCB->queueID;
 
+    OsHookCall(LOS_HOOK_TYPE_QUEUE_CREATE, queueCB);
+
     return LOS_OK;
 }
 
@@ -205,23 +205,23 @@ static INLINE VOID OsQueueBufferOperate(LosQueueCB *queueCB, UINT32 operateType,
 {
     UINT8 *queueNode = NULL;
     UINT32 msgDataSize;
-    UINT16 queuePosion;
+    UINT16 queuePosition;
     errno_t rc;
 
     /* get the queue position */
     switch (OS_QUEUE_OPERATE_GET(operateType)) {
         case OS_QUEUE_READ_HEAD:
-            queuePosion = queueCB->queueHead;
+            queuePosition = queueCB->queueHead;
             ((queueCB->queueHead + 1) == queueCB->queueLen) ? (queueCB->queueHead = 0) : (queueCB->queueHead++);
             break;
 
         case OS_QUEUE_WRITE_HEAD:
             (queueCB->queueHead == 0) ? (queueCB->queueHead = (queueCB->queueLen - 1)) : (--queueCB->queueHead);
-            queuePosion = queueCB->queueHead;
+            queuePosition = queueCB->queueHead;
             break;
 
         case OS_QUEUE_WRITE_TAIL:
-            queuePosion = queueCB->queueTail;
+            queuePosition = queueCB->queueTail;
             ((queueCB->queueTail + 1) == queueCB->queueLen) ? (queueCB->queueTail = 0) : (queueCB->queueTail++);
             break;
 
@@ -230,7 +230,7 @@ static INLINE VOID OsQueueBufferOperate(LosQueueCB *queueCB, UINT32 operateType,
             return;
     }
 
-    queueNode = &(queueCB->queue[(queuePosion * (queueCB->queueSize))]);
+    queueNode = &(queueCB->queue[(queuePosition * (queueCB->queueSize))]);
 
     if (OS_QUEUE_IS_POINT(operateType)) {
         if (OS_QUEUE_IS_READ(operateType)) {
@@ -277,13 +277,12 @@ static INLINE UINT32 OsQueueOperateParamCheck(const LosQueueCB *queueCB, UINT32
 UINT32 OsQueueOperate(UINT32 queueID, UINT32 operateType, VOID *bufferAddr, UINT32 *bufferSize, UINT32 timeOut)
 {
     LosQueueCB *queueCB = NULL;
-    LosTaskCB *runTsk = NULL;
     LosTaskCB *resumedTask = NULL;
     UINT32 ret;
     UINT32 readWrite = OS_QUEUE_READ_WRITE_GET(operateType);
     UINT32 readWriteTmp = !readWrite;
 
-    UINTPTR intSave = LOS_IntLock();
+    UINT32 intSave = LOS_IntLock();
 
     queueCB = (LosQueueCB *)GET_QUEUE_HANDLE(queueID);
     ret = OsQueueOperateParamCheck(queueCB, operateType, bufferSize);
@@ -302,14 +301,14 @@ UINT32 OsQueueOperate(UINT32 queueID, UINT32 operateType, VOID *bufferAddr, UINT
             goto QUEUE_END;
         }
 
-        runTsk = (LosTaskCB *)g_losTask.runTask;
-        OsTaskWait(&queueCB->readWriteList[readWrite], OS_TASK_STATUS_PEND_QUEUE, timeOut);
+        LosTaskCB *runTsk = (LosTaskCB *)g_losTask.runTask;
+        OsSchedTaskWait(&queueCB->readWriteList[readWrite], timeOut);
         LOS_IntRestore(intSave);
         LOS_Schedule();
 
         intSave = LOS_IntLock();
         if (runTsk->taskStatus & OS_TASK_STATUS_TIMEOUT) {
-            runTsk->taskStatus &= (~OS_TASK_STATUS_TIMEOUT);
+            runTsk->taskStatus &= ~OS_TASK_STATUS_TIMEOUT;
             ret = LOS_ERRNO_QUEUE_TIMEOUT;
             goto QUEUE_END;
         }
@@ -319,10 +318,9 @@ UINT32 OsQueueOperate(UINT32 queueID, UINT32 operateType, VOID *bufferAddr, UINT
 
     OsQueueBufferOperate(queueCB, operateType, bufferAddr, bufferSize);
 
-
     if (!LOS_ListEmpty(&queueCB->readWriteList[readWriteTmp])) {
         resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&queueCB->readWriteList[readWriteTmp]));
-        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND_QUEUE);
+        OsSchedTaskWake(resumedTask);
         LOS_IntRestore(intSave);
         LOS_Schedule();
         return LOS_OK;
@@ -397,6 +395,9 @@ LITE_OS_SEC_TEXT UINT32 LOS_QueueRead(UINT32 queueID, VOID *bufferAddr, UINT32 b
     }
 
     operateType = OS_QUEUE_OPERATE_TYPE(OS_QUEUE_READ, OS_QUEUE_HEAD, OS_QUEUE_POINT);
+
+    OsHookCall(LOS_HOOK_TYPE_QUEUE_READ, (LosQueueCB *)GET_QUEUE_HANDLE(queueID));
+
     return OsQueueOperate(queueID, operateType, bufferAddr, &bufferSize, timeOut);
 }
 
@@ -413,6 +414,9 @@ LITE_OS_SEC_TEXT UINT32 LOS_QueueWrite(UINT32 queueID, VOID *bufferAddr, UINT32
     }
 
     operateType = OS_QUEUE_OPERATE_TYPE(OS_QUEUE_WRITE, OS_QUEUE_TAIL, OS_QUEUE_POINT);
+
+    OsHookCall(LOS_HOOK_TYPE_QUEUE_WRITE, (LosQueueCB *)GET_QUEUE_HANDLE(queueID));
+
     return OsQueueOperate(queueID, operateType, &bufferAddr, &size, timeOut);
 }
 
@@ -443,7 +447,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_QueueWriteHead(UINT32 queueID,
 LITE_OS_SEC_TEXT VOID *OsQueueMailAlloc(UINT32 queueID, VOID *mailPool, UINT32 timeOut)
 {
     VOID *mem = (VOID *)NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
     LosQueueCB *queueCB = (LosQueueCB *)NULL;
     LosTaskCB *runTsk = (LosTaskCB *)NULL;
 
@@ -474,7 +478,7 @@ LITE_OS_SEC_TEXT VOID *OsQueueMailAlloc(UINT32 queueID, VOID *mailPool, UINT32 t
         }
 
         runTsk = (LosTaskCB *)g_losTask.runTask;
-        OsTaskWait(&queueCB->memList, OS_TASK_STATUS_PEND_QUEUE, timeOut);
+        OsSchedTaskWait(&queueCB->memList, timeOut);
         LOS_IntRestore(intSave);
         LOS_Schedule();
 
@@ -508,7 +512,7 @@ END:
 LITE_OS_SEC_TEXT UINT32 OsQueueMailFree(UINT32 queueID, VOID *mailPool, VOID *mailMem)
 {
     VOID *mem = (VOID *)NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
     LosQueueCB *queueCB = (LosQueueCB *)NULL;
     LosTaskCB *resumedTask = (LosTaskCB *)NULL;
 
@@ -535,7 +539,7 @@ LITE_OS_SEC_TEXT UINT32 OsQueueMailFree(UINT32 queueID, VOID *mailPool, VOID *ma
 
     if (!LOS_ListEmpty(&queueCB->memList)) {
         resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&queueCB->memList));
-        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND_QUEUE);
+        OsSchedTaskWake(resumedTask);
         mem = LOS_MemboxAlloc(mailPool);
         if (mem == NULL) {
             LOS_IntRestore(intSave);
@@ -561,7 +565,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_QueueDelete(UINT32 queueID)
 {
     LosQueueCB *queueCB = NULL;
     UINT8 *queue = NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
     UINT32 ret;
 
     if (queueID >= LOSCFG_BASE_IPC_QUEUE_LIMIT) {
@@ -602,6 +606,8 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_QueueDelete(UINT32 queueID)
     LOS_ListAdd(&g_freeQueueList, &queueCB->readWriteList[OS_QUEUE_WRITE]);
     LOS_IntRestore(intSave);
 
+    OsHookCall(LOS_HOOK_TYPE_QUEUE_DELETE, queueCB);
+
     ret = LOS_MemFree(m_aucSysMem0, (VOID *)queue);
     return ret;
 
@@ -612,7 +618,7 @@ QUEUE_END:
 
 LITE_OS_SEC_TEXT_MINOR UINT32 LOS_QueueInfoGet(UINT32 queueID, QUEUE_INFO_S *queueInfo)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     UINT32 ret = LOS_OK;
     LosQueueCB *queueCB = NULL;
     LosTaskCB *tskCB = NULL;
@@ -662,8 +668,3 @@ QUEUE_END:
 
 #endif /* (LOSCFG_BASE_IPC_QUEUE == 1) */
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/los_sched.c b/kernel/liteos_m/kernel/src/los_sched.c
new file mode 100644
index 0000000..fe9f578
--- /dev/null
+++ b/kernel/liteos_m/kernel/src/los_sched.c
@@ -0,0 +1,594 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_sched.h"
+#include "los_task.h"
+#include "los_tick.h"
+#include "los_debug.h"
+#include "los_hook.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define OS_PRIORITY_QUEUE_NUM      32
+#define PRIQUEUE_PRIOR0_BIT        0x80000000U
+#define OS_SCHED_TIME_SLICES       ((LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT * OS_SYS_NS_PER_US) / OS_NS_PER_CYCLE)
+#define OS_TIME_SLICE_MIN          (INT32)((50 * OS_SYS_NS_PER_US) / OS_NS_PER_CYCLE) /* 50us */
+#define OS_TICK_RESPONSE_TIME_MAX  LOSCFG_BASE_CORE_TICK_RESPONSE_MAX
+#if (LOSCFG_BASE_CORE_TICK_RESPONSE_MAX == 0)
+#error "Must specify the maximum value that tick timer counter supports!"
+#endif
+
+STATIC UINT32  g_tryToContextSwitch = 0;
+STATIC SchedScan  g_swtmrScan = NULL;
+STATIC SortLinkAttribute *g_taskSortLinkList = NULL;
+STATIC LOS_DL_LIST g_priQueueList[OS_PRIORITY_QUEUE_NUM];
+STATIC UINT32 g_queueBitmap;
+
+STATIC UINT32 g_schedResponseID = 0;
+STATIC UINT64 g_schedResponseTime = OS_SCHED_MAX_RESPONSE_TIME;
+STATIC VOID (*SchedRealSleepTimeSet)(UINT64) = NULL;
+
+UINT32 OsSchedRealSleepTimeSet(VOID (*func)(UINT64))
+{
+    if (func == NULL) {
+        return LOS_NOK;
+    }
+
+    SchedRealSleepTimeSet = func;
+    return LOS_OK;
+}
+
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)
+STATIC UINT64 g_schedTimerBase;
+
+VOID OsSchedUpdateSchedTimeBase(VOID)
+{
+    UINT32 period = 0;
+
+    (VOID)HalGetTickCycle(&period);
+    g_schedTimerBase += period;
+}
+
+VOID OsSchedTimerBaseReset(UINT64 currTime)
+{
+    LOS_ASSERT(currTime > g_schedTimerBase);
+
+    g_schedTimerBase = currTime;
+    g_schedResponseTime = OS_SCHED_MAX_RESPONSE_TIME;
+}
+#endif
+
+UINT64 OsGetCurrSchedTimeCycle(VOID)
+{
+    if (!g_taskScheduled) {
+        return 0;
+    }
+
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 1)
+    return HalGetTickCycle(NULL);
+#else
+    STATIC UINT64 oldSchedTime = 0;
+    UINT32 period = 0;
+    UINT32 intSave = LOS_IntLock();
+    UINT64 time = HalGetTickCycle(&period);
+    UINT64 schedTime = g_schedTimerBase + time;
+    if (schedTime < oldSchedTime) {
+        /* Turn the timer count */
+        g_schedTimerBase += period;
+        schedTime = g_schedTimerBase + time;
+    }
+
+    LOS_ASSERT(schedTime >= oldSchedTime);
+
+    oldSchedTime = schedTime;
+    LOS_IntRestore(intSave);
+    return schedTime;
+#endif
+}
+
+STATIC INLINE VOID OsTimeSliceUpdate(LosTaskCB *taskCB, UINT64 currTime)
+{
+    LOS_ASSERT(currTime >= taskCB->startTime);
+
+    INT32 incTime = currTime - taskCB->startTime;
+    if (taskCB->taskID != g_idleTaskID) {
+        taskCB->timeSlice -= incTime;
+    }
+    taskCB->startTime = currTime;
+}
+
+STATIC INLINE VOID OsSchedSetNextExpireTime(UINT64 startTime, UINT32 responseID, UINT64 taskEndTime, BOOL timeUpdate)
+{
+    UINT64 nextExpireTime = OsGetNextExpireTime(startTime);
+    UINT64 nextResponseTime;
+    BOOL isTimeSlice = FALSE;
+
+    /* The current thread's time slice has been consumed, but the current system lock task cannot
+     * trigger the schedule to release the CPU
+     */
+    if (taskEndTime < nextExpireTime) {
+        nextExpireTime = taskEndTime;
+        isTimeSlice = TRUE;
+    }
+
+    if ((g_schedResponseTime > nextExpireTime) && ((g_schedResponseTime - nextExpireTime) >= OS_CYCLE_PER_TICK)) {
+        nextResponseTime = nextExpireTime - startTime;
+        if (nextResponseTime > OS_TICK_RESPONSE_TIME_MAX) {
+            if (SchedRealSleepTimeSet != NULL) {
+                SchedRealSleepTimeSet(nextResponseTime);
+            }
+            nextResponseTime = OS_TICK_RESPONSE_TIME_MAX;
+            nextExpireTime = startTime + nextResponseTime;
+        } else if (nextResponseTime < OS_CYCLE_PER_TICK) {
+            if (SchedRealSleepTimeSet != NULL) {
+                SchedRealSleepTimeSet(0);
+            }
+            nextResponseTime = OS_CYCLE_PER_TICK;
+            nextExpireTime = startTime + nextResponseTime;
+            if (nextExpireTime >= g_schedResponseTime) {
+                return;
+            }
+        }
+    } else {
+        /* There is no point earlier than the current expiration date */
+        return;
+    }
+
+    if (isTimeSlice) {
+        /* The expiration time of the current system is the thread's slice expiration time */
+        g_schedResponseID = responseID;
+    } else {
+        g_schedResponseID = OS_INVALID;
+    }
+
+    g_schedResponseTime = nextExpireTime;
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)
+    if (timeUpdate) {
+        g_schedTimerBase = OsGetCurrSchedTimeCycle();
+    }
+#endif
+    HalSysTickReload(nextResponseTime);
+}
+
+VOID OsSchedUpdateExpireTime(UINT64 startTime, BOOL timeUpdate)
+{
+    UINT64 endTime;
+    LosTaskCB *runTask = g_losTask.runTask;
+
+    if (runTask->taskID != g_idleTaskID) {
+        INT32 timeSlice = (runTask->timeSlice <= OS_TIME_SLICE_MIN) ? OS_SCHED_TIME_SLICES : runTask->timeSlice;
+        endTime = startTime + timeSlice;
+    } else {
+        endTime = OS_SCHED_MAX_RESPONSE_TIME - OS_CYCLE_PER_TICK;
+    }
+    OsSchedSetNextExpireTime(startTime, runTask->taskID, endTime, timeUpdate);
+}
+
+STATIC INLINE VOID OsSchedPriQueueEnHead(LOS_DL_LIST *priqueueItem, UINT32 priority)
+{
+    /*
+     * Task control blocks are inited as zero. And when task is deleted,
+     * and at the same time would be deleted from priority queue or
+     * other lists, task pend node will restored as zero.
+     */
+    if (LOS_ListEmpty(&g_priQueueList[priority])) {
+        g_queueBitmap |= PRIQUEUE_PRIOR0_BIT >> priority;
+    }
+
+    LOS_ListAdd(&g_priQueueList[priority], priqueueItem);
+}
+
+STATIC INLINE VOID OsSchedPriQueueEnTail(LOS_DL_LIST *priqueueItem, UINT32 priority)
+{
+    if (LOS_ListEmpty(&g_priQueueList[priority])) {
+        g_queueBitmap |= PRIQUEUE_PRIOR0_BIT >> priority;
+    }
+
+    LOS_ListTailInsert(&g_priQueueList[priority], priqueueItem);
+}
+
+STATIC INLINE VOID OsSchedPriQueueDelete(LOS_DL_LIST *priqueueItem, UINT32 priority)
+{
+    LOS_ListDelete(priqueueItem);
+    if (LOS_ListEmpty(&g_priQueueList[priority])) {
+        g_queueBitmap &= ~(PRIQUEUE_PRIOR0_BIT >> priority);
+    }
+}
+
+STATIC INLINE VOID OsSchedWakePendTimeTask(UINT64 currTime, LosTaskCB *taskCB, BOOL *needSchedule)
+{
+    UINT16 tempStatus = taskCB->taskStatus;
+    if (tempStatus & (OS_TASK_STATUS_PEND | OS_TASK_STATUS_DELAY)) {
+        taskCB->taskStatus &= ~(OS_TASK_STATUS_PEND | OS_TASK_STATUS_PEND_TIME | OS_TASK_STATUS_DELAY);
+        if (tempStatus & OS_TASK_STATUS_PEND) {
+            taskCB->taskStatus |= OS_TASK_STATUS_TIMEOUT;
+            LOS_ListDelete(&taskCB->pendList);
+            taskCB->taskMux = NULL;
+            taskCB->taskSem = NULL;
+        }
+
+        if (!(tempStatus & OS_TASK_STATUS_SUSPEND)) {
+            OsSchedTaskEnQueue(taskCB);
+            *needSchedule = TRUE;
+        }
+    }
+}
+
+STATIC INLINE BOOL OsSchedScanTimerList(VOID)
+{
+    BOOL needSchedule = FALSE;
+    LOS_DL_LIST *listObject = &g_taskSortLinkList->sortLink;
+    /*
+     * When task is pended with timeout, the task block is on the timeout sortlink
+     * (per cpu) and ipc(mutex,sem and etc.)'s block at the same time, it can be waken
+     * up by either timeout or corresponding ipc it's waiting.
+     *
+     * Now synchronize sortlink procedure is used, therefore the whole task scan needs
+     * to be protected, preventing another core from doing sortlink deletion at same time.
+     */
+
+    if (LOS_ListEmpty(listObject)) {
+        return needSchedule;
+    }
+
+    SortLinkList *sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
+    UINT64 currTime = OsGetCurrSchedTimeCycle();
+    while (sortList->responseTime <= currTime) {
+        LosTaskCB *taskCB = LOS_DL_LIST_ENTRY(sortList, LosTaskCB, sortList);
+        OsDeleteNodeSortLink(g_taskSortLinkList, &taskCB->sortList);
+
+        OsSchedWakePendTimeTask(currTime, taskCB, &needSchedule);
+
+        if (LOS_ListEmpty(listObject)) {
+            break;
+        }
+
+        sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
+    }
+
+    return needSchedule;
+}
+
+VOID OsSchedTaskEnQueue(LosTaskCB *taskCB)
+{
+    LOS_ASSERT(!(taskCB->taskStatus & OS_TASK_STATUS_READY));
+
+    if (taskCB->taskID != g_idleTaskID) {
+        if (taskCB->timeSlice > OS_TIME_SLICE_MIN) {
+            OsSchedPriQueueEnHead(&taskCB->pendList, taskCB->priority);
+        } else {
+            taskCB->timeSlice = OS_SCHED_TIME_SLICES;
+            OsSchedPriQueueEnTail(&taskCB->pendList, taskCB->priority);
+        }
+        OsHookCall(LOS_HOOK_TYPE_MOVEDTASKTOREADYSTATE, taskCB);
+    }
+
+    taskCB->taskStatus &= ~(OS_TASK_STATUS_PEND | OS_TASK_STATUS_SUSPEND |
+                            OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND_TIME);
+
+    taskCB->taskStatus |= OS_TASK_STATUS_READY;
+}
+
+VOID OsSchedTaskDeQueue(LosTaskCB *taskCB)
+{
+    if (taskCB->taskStatus & OS_TASK_STATUS_READY) {
+        if (taskCB->taskID != g_idleTaskID) {
+            OsSchedPriQueueDelete(&taskCB->pendList, taskCB->priority);
+        }
+
+        taskCB->taskStatus &= ~OS_TASK_STATUS_READY;
+    }
+}
+
+VOID OsSchedTaskExit(LosTaskCB *taskCB)
+{
+    if (taskCB->taskStatus & OS_TASK_STATUS_READY) {
+        OsSchedTaskDeQueue(taskCB);
+    } else if (taskCB->taskStatus & OS_TASK_STATUS_PEND) {
+        LOS_ListDelete(&taskCB->pendList);
+        taskCB->taskStatus &= ~OS_TASK_STATUS_PEND;
+    }
+
+    if (taskCB->taskStatus & (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND_TIME)) {
+        OsDeleteSortLink(&taskCB->sortList, OS_SORT_LINK_TASK);
+        taskCB->taskStatus &= ~(OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND_TIME);
+    }
+}
+
+VOID OsSchedYield(VOID)
+{
+    LosTaskCB *runTask = g_losTask.runTask;
+
+    runTask->timeSlice = 0;
+}
+
+VOID OsSchedDelay(LosTaskCB *runTask, UINT32 tick)
+{
+    runTask->taskStatus |= OS_TASK_STATUS_DELAY;
+    runTask->waitTimes = tick;
+}
+
+VOID OsSchedTaskWait(LOS_DL_LIST *list, UINT32 ticks)
+{
+    LosTaskCB *runTask = g_losTask.runTask;
+
+    runTask->taskStatus |= OS_TASK_STATUS_PEND;
+    LOS_ListTailInsert(list, &runTask->pendList);
+
+    if (ticks != LOS_WAIT_FOREVER) {
+        runTask->taskStatus |= OS_TASK_STATUS_PEND_TIME;
+        runTask->waitTimes = ticks;
+    }
+}
+
+VOID OsSchedTaskWake(LosTaskCB *resumedTask)
+{
+    LOS_ListDelete(&resumedTask->pendList);
+    resumedTask->taskStatus &= ~OS_TASK_STATUS_PEND;
+
+    if (resumedTask->taskStatus & OS_TASK_STATUS_PEND_TIME) {
+        OsDeleteSortLink(&resumedTask->sortList, OS_SORT_LINK_TASK);
+        resumedTask->taskStatus &= ~OS_TASK_STATUS_PEND_TIME;
+    }
+
+    if (!(resumedTask->taskStatus & OS_TASK_STATUS_SUSPEND) &&
+        !(resumedTask->taskStatus & OS_TASK_STATUS_RUNNING)) {
+        OsSchedTaskEnQueue(resumedTask);
+    }
+}
+
+BOOL OsSchedModifyTaskSchedParam(LosTaskCB *taskCB, UINT16 priority)
+{
+    if (taskCB->taskStatus & OS_TASK_STATUS_READY) {
+        OsSchedTaskDeQueue(taskCB);
+        taskCB->priority = priority;
+        OsSchedTaskEnQueue(taskCB);
+        return TRUE;
+    }
+
+    taskCB->priority = priority;
+    OsHookCall(LOS_HOOK_TYPE_TASK_PRIMODIFY, taskCB, taskCB->priority); 
+    if (taskCB->taskStatus & OS_TASK_STATUS_RUNNING) {
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+VOID OsSchedSetIdleTaskSchedParam(LosTaskCB *idleTask)
+{
+    OsSchedTaskEnQueue(idleTask);
+}
+
+UINT32 OsSchedSwtmrScanRegister(SchedScan func)
+{
+    if (func == NULL) {
+        return LOS_NOK;
+    }
+
+    g_swtmrScan = func;
+    return LOS_OK;
+}
+
+UINT32 OsTaskNextSwitchTimeGet(VOID)
+{
+    UINT32 intSave = LOS_IntLock();
+    UINT32 ticks = OsSortLinkGetNextExpireTime(g_taskSortLinkList);
+    LOS_IntRestore(intSave);
+    return ticks;
+}
+
+UINT32 OsSchedInit(VOID)
+{
+    UINT16 pri;
+    for (pri = 0; pri < OS_PRIORITY_QUEUE_NUM; pri++) {
+        LOS_ListInit(&g_priQueueList[pri]);
+    }
+    g_queueBitmap = 0;
+
+    g_taskSortLinkList = OsGetSortLinkAttribute(OS_SORT_LINK_TASK);
+    if (g_taskSortLinkList == NULL) {
+        return LOS_NOK;
+    }
+
+    OsSortLinkInit(g_taskSortLinkList);
+    g_schedResponseTime = OS_SCHED_MAX_RESPONSE_TIME;
+
+    return LOS_OK;
+}
+
+LosTaskCB *OsGetTopTask(VOID)
+{
+    UINT32 priority;
+    LosTaskCB *newTask = NULL;
+    if (g_queueBitmap) {
+        priority = CLZ(g_queueBitmap);
+        newTask = LOS_DL_LIST_ENTRY(((LOS_DL_LIST *)&g_priQueueList[priority])->pstNext, LosTaskCB, pendList);
+    } else {
+        newTask = OS_TCB_FROM_TID(g_idleTaskID);
+    }
+
+    return newTask;
+}
+
+VOID OsSchedStart(VOID)
+{
+    (VOID)LOS_IntLock();
+    LosTaskCB *newTask = OsGetTopTask();
+
+    newTask->taskStatus |= OS_TASK_STATUS_RUNNING;
+    g_losTask.newTask = newTask;
+    g_losTask.runTask = g_losTask.newTask;
+
+    g_taskScheduled = 1;
+    newTask->startTime = OsGetCurrSchedTimeCycle();
+    OsSchedTaskDeQueue(newTask);
+
+    g_schedResponseTime = OS_SCHED_MAX_RESPONSE_TIME;
+    g_schedResponseID = OS_INVALID;
+    OsSchedSetNextExpireTime(newTask->startTime, newTask->taskID, newTask->startTime + newTask->timeSlice, TRUE);
+
+    PRINTK("Entering scheduler\n");
+}
+
+void OsSetTryToTaskSwitch(void)
+{
+	g_tryToContextSwitch = 1;
+}
+
+void OsClearTryToTaskSwitch(void)
+{
+	g_tryToContextSwitch = 0;
+}
+
+UINT32 OsGetTryToTaskSwichFlag(void)
+{
+	return g_tryToContextSwitch;
+}
+
+BOOL OsTryToSchedTaskSwitch(VOID)
+{
+	BOOL ret = 0;
+	
+	if(g_tryToContextSwitch)
+	{
+		ret = OsSchedTaskSwitch();
+		g_tryToContextSwitch = 0;
+	}
+
+	return ret;
+}
+
+BOOL OsSchedTaskSwitch(VOID)
+{
+    UINT64 endTime;
+    BOOL isTaskSwitch = FALSE;
+    LosTaskCB *runTask = g_losTask.runTask;
+    OsTimeSliceUpdate(runTask, OsGetCurrSchedTimeCycle());
+
+    if (runTask->taskStatus & (OS_TASK_STATUS_PEND_TIME | OS_TASK_STATUS_DELAY)) {
+        OsAdd2SortLink(&runTask->sortList, runTask->startTime, runTask->waitTimes, OS_SORT_LINK_TASK);
+    } else if (!(runTask->taskStatus & (OS_TASK_STATUS_PEND | OS_TASK_STATUS_SUSPEND | OS_TASK_STATUS_UNUSED))) {
+        OsSchedTaskEnQueue(runTask);
+    }
+
+    LosTaskCB *newTask = OsGetTopTask();
+    g_losTask.newTask = newTask;
+
+    if (runTask != newTask) {
+#if (LOSCFG_BASE_CORE_TSK_MONITOR == 1)
+        OsTaskSwitchCheck();
+#endif
+        runTask->taskStatus &= ~OS_TASK_STATUS_RUNNING;
+        newTask->taskStatus |= OS_TASK_STATUS_RUNNING;
+        newTask->startTime = runTask->startTime;
+        isTaskSwitch = TRUE;
+
+        OsHookCall(LOS_HOOK_TYPE_TASK_SWITCHEDIN);
+    }
+
+    OsSchedTaskDeQueue(newTask);
+
+    if (newTask->taskID != g_idleTaskID) {
+        endTime = newTask->startTime + newTask->timeSlice;
+    } else {
+        endTime = OS_SCHED_MAX_RESPONSE_TIME - OS_CYCLE_PER_TICK;
+    }
+    OsSchedSetNextExpireTime(newTask->startTime, newTask->taskID, endTime, TRUE);
+
+    return isTaskSwitch;
+}
+
+UINT64 LOS_SchedTickTimeoutNsGet(VOID)
+{
+    UINT32 intSave;
+    UINT64 responseTime;
+    UINT64 currTime;
+
+    intSave = LOS_IntLock();
+    responseTime = g_schedResponseTime;
+    currTime = OsGetCurrSchedTimeCycle();
+    LOS_IntRestore(intSave);
+
+    if (responseTime > currTime) {
+        responseTime = responseTime - currTime;
+    } else {
+        responseTime = 0; /* Tick interrupt already timeout */
+    }
+
+    return OS_SYS_CYCLE_TO_NS(responseTime, OS_SYS_CLOCK);
+}
+
+VOID LOS_SchedTickHandler(VOID)
+{
+    UINT64 currTime;
+    BOOL needSched = FALSE;
+
+    LOS_ASSERT(g_taskScheduled);
+
+    UINT32 intSave = LOS_IntLock();
+
+    if (g_schedResponseID == OS_INVALID) {
+        if (g_swtmrScan != NULL) {
+            needSched = g_swtmrScan();
+        }
+
+        needSched |= OsSchedScanTimerList();
+    }
+
+    g_schedResponseTime = OS_SCHED_MAX_RESPONSE_TIME;
+    if (needSched && LOS_CHECK_SCHEDULE) {
+        HalTaskSchedule();
+    } else {
+        currTime = OsGetCurrSchedTimeCycle();
+        OsTimeSliceUpdate(g_losTask.runTask, currTime);
+        OsSchedUpdateExpireTime(currTime, TRUE);
+    }
+
+    LOS_IntRestore(intSave);
+}
+
+VOID LOS_Schedule(VOID)
+{
+    if (g_taskScheduled && LOS_CHECK_SCHEDULE) {
+        HalTaskSchedule();
+    }
+}
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/los_sem.c b/kernel/liteos_m/kernel/src/los_sem.c
old mode 100755
new mode 100644
index 830625a..13e0fb6
--- a/kernel/liteos_m/kernel/src/los_sem.c
+++ b/kernel/liteos_m/kernel/src/los_sem.c
@@ -28,17 +28,15 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-#include "los_config.h"
+
 #include "los_sem.h"
-#include "los_memory.h"
-#include "los_interrupt.h"
+#include "los_config.h"
 #include "los_debug.h"
+#include "los_hook.h"
+#include "los_interrupt.h"
+#include "los_memory.h"
+#include "los_sched.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif
-#endif /* __cplusplus */
 
 #if (LOSCFG_BASE_IPC_SEM == 1)
 
@@ -47,7 +45,7 @@ LITE_OS_SEC_BSS LosSemCB *g_allSem = NULL;
 
 /*****************************************************************************
  Function     : OsSemInit
- Description  : Initialize the  Semaphore doubly linked list
+ Description  : Initialize the Semaphore doubly linked list
  Input        : None
  Output       : None
  Return       : LOS_OK on success, or error code on failure
@@ -68,7 +66,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsSemInit(VOID)
         return LOS_ERRNO_SEM_NO_MEMORY;
     }
 
-    /* Connect all the ECBs in a doubly linked list. */
+    /* Connect all the semaphore CBs in a doubly linked list. */
     for (index = 0; index < LOSCFG_BASE_IPC_SEM_LIMIT; index++) {
         semNode = ((LosSemCB *)g_allSem) + index;
         semNode->semID = index;
@@ -80,7 +78,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsSemInit(VOID)
 
 /*****************************************************************************
  Function     : OsSemCreate
- Description  : create the  Semaphore
+ Description  : create the Semaphore
  Input        : count      --- Semaphore count
               : maxCount   --- Max semaphore count for check
  Output       : semHandle  --- Index of semaphore
@@ -118,6 +116,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsSemCreate(UINT16 count, UINT16 maxCount, UINT32 *
     LOS_ListInit(&semCreated->semList);
     *semHandle = (UINT32)semCreated->semID;
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_SEM_CREATE, semCreated);
     return LOS_OK;
 
 ERR_HANDLER:
@@ -181,6 +180,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_SemDelete(UINT32 semHandle)
     LOS_ListAdd(&g_unusedSemList, &semDeleted->semList);
     semDeleted->semStat = OS_SEM_UNUSED;
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_SEM_DELETE, semDeleted);
     return LOS_OK;
 ERR_HANDLER:
     OS_RETURN_ERROR_P2(errLine, errNo);
@@ -235,6 +235,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_SemPend(UINT32 semHandle, UINT32 timeout)
     if (semPended->semCount > 0) {
         semPended->semCount--;
         LOS_IntRestore(intSave);
+        OsHookCall(LOS_HOOK_TYPE_SEM_PEND, semPended, runningTask);
         return LOS_OK;
     }
 
@@ -245,17 +246,19 @@ LITE_OS_SEC_TEXT UINT32 LOS_SemPend(UINT32 semHandle, UINT32 timeout)
 
     runningTask = (LosTaskCB *)g_losTask.runTask;
     runningTask->taskSem = (VOID *)semPended;
-    OsTaskWait(&semPended->semList, OS_TASK_STATUS_PEND, timeout);
+    OsSchedTaskWait(&semPended->semList, timeout);
     LOS_IntRestore(intSave);
+    OsHookCall(LOS_HOOK_TYPE_SEM_PEND, semPended, runningTask);
     LOS_Schedule();
 
+    intSave = LOS_IntLock();
     if (runningTask->taskStatus & OS_TASK_STATUS_TIMEOUT) {
-        intSave = LOS_IntLock();
         runningTask->taskStatus &= (~OS_TASK_STATUS_TIMEOUT);
         retErr = LOS_ERRNO_SEM_TIMEOUT;
         goto ERROR_SEM_PEND;
     }
 
+    LOS_IntRestore(intSave);
     return LOS_OK;
 
 ERROR_SEM_PEND:
@@ -294,22 +297,30 @@ LITE_OS_SEC_TEXT UINT32 LOS_SemPost(UINT32 semHandle)
     if (!LOS_ListEmpty(&semPosted->semList)) {
         resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&(semPosted->semList)));
         resumedTask->taskSem = NULL;
-        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
+        OsSchedTaskWake(resumedTask);
 
         LOS_IntRestore(intSave);
+        OsHookCall(LOS_HOOK_TYPE_SEM_POST, semPosted, resumedTask);
         LOS_Schedule();
     } else {
         semPosted->semCount++;
         LOS_IntRestore(intSave);
+        OsHookCall(LOS_HOOK_TYPE_SEM_POST, semPosted, resumedTask);
     }
 
     return LOS_OK;
 }
 
-#endif /* (LOSCFG_BASE_IPC_SEM == 1) */
+LITE_OS_SEC_TEXT UINT32 LOS_SemGetValue(UINT32 semHandle, INT32 *currVal)
+{
+    LosSemCB *sem = GET_SEM(semHandle);
+
+    if (semHandle >= (UINT32)LOSCFG_BASE_IPC_SEM_LIMIT) {
+        OS_RETURN_ERROR(LOS_ERRNO_SEM_INVALID);
+    }
 
-#ifdef __cplusplus
-#if __cplusplus
+    *currVal = sem->semCount;
+    return 0;
 }
-#endif
-#endif /* __cplusplus */
+
+#endif /* (LOSCFG_BASE_IPC_SEM == 1) */
diff --git a/kernel/liteos_m/kernel/src/los_sortlink.c b/kernel/liteos_m/kernel/src/los_sortlink.c
new file mode 100644
index 0000000..ad07801
--- /dev/null
+++ b/kernel/liteos_m/kernel/src/los_sortlink.c
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_sortlink.h"
+#include "los_sched.h"
+#include "los_debug.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+STATIC SortLinkAttribute g_taskSortLink;
+STATIC SortLinkAttribute g_swtmrSortLink;
+
+UINT32 OsSortLinkInit(SortLinkAttribute *sortLinkHeader)
+{
+    LOS_ListInit(&sortLinkHeader->sortLink);
+    return LOS_OK;
+}
+
+STATIC INLINE VOID OsAddNode2SortLink(SortLinkAttribute *sortLinkHeader, SortLinkList *sortList)
+{
+    LOS_DL_LIST *head = (LOS_DL_LIST *)&sortLinkHeader->sortLink;
+
+    if (LOS_ListEmpty(head)) {
+        LOS_ListAdd(head, &sortList->sortLinkNode);
+        return;
+    }
+
+    SortLinkList *listSorted = LOS_DL_LIST_ENTRY(head->pstNext, SortLinkList, sortLinkNode);
+    if (listSorted->responseTime > sortList->responseTime) {
+        LOS_ListAdd(head, &sortList->sortLinkNode);
+        return;
+    } else if (listSorted->responseTime == sortList->responseTime) {
+        LOS_ListAdd(head->pstNext, &sortList->sortLinkNode);
+        return;
+    }
+
+    LOS_DL_LIST *prevNode = head->pstPrev;
+    do {
+        listSorted = LOS_DL_LIST_ENTRY(prevNode, SortLinkList, sortLinkNode);
+        if (listSorted->responseTime <= sortList->responseTime) {
+            LOS_ListAdd(prevNode, &sortList->sortLinkNode);
+            break;
+        }
+
+        prevNode = prevNode->pstPrev;
+    } while (1);
+}
+
+VOID OsDeleteNodeSortLink(SortLinkAttribute *sortLinkHeader, SortLinkList *sortList)
+{
+    LOS_ListDelete(&sortList->sortLinkNode);
+    SET_SORTLIST_VALUE(sortList, OS_SORT_LINK_INVALID_TIME);
+}
+
+STATIC INLINE UINT64 OsGetSortLinkNextExpireTime(SortLinkAttribute *sortHeader, UINT64 startTime)
+{
+    UINT64 expirTime = 0;
+    UINT64 nextExpirTime = 0;
+    LOS_DL_LIST *head = &sortHeader->sortLink;
+    LOS_DL_LIST *list = head->pstNext;
+
+    if (LOS_ListEmpty(head)) {
+        return OS_SCHED_MAX_RESPONSE_TIME - OS_CYCLE_PER_TICK;
+    }
+
+    do {
+        SortLinkList *listSorted = LOS_DL_LIST_ENTRY(list, SortLinkList, sortLinkNode);
+        if (listSorted->responseTime <= startTime) {
+            expirTime = startTime;
+            list = list->pstNext;
+        } else {
+            nextExpirTime = listSorted->responseTime;
+            break;
+        }
+    } while (list != head);
+
+    if (expirTime == 0) {
+        return nextExpirTime;
+    }
+
+    if (nextExpirTime == 0) {
+        return expirTime;
+    }
+
+    if ((nextExpirTime - expirTime) <= OS_US_PER_TICK) {
+        return nextExpirTime;
+    }
+
+    return expirTime;
+}
+
+VOID OsAdd2SortLink(SortLinkList *node, UINT64 startTime, UINT32 waitTicks, SortLinkType type)
+{
+    UINT32 intSave;
+    SortLinkAttribute *sortLinkHeader = NULL;
+
+    if (type == OS_SORT_LINK_TASK) {
+        sortLinkHeader = &g_taskSortLink;
+    } else if (type == OS_SORT_LINK_SWTMR) {
+        sortLinkHeader = &g_swtmrSortLink;
+    } else {
+        LOS_Panic("Sort link type error : %u\n", type);
+    }
+
+    intSave = LOS_IntLock();
+    SET_SORTLIST_VALUE(node, startTime + (UINT64)waitTicks * OS_CYCLE_PER_TICK);
+    OsAddNode2SortLink(sortLinkHeader, node);
+    LOS_IntRestore(intSave);
+}
+
+VOID OsDeleteSortLink(SortLinkList *node, SortLinkType type)
+{
+    UINT32 intSave;
+    SortLinkAttribute *sortLinkHeader = NULL;
+
+    if (type == OS_SORT_LINK_TASK) {
+        sortLinkHeader = &g_taskSortLink;
+    } else if (type == OS_SORT_LINK_SWTMR) {
+        sortLinkHeader = &g_swtmrSortLink;
+    } else {
+        LOS_Panic("Sort link type error : %u\n", type);
+    }
+
+    intSave = LOS_IntLock();
+    if (node->responseTime != OS_SORT_LINK_INVALID_TIME) {
+        OsDeleteNodeSortLink(sortLinkHeader, node);
+    }
+    LOS_IntRestore(intSave);
+}
+
+SortLinkAttribute *OsGetSortLinkAttribute(SortLinkType type)
+{
+    if (type == OS_SORT_LINK_TASK) {
+        return &g_taskSortLink;
+    } else if (type == OS_SORT_LINK_SWTMR) {
+        return &g_swtmrSortLink;
+    }
+
+    PRINT_ERR("Invalid sort link type!\n");
+    return NULL;
+}
+
+UINT64 OsGetNextExpireTime(UINT64 startTime)
+{
+    UINT32 intSave;
+    SortLinkAttribute *taskHeader = &g_taskSortLink;
+    SortLinkAttribute *swtmrHeader = &g_swtmrSortLink;
+
+    intSave = LOS_IntLock();
+    UINT64 taskExpirTime = OsGetSortLinkNextExpireTime(taskHeader, startTime);
+    UINT64 swtmrExpirTime = OsGetSortLinkNextExpireTime(swtmrHeader, startTime);
+    LOS_IntRestore(intSave);
+
+    return (taskExpirTime < swtmrExpirTime) ? taskExpirTime : swtmrExpirTime;
+}
+
+UINT32 OsSortLinkGetTargetExpireTime(UINT64 currTime, const SortLinkList *targetSortList)
+{
+    if (currTime >= targetSortList->responseTime) {
+        return 0;
+    }
+
+    return (UINT32)(((targetSortList->responseTime - currTime) * LOSCFG_BASE_CORE_TICK_PER_SECOND) / OS_SYS_CLOCK);
+}
+
+UINT32 OsSortLinkGetNextExpireTime(const SortLinkAttribute *sortLinkHeader)
+{
+    LOS_DL_LIST *head = (LOS_DL_LIST *)&sortLinkHeader->sortLink;
+
+    if (LOS_ListEmpty(head)) {
+        return 0;
+    }
+
+    SortLinkList *listSorted = LOS_DL_LIST_ENTRY(head->pstNext, SortLinkList, sortLinkNode);
+    return OsSortLinkGetTargetExpireTime(OsGetCurrSchedTimeCycle(), listSorted);
+}
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/los_swtmr.c b/kernel/liteos_m/kernel/src/los_swtmr.c
index 1d02a04..dae7b77 100644
--- a/kernel/liteos_m/kernel/src/los_swtmr.c
+++ b/kernel/liteos_m/kernel/src/los_swtmr.c
@@ -28,27 +28,23 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-#include "los_config.h"
+
+#include "los_swtmr.h"
 #include "securec.h"
 #include "los_interrupt.h"
-#include "los_swtmr.h"
 #include "los_task.h"
 #include "los_memory.h"
 #include "los_queue.h"
 #include "los_debug.h"
+#include "los_sched.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 #if (LOSCFG_BASE_CORE_SWTMR == 1)
 
-LITE_OS_SEC_BSS UINT32          g_swtmrHandlerQueue;           /* Software Timer timeout queue ID */
-LITE_OS_SEC_BSS SWTMR_CTRL_S    *g_swtmrCBArray = NULL;        /* first address in Timer memory space */
-LITE_OS_SEC_BSS SWTMR_CTRL_S    *g_swtmrFreeList = NULL;       /* Free list of Softwaer Timer */
-LITE_OS_SEC_BSS SWTMR_CTRL_S    *g_swtmrSortList = NULL;       /* The software timer count list */
+LITE_OS_SEC_BSS UINT32            g_swtmrHandlerQueue;           /* Software Timer timeout queue ID */
+LITE_OS_SEC_BSS SWTMR_CTRL_S      *g_swtmrCBArray = NULL;        /* first address in Timer memory space */
+LITE_OS_SEC_BSS SWTMR_CTRL_S      *g_swtmrFreeList = NULL;       /* Free list of Software Timer */
+LITE_OS_SEC_BSS SortLinkAttribute *g_swtmrSortLinkList = NULL;       /* The software timer count list */
 
 #if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
 typedef struct SwtmrAlignDataStr {
@@ -59,9 +55,6 @@ typedef struct SwtmrAlignDataStr {
     UINT32 isAligned : 1;
 } SwtmrAlignData;
 LITE_OS_SEC_BSS SwtmrAlignData      g_swtmrAlignID[LOSCFG_BASE_CORE_SWTMR_LIMIT] = {0};   /* store swtmr align */
-static UINT32                       g_swtimerRousesTime = 0;  /* suspend time */
-static SWTMR_CTRL_S                 *g_swtmrRouses = NULL;    /* first swtmr that can wake up */
-static SWTMR_CTRL_S                 *g_swtmrRousesPrev = NULL;
 #endif
 
 #define SWTMR_MAX_RUNNING_TICKS 2
@@ -77,14 +70,14 @@ Return      : None
 LITE_OS_SEC_TEXT VOID OsSwtmrTask(VOID)
 {
     SwtmrHandlerItem swtmrHandle;
-    UINT32 readSzie;
+    UINT32 readSize;
     UINT32 ret;
     UINT64 tick;
-    readSzie = sizeof(SwtmrHandlerItem);
+    readSize = sizeof(SwtmrHandlerItem);
 
     for (;;) {
-        ret = LOS_QueueReadCopy(g_swtmrHandlerQueue, &swtmrHandle, &readSzie, LOS_WAIT_FOREVER);
-        if ((ret == LOS_OK) && (readSzie == sizeof(SwtmrHandlerItem))) {
+        ret = LOS_QueueReadCopy(g_swtmrHandlerQueue, &swtmrHandle, &readSize, LOS_WAIT_FOREVER);
+        if ((ret == LOS_OK) && (readSize == sizeof(SwtmrHandlerItem))) {
             if (swtmrHandle.handler == NULL) {
                 continue;
             }
@@ -125,103 +118,48 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsSwtmrTaskCreate(VOID)
     return ret;
 }
 
-/*****************************************************************************
-Function    : OsSwtmrInit
-Description : Initializes Software Timer
-Input       : None
-Output      : None
-Return      : LOS_OK on success or error code on failure
-*****************************************************************************/
-LITE_OS_SEC_TEXT_INIT UINT32 OsSwtmrInit(VOID)
-{
-    UINT32 size;
-    UINT16 index;
-    UINT32 ret;
-    SWTMR_CTRL_S *swtmr = NULL;
-    SWTMR_CTRL_S *temp = NULL;
-
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-    // Ignore the return code when matching CSEC rule 6.6(1).
-    (VOID)memset_s((VOID *)g_swtmrAlignID, sizeof(SwtmrAlignData) * LOSCFG_BASE_CORE_SWTMR_LIMIT,
-                   0, sizeof(SwtmrAlignData) * LOSCFG_BASE_CORE_SWTMR_LIMIT);
-#endif
-
-    g_swtmrSortList = (SWTMR_CTRL_S *)NULL;
-    size = sizeof(SWTMR_CTRL_S) * LOSCFG_BASE_CORE_SWTMR_LIMIT;
-    swtmr = (SWTMR_CTRL_S *)LOS_MemAlloc(m_aucSysMem0, size);
-    if (swtmr == NULL) {
-        return LOS_ERRNO_SWTMR_NO_MEMORY;
-    }
-    // Ignore the return code when matching CSEC rule 6.6(3).
-    (VOID)memset_s((VOID *)swtmr, size, 0, size);
-    g_swtmrCBArray = swtmr;
-    g_swtmrFreeList = swtmr;
-    swtmr->usTimerID = 0;
-    temp = swtmr;
-    swtmr++;
-    for (index = 1; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
-        swtmr->usTimerID = index;
-        temp->pstNext = swtmr;
-        temp = swtmr;
-    }
-
-    ret = LOS_QueueCreate((CHAR *)NULL, OS_SWTMR_HANDLE_QUEUE_SIZE,
-                          &g_swtmrHandlerQueue, 0, sizeof(SwtmrHandlerItem));
-    if (ret != LOS_OK) {
-        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
-        return LOS_ERRNO_SWTMR_QUEUE_CREATE_FAILED;
-    }
-
-    ret = OsSwtmrTaskCreate();
-    if (ret != LOS_OK) {
-        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
-        return LOS_ERRNO_SWTMR_TASK_CREATE_FAILED;
-    }
-
-    return LOS_OK;
-}
-
 #if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-STATIC_INLINE UINT32 OsSwtmrCalcAlignCount(UINT32 interval, UINT32 timerId)
+STATIC_INLINE UINT32 OsSwtmrCalcAlignCount(UINT64 currTime, UINT32 interval, UINT32 timerId)
 {
-    SWTMR_CTRL_S *cur = g_swtmrSortList;
-    UINT32 count = 0;
+    UINT32 count;
+
     if (interval == 0) {
         return interval;
     }
-    while (cur != NULL) {
-        count += cur->uwCount;
-        if (cur->usTimerID == timerId) {
-            return (interval - (cur->uwInterval - count) % interval);
-        }
-        cur = cur->pstNext;
-    }
-    return interval;
+    SWTMR_CTRL_S *cur = g_swtmrCBArray + timerId % LOSCFG_BASE_CORE_SWTMR_LIMIT;
+    count = OsSortLinkGetTargetExpireTime(currTime, &cur->stSortList);
+    return (interval - (cur->uwInterval - count) % interval);
 }
 
-LITE_OS_SEC_TEXT SWTMR_CTRL_S* OsSwtmrFindAlignPos(SWTMR_CTRL_S *swtmr)
+VOID OsSwtmrFindAlignPos(UINT64 currTime, SWTMR_CTRL_S *swtmr)
 {
-    SWTMR_CTRL_S *intPos = (SWTMR_CTRL_S *)NULL;
-    SWTMR_CTRL_S *cur = (SWTMR_CTRL_S *)NULL;
     SWTMR_CTRL_S *minInLarge = (SWTMR_CTRL_S *)NULL;
-    SWTMR_CTRL_S *maxInLitte = (SWTMR_CTRL_S *)NULL;
+    SWTMR_CTRL_S *maxInLittle = (SWTMR_CTRL_S *)NULL;
     UINT32 currSwtmrTimes, swtmrTimes;
-    SwtmrAlignData swtmrAlgInfo, currSwtmrAlgInfo;
     UINT32 minInLargeVal = OS_NULL_INT;
-    UINT32 maxInLitteval = OS_NULL_INT;
+    UINT32 maxInLittleVal = OS_NULL_INT;
 
-    currSwtmrAlgInfo = g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT];
+    LOS_DL_LIST *listHead = &g_swtmrSortLinkList->sortLink;
+    if (LOS_ListEmpty(listHead)) {
+        return;
+    }
+
+    SwtmrAlignData currSwtmrAlgInfo = g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT];
     currSwtmrTimes = currSwtmrAlgInfo.times;
-    cur = g_swtmrSortList;
-    while (cur != NULL) {
-        swtmrAlgInfo = g_swtmrAlignID[cur->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT];
-        if ((swtmrAlgInfo.isAligned == 0) || (swtmrAlgInfo.canAlign == 0)) { // swtmr not start
+    LOS_DL_LIST *listObject = listHead->pstNext;
+
+    do {
+        SortLinkList *sortList = LOS_DL_LIST_ENTRY(listObject, SortLinkList, sortLinkNode);
+        SWTMR_CTRL_S *cur = LOS_DL_LIST_ENTRY(sortList, SWTMR_CTRL_S, stSortList);
+        SwtmrAlignData swtmrAlgInfo = g_swtmrAlignID[cur->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT];
+        /* swtmr not start */
+        if ((swtmrAlgInfo.isAligned == 0) || (swtmrAlgInfo.canAlign == 0)) {
             goto CONTINUE_NEXT_NODE;
         }
-        // find same interval timer, directly return
+        /* find same interval timer, directly return */
         if (cur->uwInterval == swtmr->uwInterval) {
-            swtmr->uwCount = 0;
-            return cur;
+            swtmr->uwCount = OsSortLinkGetTargetExpireTime(currTime, &cur->stSortList);
+            return;
         }
 
         if ((currSwtmrAlgInfo.canMultiple != 1) || (swtmrAlgInfo.times == 0)) {
@@ -229,7 +167,7 @@ LITE_OS_SEC_TEXT SWTMR_CTRL_S* OsSwtmrFindAlignPos(SWTMR_CTRL_S *swtmr)
         }
         swtmrTimes = swtmrAlgInfo.times;
         if (currSwtmrTimes == 0) {
-            return NULL;
+            return;
         }
         if ((swtmrTimes >= currSwtmrTimes) && ((swtmrTimes % currSwtmrTimes) == 0)) {
             if (minInLargeVal > (swtmrTimes / currSwtmrTimes)) {
@@ -237,22 +175,22 @@ LITE_OS_SEC_TEXT SWTMR_CTRL_S* OsSwtmrFindAlignPos(SWTMR_CTRL_S *swtmr)
                 minInLarge = cur;
             }
         } else if ((swtmrTimes < currSwtmrTimes) && ((currSwtmrTimes % swtmrTimes) == 0)) {
-            if (maxInLitteval > (currSwtmrTimes / swtmrTimes)) {
-                maxInLitteval = currSwtmrTimes / swtmrTimes;
-                maxInLitte = cur;
+            if (maxInLittleVal > (currSwtmrTimes / swtmrTimes)) {
+                maxInLittleVal = currSwtmrTimes / swtmrTimes;
+                maxInLittle = cur;
             }
         }
-    CONTINUE_NEXT_NODE:
+CONTINUE_NEXT_NODE:
+        listObject = listObject->pstNext;
+    } while (listObject != listHead);
 
-        cur = cur->pstNext;
-    }
     if (minInLarge != NULL) {
-        swtmr->uwCount = OsSwtmrCalcAlignCount(swtmr->uwInterval, minInLarge->usTimerID);
-    } else if (maxInLitte != NULL) {
-        swtmr->uwCount = 0;
-        intPos = maxInLitte;
+        swtmr->uwCount = OsSwtmrCalcAlignCount(currTime, swtmr->uwInterval, minInLarge->usTimerID);
+    } else if (maxInLittle != NULL) {
+        swtmr->uwCount = OsSortLinkGetTargetExpireTime(currTime, &maxInLittle->stSortList);
     }
-    return intPos;
+
+    return;
 }
 #endif
 
@@ -265,38 +203,22 @@ Return      : None
 *****************************************************************************/
 LITE_OS_SEC_TEXT VOID OsSwtmrStart(SWTMR_CTRL_S *swtmr)
 {
-    SWTMR_CTRL_S *prev = (SWTMR_CTRL_S *)NULL;
-    SWTMR_CTRL_S *cur = (SWTMR_CTRL_S *)NULL;
+    UINT64 currTime = OsGetCurrSchedTimeCycle();
 
     swtmr->uwCount = swtmr->uwInterval;
+    swtmr->ucState = OS_SWTMR_STATUS_TICKING;
 
 #if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
     if ((g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT].canAlign == 1) &&
         (g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT].isAligned == 0)) {
         g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT].isAligned = 1;
-        prev = OsSwtmrFindAlignPos(swtmr);
+        OsSwtmrFindAlignPos(currTime, swtmr);
     }
 #endif
-
-    if (prev == NULL) {
-        cur = g_swtmrSortList;
-        while (cur != NULL) {
-            if (cur->uwCount > swtmr->uwCount) {
-                break;
-            }
-
-            swtmr->uwCount -= cur->uwCount;
-            prev = cur;
-            cur = cur->pstNext;
-        }
+    OsAdd2SortLink(&swtmr->stSortList, currTime, swtmr->uwCount, OS_SORT_LINK_SWTMR);
+    if (LOS_TaskIsRunning()) {
+        OsSchedUpdateExpireTime(currTime, TRUE);
     }
-
-    swtmr->pstNext = ((prev == NULL) ? g_swtmrSortList : prev->pstNext);
-    if (swtmr->pstNext != NULL) {
-        swtmr->pstNext->uwCount -= swtmr->uwCount;
-    }
-    (prev == NULL) ? (g_swtmrSortList = swtmr) : (prev->pstNext = swtmr);
-    swtmr->ucState = OS_SWTMR_STATUS_TICKING;
 }
 
 /*****************************************************************************
@@ -320,93 +242,67 @@ STATIC_INLINE VOID OsSwtmrDelete(SWTMR_CTRL_S *swtmr)
 }
 
 
-LITE_OS_SEC_TEXT VOID OsSwtmrStop(const SWTMR_CTRL_S *swtmr)
+LITE_OS_SEC_TEXT VOID OsSwtmrStop(SWTMR_CTRL_S *swtmr)
 {
-    SWTMR_CTRL_S *prev = (SWTMR_CTRL_S *)NULL;
-    SWTMR_CTRL_S *cur = (SWTMR_CTRL_S *)NULL;
-
-    if (!g_swtmrSortList) {
-        return;
-    }
-
-    cur = g_swtmrSortList;
-
-    while (cur != swtmr) {
-        prev = cur;
-        cur = cur->pstNext;
-    }
-    if (cur == NULL) {
-        return;
-    }
-    if (cur->pstNext != NULL) {
-        cur->pstNext->uwCount += cur->uwCount;
-    }
-
-    if (prev == NULL) {
-        g_swtmrSortList = cur->pstNext;
-    } else {
-        prev->pstNext = cur->pstNext;
-    }
-
-    cur->pstNext = (SWTMR_CTRL_S *)NULL;
-    cur->ucState = OS_SWTMR_STATUS_CREATED;
+    OsDeleteSortLink(&swtmr->stSortList, OS_SORT_LINK_SWTMR);
+    swtmr->ucState = OS_SWTMR_STATUS_CREATED;
 
+    if (LOS_TaskIsRunning()) {
+        OsSchedUpdateExpireTime(OsGetCurrSchedTimeCycle(), TRUE);
 #if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-    g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT].isAligned = 0;
+        g_swtmrAlignID[swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT].isAligned = 0;
 #endif
+    }
 }
 
-/*****************************************************************************
-Function    : OsSwtmrTimeoutHandle
-Description : Software Timer time out handler
-Input       : None
-Output      : None
-Return      : None
-*****************************************************************************/
-LITE_OS_SEC_TEXT static VOID OsSwtmrTimeoutHandle(VOID)
+STATIC VOID OsSwtmrTimeoutHandle(SWTMR_CTRL_S *swtmr)
 {
-    SWTMR_CTRL_S *swtmr = g_swtmrSortList;
     SwtmrHandlerItem swtmrHandler;
 
-    while ((swtmr != NULL) && (swtmr->uwCount == 0)) {
-        g_swtmrSortList = swtmr->pstNext;
-        swtmrHandler.handler = swtmr->pfnHandler;
-        swtmrHandler.arg = swtmr->uwArg;
-        (VOID)LOS_QueueWriteCopy(g_swtmrHandlerQueue, &swtmrHandler, sizeof(SwtmrHandlerItem), LOS_NO_WAIT);
-        if (swtmr->ucMode == LOS_SWTMR_MODE_ONCE) {
-            OsSwtmrDelete(swtmr);
-            if (swtmr->usTimerID < (OS_SWTMR_MAX_TIMERID - LOSCFG_BASE_CORE_SWTMR_LIMIT)) {
-                swtmr->usTimerID += LOSCFG_BASE_CORE_SWTMR_LIMIT;
-            } else {
-                swtmr->usTimerID %= LOSCFG_BASE_CORE_SWTMR_LIMIT;
-            }
-        } else if (swtmr->ucMode == LOS_SWTMR_MODE_PERIOD) {
-            OsSwtmrStart(swtmr);
-        } else if (swtmr->ucMode == LOS_SWTMR_MODE_NO_SELFDELETE) {
-            swtmr->ucState = OS_SWTMR_STATUS_CREATED;
-        }
+    swtmrHandler.handler = swtmr->pfnHandler;
+    swtmrHandler.arg = swtmr->uwArg;
 
-        swtmr = g_swtmrSortList;
+    (VOID)LOS_QueueWriteCopy(g_swtmrHandlerQueue, &swtmrHandler, sizeof(SwtmrHandlerItem), LOS_NO_WAIT);
+    if (swtmr->ucMode == LOS_SWTMR_MODE_ONCE) {
+        OsSwtmrDelete(swtmr);
+        if (swtmr->usTimerID < (OS_SWTMR_MAX_TIMERID - LOSCFG_BASE_CORE_SWTMR_LIMIT)) {
+            swtmr->usTimerID += LOSCFG_BASE_CORE_SWTMR_LIMIT;
+        } else {
+            swtmr->usTimerID %= LOSCFG_BASE_CORE_SWTMR_LIMIT;
+        }
+    } else if (swtmr->ucMode == LOS_SWTMR_MODE_PERIOD) {
+        OsSwtmrStart(swtmr);
+    } else if (swtmr->ucMode == LOS_SWTMR_MODE_NO_SELFDELETE) {
+        swtmr->ucState = OS_SWTMR_STATUS_CREATED;
     }
 }
 
-/*****************************************************************************
-Function    : OsSwtmrScan
-Description : Tick interrupt interface module of Software Timer
-Input       : None
-Output      : None
-Return      : LOS_OK on success
-*****************************************************************************/
-LITE_OS_SEC_TEXT UINT32 OsSwtmrScan(VOID)
+STATIC BOOL OsSwtmrScan(VOID)
 {
-    UINTPTR intSave = LOS_IntLock();
-    if (g_swtmrSortList != NULL) {
-        if (--(g_swtmrSortList->uwCount) == 0) {
-            OsSwtmrTimeoutHandle();
+    BOOL needSchedule = FALSE;
+    LOS_DL_LIST *listObject = &g_swtmrSortLinkList->sortLink;
+
+    if (LOS_ListEmpty(listObject)) {
+        return needSchedule;
+    }
+
+    SortLinkList *sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
+    UINT64 currTime = OsGetCurrSchedTimeCycle();
+    while (sortList->responseTime <= currTime) {
+        OsDeleteNodeSortLink(g_swtmrSortLinkList, sortList);
+
+        SWTMR_CTRL_S *swtmr = LOS_DL_LIST_ENTRY(sortList, SWTMR_CTRL_S, stSortList);
+        OsSwtmrTimeoutHandle(swtmr);
+
+        needSchedule = TRUE;
+        if (LOS_ListEmpty(listObject)) {
+            break;
         }
+
+        sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
     }
-    LOS_IntRestore(intSave);
-    return LOS_OK;
+
+    return needSchedule;
 }
 
 /*****************************************************************************
@@ -416,174 +312,88 @@ Input       : None
 Output      : None
 Return      : Count of the Timer list
 *****************************************************************************/
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-LITE_OS_SEC_TEXT UINT32 OsSwtmrGetNextTimeout(VOID)
-{
-    SWTMR_CTRL_S *cur = NULL;
-    UINT32 tmpTime = 0;
-    UINT32 sleepTime = OS_NULL_INT;
-    UINTPTR intSave = LOS_IntLock();
-    cur = g_swtmrSortList;
-
-    // find first timer can wakeup the system
-    while (cur != NULL) {
-        if (cur->ucRouses == OS_SWTMR_ROUSES_ALLOW) {
-            g_swtmrRouses = cur;
-            break;
-        }
-
-        tmpTime += cur->uwCount;
-        g_swtmrRousesPrev = cur;
-        cur = cur->pstNext;
-    }
-
-    if (cur != NULL) {
-        sleepTime = cur->uwCount + tmpTime;
-        g_swtimerRousesTime  = sleepTime;
-    }
-    LOS_IntRestore(intSave);
-    return sleepTime;
-}
-#else
 LITE_OS_SEC_TEXT UINT32 OsSwtmrGetNextTimeout(VOID)
 {
-    UINTPTR intSave = LOS_IntLock();
-    if (g_swtmrSortList == NULL) {
-        LOS_IntRestore(intSave);
-        return OS_NULL_INT;
-    }
-    UINT32 tmp = g_swtmrSortList->uwCount;
+    UINT32 intSave = LOS_IntLock();
+    UINT32 ticks = OsSortLinkGetNextExpireTime(g_swtmrSortLinkList);
     LOS_IntRestore(intSave);
-    return tmp;
+    return ticks;
 }
-#endif
 
-/*****************************************************************************
-Function    : OsSwtimerInsert
-Description : Insert a list of swtmr
-Input       : **head, *swtmr
-Output      : **head, *swtmr
-Return      : None
-*****************************************************************************/
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-VOID OsSwtimerInsert(SWTMR_CTRL_S **head, SWTMR_CTRL_S *swtmr)
+LITE_OS_SEC_TEXT UINT32 OsSwtmrTimeGet(const SWTMR_CTRL_S *swtmr)
 {
-    SWTMR_CTRL_S *prev = NULL;
-    SWTMR_CTRL_S *nextTmp = swtmr->pstNext;
-    SWTMR_CTRL_S *cur = *head;
-
-    while (swtmr != NULL) {
-        while (cur != NULL) {
-            if (cur->uwCount > swtmr->uwCount) {
-                break;
-            }
-
-            swtmr->uwCount -= cur->uwCount;
-            prev = cur;
-            cur = cur->pstNext;
-        }
-        swtmr->pstNext = cur;
-
-        if (cur != NULL) {
-            cur->uwCount -= swtmr->uwCount;
-        }
-        if (prev == NULL) {
-            *head = swtmr;
-        } else {
-            prev->pstNext = swtmr;
-        }
-
-        prev = swtmr;
-        swtmr = nextTmp;
-        nextTmp = nextTmp->pstNext;
-    }
-
-    return;
+    return OsSortLinkGetTargetExpireTime(OsGetCurrSchedTimeCycle(), &swtmr->stSortList);
 }
-#endif
+
 /*****************************************************************************
-Function    : OsSwtmrAdjust
-Description : Adjust Software Timer list
-Input       : sleepTime
+Function    : OsSwtmrInit
+Description : Initializes Software Timer
+Input       : None
 Output      : None
-Return      : None
+Return      : LOS_OK on success or error code on failure
 *****************************************************************************/
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-LITE_OS_SEC_TEXT VOID OsSwtmrAdjust(UINT32 sleepTime)
+LITE_OS_SEC_TEXT_INIT UINT32 OsSwtmrInit(VOID)
 {
-    SWTMR_CTRL_S  *cur = NULL;
-    UINTPTR intSave = LOS_IntLock();
-    if (g_swtmrRouses == NULL) {
-        LOS_IntRestore(intSave);
-        return;
-    }
-
-    if (sleepTime > g_swtimerRousesTime) {
-        sleepTime = g_swtimerRousesTime;
-    }
+    UINT32 size;
+    UINT16 index;
+    UINT32 ret;
 
-    if (sleepTime <= g_swtmrRouses->uwCount) {
-        g_swtmrRouses->uwCount -= sleepTime;
-    } else {
-        g_swtmrRouses->uwCount = g_swtimerRousesTime - sleepTime;
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+    // Ignore the return code when matching CSEC rule 6.6(1).
+    (VOID)memset_s((VOID *)g_swtmrAlignID, sizeof(SwtmrAlignData) * LOSCFG_BASE_CORE_SWTMR_LIMIT,
+                   0, sizeof(SwtmrAlignData) * LOSCFG_BASE_CORE_SWTMR_LIMIT);
+#endif
 
-        if (g_swtmrRousesPrev != NULL) {
-            g_swtmrRousesPrev->pstNext = NULL;
-            cur = g_swtmrSortList;
-            OsSwtimerInsert(&g_swtmrRouses, cur);
-            g_swtmrSortList = g_swtmrRouses;
-        }
+    size = sizeof(SWTMR_CTRL_S) * LOSCFG_BASE_CORE_SWTMR_LIMIT;
+    SWTMR_CTRL_S *swtmr = (SWTMR_CTRL_S *)LOS_MemAlloc(m_aucSysMem0, size);
+    if (swtmr == NULL) {
+        return LOS_ERRNO_SWTMR_NO_MEMORY;
     }
-    if (g_swtmrSortList->uwCount == 0) {
-        OsSwtmrTimeoutHandle();
+    // Ignore the return code when matching CSEC rule 6.6(3).
+    (VOID)memset_s((VOID *)swtmr, size, 0, size);
+    g_swtmrCBArray = swtmr;
+    g_swtmrFreeList = swtmr;
+    swtmr->usTimerID = 0;
+    SWTMR_CTRL_S *temp = swtmr;
+    swtmr++;
+    for (index = 1; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
+        swtmr->usTimerID = index;
+        temp->pstNext = swtmr;
+        temp = swtmr;
     }
 
-    g_swtmrRouses = NULL;
-    g_swtmrRousesPrev = NULL;
-    LOS_IntRestore(intSave);
-}
-#else
-LITE_OS_SEC_TEXT VOID OsSwtmrAdjust(UINT32 sleepTime)
-{
-    UINT32 tmpSleepTime = sleepTime;
-    UINTPTR intSave = LOS_IntLock();
-    if (g_swtmrSortList == NULL) {
-        LOS_IntRestore(intSave);
-        return;
+    ret = LOS_QueueCreate((CHAR *)NULL, OS_SWTMR_HANDLE_QUEUE_SIZE,
+                          &g_swtmrHandlerQueue, 0, sizeof(SwtmrHandlerItem));
+    if (ret != LOS_OK) {
+        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
+        return LOS_ERRNO_SWTMR_QUEUE_CREATE_FAILED;
     }
 
-    if (tmpSleepTime > g_swtmrSortList->uwCount) {
-        tmpSleepTime = g_swtmrSortList->uwCount;
+    ret = OsSwtmrTaskCreate();
+    if (ret != LOS_OK) {
+        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
+        return LOS_ERRNO_SWTMR_TASK_CREATE_FAILED;
     }
 
-    g_swtmrSortList->uwCount -= tmpSleepTime;
-
-    if (g_swtmrSortList->uwCount == 0) {
-        OsSwtmrTimeoutHandle();
+    g_swtmrSortLinkList = OsGetSortLinkAttribute(OS_SORT_LINK_SWTMR);
+    if (g_swtmrSortLinkList == NULL) {
+        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
+        return LOS_NOK;
     }
-    LOS_IntRestore(intSave);
-}
-#endif
-
-LITE_OS_SEC_TEXT UINT32 OsSwtmrTimeGet(const SWTMR_CTRL_S *swtmr)
-{
-    SWTMR_CTRL_S *cur = (SWTMR_CTRL_S *)NULL;
-    UINT32 tick = 0;
 
-    cur = g_swtmrSortList;
-    while (1) {
-        if (cur == NULL) {
-            break;
-        }
-        tick += cur->uwCount;
-        if (cur == swtmr) {
-            break;
-        }
+    ret = OsSortLinkInit(g_swtmrSortLinkList);
+    if (ret != LOS_OK) {
+        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
+        return LOS_NOK;
+    }
 
-        cur = cur->pstNext;
+    ret = OsSchedSwtmrScanRegister((SchedScan)OsSwtmrScan);
+    if (ret != LOS_OK) {
+        (VOID)LOS_MemFree(m_aucSysMem0, swtmr);
+        return LOS_NOK;
     }
 
-    return tick;
+    return LOS_OK;
 }
 
 /*****************************************************************************
@@ -613,7 +423,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_SwtmrCreate(UINT32 interval,
 #endif
 {
     SWTMR_CTRL_S  *swtmr = NULL;
-    UINTPTR  intSave;
+    UINT32 intSave;
 
     if (interval == 0) {
         return LOS_ERRNO_SWTMR_INTERVAL_NOT_SUITED;
@@ -664,6 +474,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_SwtmrCreate(UINT32 interval,
 #endif
     swtmr->ucState       = OS_SWTMR_STATUS_CREATED;
     *swtmrId = swtmr->usTimerID;
+    SET_SORTLIST_VALUE(&swtmr->stSortList, OS_SORT_LINK_INVALID_TIME);
 
     return LOS_OK;
 }
@@ -677,21 +488,15 @@ Return      : LOS_OK on success or error code on failure
 *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStart(UINT32 swtmrId)
 {
-    SWTMR_CTRL_S *swtmr = NULL;
-    UINTPTR intSave;
-#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
-    UINT32 times;
-    UINT32 swtmrAlignIdIndex = 0;
-#endif
+    UINT32 intSave;
     UINT32 ret = LOS_OK;
-    UINT16 swtmrCbId;
 
     if (swtmrId >= OS_SWTMR_MAX_TIMERID) {
         return LOS_ERRNO_SWTMR_ID_INVALID;
     }
+
     intSave = LOS_IntLock();
-    swtmrCbId = swtmrId % LOSCFG_BASE_CORE_SWTMR_LIMIT;
-    swtmr = g_swtmrCBArray + swtmrCbId;
+    SWTMR_CTRL_S *swtmr = g_swtmrCBArray + swtmrId % LOSCFG_BASE_CORE_SWTMR_LIMIT;
     if (swtmr->usTimerID != swtmrId) {
         LOS_IntRestore(intSave);
         return LOS_ERRNO_SWTMR_ID_INVALID;
@@ -699,12 +504,11 @@ LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStart(UINT32 swtmrId)
 
 #if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
     if ((swtmr->ucSensitive == OS_SWTMR_ALIGN_INSENSITIVE) && (swtmr->ucMode == LOS_SWTMR_MODE_PERIOD)) {
-        swtmrAlignIdIndex = swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT;
+        UINT32 swtmrAlignIdIndex = swtmr->usTimerID % LOSCFG_BASE_CORE_SWTMR_LIMIT;
         g_swtmrAlignID[swtmrAlignIdIndex].canAlign = 1;
         if ((swtmr->uwInterval % LOS_COMMON_DIVISOR) == 0) {
             g_swtmrAlignID[swtmrAlignIdIndex].canMultiple = 1;
-            times = swtmr->uwInterval / (LOS_COMMON_DIVISOR);
-            g_swtmrAlignID[swtmrAlignIdIndex].times = times;
+            g_swtmrAlignID[swtmrAlignIdIndex].times = swtmr->uwInterval / LOS_COMMON_DIVISOR;
         }
     }
 #endif
@@ -738,7 +542,7 @@ Return      : LOS_OK on success or error code on failure
 LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStop(UINT32 swtmrId)
 {
     SWTMR_CTRL_S *swtmr = NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
     UINT16 swtmrCbId;
     UINT32 ret = LOS_OK;
 
@@ -775,7 +579,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStop(UINT32 swtmrId)
 LITE_OS_SEC_TEXT UINT32 LOS_SwtmrTimeGet(UINT32 swtmrId, UINT32 *tick)
 {
     SWTMR_CTRL_S *swtmr = NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
     UINT32 ret = LOS_OK;
     UINT16 swtmrCbId;
 
@@ -823,7 +627,7 @@ Return      : LOS_OK on success or error code on failure
 LITE_OS_SEC_TEXT UINT32 LOS_SwtmrDelete(UINT32 swtmrId)
 {
     SWTMR_CTRL_S *swtmr = NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
     UINT32 ret = LOS_OK;
     UINT16 swtmrCbId;
 
@@ -860,8 +664,3 @@ LITE_OS_SEC_TEXT UINT32 LOS_SwtmrDelete(UINT32 swtmrId)
 #endif /* (LOSCFG_BASE_CORE_SWTMR == 1) */
 
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif
diff --git a/kernel/liteos_m/kernel/src/los_task.c b/kernel/liteos_m/kernel/src/los_task.c
old mode 100755
new mode 100644
index 619c17d..5af9f09
--- a/kernel/liteos_m/kernel/src/los_task.c
+++ b/kernel/liteos_m/kernel/src/los_task.c
@@ -28,27 +28,26 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-#include "los_config.h"
+
+#include "los_task.h"
 #include "securec.h"
+#include "los_config.h"
+#include "los_debug.h"
+#include "los_hook.h"
+#include "los_interrupt.h"
 #include "los_memory.h"
+#include "los_mpu.h"
+#include "los_sched.h"
 #include "los_mux.h"
 #include "los_sem.h"
 #include "los_timer.h"
-#include "los_interrupt.h"
 #if (LOSCFG_BASE_CORE_CPUP == 1)
 #include "los_cpup.h"
 #endif
-#include "los_debug.h"
-
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 /**
  * @ingroup los_task
- * @brief Convinence macro for bitwise operation of task module
+ * @brief Convenience macro for bitwise operation of task module
  */
 #define EVALUATE_L(NUMBER, VALUE)  \
             ((NUMBER) = (((NUMBER) & OS_TSK_HIGH_BITS_MASK) | (VALUE)))
@@ -70,21 +69,19 @@ extern "C" {
             ((NUMBER) = ((NUMBER) - 1))
 
 
-#define OS_CHECK_TASK_BLOCK                     (OS_TASK_STATUS_DELAY | \
-                                                 OS_TASK_STATUS_PEND | \
-                                                 OS_TASK_STATUS_SUSPEND | \
-                                                 OS_TASK_STATUS_EVENT | \
-                                                 OS_TASK_STATUS_PEND_QUEUE)
+#define OS_CHECK_TASK_BLOCK                     (OS_TASK_STATUS_DELAY |  \
+                                                 OS_TASK_STATUS_PEND |   \
+                                                 OS_TASK_STATUS_SUSPEND)
 
 /**
  * @ingroup los_task
- * @brief check taks id's validation
+ * @brief check task id's validation
  */
 #define OS_TASK_ID_CHECK(taskID)              LOS_ASSERT_COND(OS_TSK_GET_INDEX(taskID) < g_taskMaxNum)
 
 /**
  * @ingroup los_task
- * @brief check taks id's invalidation
+ * @brief check task id's invalidation
  */
 #define OS_CHECK_TSK_PID_NOIDLE(taskID)       (OS_TSK_GET_INDEX(taskID) >= g_taskMaxNum)
 
@@ -94,12 +91,6 @@ extern "C" {
  */
 #define OS_TASK_STACK_TOP_OFFSET                4
 
-LITE_OS_SEC_BSS LOS_DL_LIST *g_losPriorityQueueList = NULL;
-static LITE_OS_SEC_BSS UINT32 g_priqueueBitmap = 0;
-
-#define PRIQUEUE_PRIOR0_BIT           (UINT32)0x80000000
-#define OS_PRIORITY_QUEUE_PRIORITYNUM 32
-
 LITE_OS_SEC_BSS  LosTaskCB                           *g_taskCBArray = NULL;
 LITE_OS_SEC_BSS  LosTask                             g_losTask;
 LITE_OS_SEC_BSS  UINT16                              g_losTaskLock;
@@ -108,77 +99,14 @@ LITE_OS_SEC_BSS  UINT32                              g_idleTaskID;
 LITE_OS_SEC_BSS  UINT32                              g_swtmrTaskID;
 LITE_OS_SEC_DATA_INIT LOS_DL_LIST                    g_losFreeTask;
 LITE_OS_SEC_DATA_INIT LOS_DL_LIST                    g_taskRecyleList;
-LITE_OS_SEC_BSS  TaskSortLinkAttr                    g_taskSortLink;
 LITE_OS_SEC_BSS  BOOL                                g_taskScheduled = FALSE;
 
-#if (LOSCFG_BASE_CORE_TSK_MONITOR == 1)
-TSKSWITCHHOOK g_pfnUsrTskSwitchHook = NULL;
-#endif /* LOSCFG_BASE_CORE_TSK_MONITOR == 1 */
+STATIC VOID (*PmEnter)(BOOL isIdle) = NULL;
 
 #if (LOSCFG_BASE_CORE_EXC_TSK_SWITCH == 1)
 TaskSwitchInfo g_taskSwitchInfo;
 #endif
 
-STATIC UINT32 OsPriqueueInit(VOID)
-{
-    UINT32 priority;
-    UINT32 size = OS_PRIORITY_QUEUE_PRIORITYNUM * sizeof(LOS_DL_LIST);
-
-    g_losPriorityQueueList = (LOS_DL_LIST *)LOS_MemAlloc(m_aucSysMem0, size);
-    if (g_losPriorityQueueList == NULL) {
-        return LOS_NOK;
-    }
-
-    for (priority = 0; priority < OS_PRIORITY_QUEUE_PRIORITYNUM; ++priority) {
-        LOS_ListInit(&g_losPriorityQueueList[priority]);
-    }
-    return LOS_OK;
-}
-
-STATIC VOID OsPriqueueEnqueue(LOS_DL_LIST *priqueueItem, UINT32 priority)
-{
-    if (LOS_ListEmpty(&g_losPriorityQueueList[priority])) {
-        g_priqueueBitmap |= (PRIQUEUE_PRIOR0_BIT >> priority);
-    }
-
-    LOS_ListTailInsert(&g_losPriorityQueueList[priority], priqueueItem);
-}
-
-STATIC VOID OsPriqueueDequeue(LOS_DL_LIST *priqueueItem)
-{
-    LosTaskCB *runningTask = NULL;
-    LOS_ListDelete(priqueueItem);
-
-    runningTask = LOS_DL_LIST_ENTRY(priqueueItem, LosTaskCB, pendList);
-    if (LOS_ListEmpty(&g_losPriorityQueueList[runningTask->priority])) {
-        g_priqueueBitmap &= ~(PRIQUEUE_PRIOR0_BIT >> runningTask->priority);
-    }
-}
-
-STATIC LOS_DL_LIST *OsPriqueueTop(VOID)
-{
-    UINT32 priority;
-
-    if (g_priqueueBitmap != 0) {
-        priority = CLZ(g_priqueueBitmap);
-        return LOS_DL_LIST_FIRST(&g_losPriorityQueueList[priority]);
-    }
-
-    return (LOS_DL_LIST *)NULL;
-}
-
-STATIC UINT32 OsPriqueueSize(UINT32 priority)
-{
-    UINT32 itemCnt = 0;
-    LOS_DL_LIST *curPQNode = (LOS_DL_LIST *)NULL;
-
-    LOS_DL_LIST_FOR_EACH(curPQNode, &g_losPriorityQueueList[priority]) {
-        ++itemCnt;
-    }
-
-    return itemCnt;
-}
-
 STATIC_INLINE UINT32 OsCheckTaskIDValid(UINT32 taskID)
 {
     UINT32 ret = LOS_OK;
@@ -195,39 +123,35 @@ STATIC_INLINE UINT32 OsCheckTaskIDValid(UINT32 taskID)
 STATIC VOID OsRecyleFinishedTask(VOID)
 {
     LosTaskCB *taskCB = NULL;
-    UINTPTR intSave;
+    UINT32 intSave;
+    UINTPTR stackPtr;
 
     intSave = LOS_IntLock();
     while (!LOS_ListEmpty(&g_taskRecyleList)) {
         taskCB = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&g_taskRecyleList));
         LOS_ListDelete(LOS_DL_LIST_FIRST(&g_taskRecyleList));
         LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
-        (VOID)LOS_MemFree(OS_TASK_STACK_ADDR, (VOID *)(UINTPTR)taskCB->topOfStack);
+#if (LOSCFG_EXC_HARDWARE_STACK_PROTECTION == 1)
+        stackPtr = taskCB->topOfStack - OS_TASK_STACK_PROTECT_SIZE;
+#else
+        stackPtr = taskCB->topOfStack;
+#endif
+        (VOID)LOS_MemFree(OS_TASK_STACK_ADDR, (VOID *)stackPtr);
         taskCB->topOfStack = (UINT32)NULL;
     }
     LOS_IntRestore(intSave);
 }
 
-UINT32 OsTaskNextSwitchTimeGet(VOID)
+UINT32 OsPmEnterHandlerSet(VOID (*func)(BOOL))
 {
-    LosTaskCB *taskCB = NULL;
-    UINT32 taskSortLinkTick = LOS_WAIT_FOREVER;
-    LOS_DL_LIST *listObject = NULL;
-    UINT32 tempTicks;
-    UINT32 index;
-
-    for (index = 0; index < OS_TSK_SORTLINK_LEN; index++) {
-        listObject = g_taskSortLink.sortLink + ((g_taskSortLink.cursor + index) % OS_TSK_SORTLINK_LEN);
-        if (!LOS_ListEmpty(listObject)) {
-            taskCB = LOS_DL_LIST_ENTRY((listObject)->pstNext, LosTaskCB, timerList);
-            tempTicks = (index == 0) ? OS_TSK_SORTLINK_LEN : index;
-            tempTicks += (UINT32)(UWROLLNUM((UINT32)taskCB->idxRollNum) * OS_TSK_SORTLINK_LEN);
-            if (taskSortLinkTick > tempTicks) {
-                taskSortLinkTick = tempTicks;
-            }
-        }
+    if (func == NULL) {
+        return LOS_NOK;
     }
-    return taskSortLinkTick;
+
+	bk_printf("[wzl]OsPmEnterHandlerSet:%p\r\n", func);
+
+    PmEnter = func;
+    return LOS_OK;
 }
 
 /*****************************************************************************
@@ -237,155 +161,18 @@ UINT32 OsTaskNextSwitchTimeGet(VOID)
  Output      : None
  Return      : None
  *****************************************************************************/
-LITE_OS_SEC_TEXT WEAK VOID OsIdleTask(VOID)
+LITE_OS_SEC_TEXT VOID OsIdleTask(VOID)
 {
     while (1) {
         OsRecyleFinishedTask();
-#if (LOSCFG_KERNEL_RUNSTOP == 1)
-        HalEnterSleep(OS_SYS_NORMAL_SLEEP);
-#endif
-    }
-}
-
-/*****************************************************************************
- Function    : OsTaskPriModify
- Description : Change task priority.
- Input       : taskCB    --- task control block
-               priority  --- priority
- Output      : None
- Return      : None
- *****************************************************************************/
-LITE_OS_SEC_TEXT_MINOR VOID OsTaskPriModify(LosTaskCB *taskCB, UINT16 priority)
-{
-    if (taskCB->taskStatus & OS_TASK_STATUS_READY) {
-        OsPriqueueDequeue(&taskCB->pendList);
-        taskCB->taskStatus &= (~OS_TASK_STATUS_READY);
-        taskCB->priority = priority;
-        taskCB->taskStatus |= OS_TASK_STATUS_READY;
-        OsPriqueueEnqueue(&taskCB->pendList, taskCB->priority);
-    } else {
-        taskCB->priority = priority;
-    }
-}
-
-/*****************************************************************************
- Function    : OsTaskAdd2TimerList
- Description : Add task to sorted delay list.
- Input       : taskCB    --- task control block
-               timeout   --- wait time, ticks
- Output      : None
- Return      : None
- *****************************************************************************/
-LITE_OS_SEC_TEXT VOID OsTaskAdd2TimerList(LosTaskCB *taskCB, UINT32 timeout)
-{
-    LosTaskCB *taskDelay = NULL;
-    LOS_DL_LIST *listObject = NULL;
-    UINT32 sortIndex;
-    UINT32 rollNum;
-
-    sortIndex = timeout & OS_TSK_SORTLINK_MASK;
-    rollNum = (timeout >> OS_TSK_SORTLINK_LOGLEN);
-    (sortIndex > 0) ? 0 : (rollNum--);
-    EVALUATE_L(taskCB->idxRollNum, rollNum);
-    sortIndex = (sortIndex + g_taskSortLink.cursor);
-    sortIndex = sortIndex & OS_TSK_SORTLINK_MASK;
-    EVALUATE_H(taskCB->idxRollNum, sortIndex);
-    listObject = g_taskSortLink.sortLink + sortIndex;
-    if (listObject->pstNext == listObject) {
-        LOS_ListTailInsert(listObject, &taskCB->timerList);
-    } else {
-        taskDelay = LOS_DL_LIST_ENTRY((listObject)->pstNext, LosTaskCB, timerList);
-        do {
-            if (UWROLLNUM(taskDelay->idxRollNum) <= UWROLLNUM(taskCB->idxRollNum)) {
-                UWROLLNUMSUB(taskCB->idxRollNum, taskDelay->idxRollNum);
-            } else {
-                UWROLLNUMSUB(taskDelay->idxRollNum, taskCB->idxRollNum);
-                break;
-            }
-
-            taskDelay = LOS_DL_LIST_ENTRY(taskDelay->timerList.pstNext, LosTaskCB, timerList);
-        } while (&taskDelay->timerList != (listObject));
-
-        LOS_ListTailInsert(&taskDelay->timerList, &taskCB->timerList);
-    }
-}
-
-
-LITE_OS_SEC_TEXT VOID OsTimerListDelete(LosTaskCB *taskCB)
-{
-    LOS_DL_LIST  *listObject = NULL;
-    LosTaskCB  *nextTask = NULL;
-    UINT32 sortIndex;
-
-    sortIndex = UWSORTINDEX(taskCB->idxRollNum);
-    listObject = g_taskSortLink.sortLink + sortIndex;
-
-    if (listObject != taskCB->timerList.pstNext) {
-        nextTask = LOS_DL_LIST_ENTRY(taskCB->timerList.pstNext, LosTaskCB, timerList);
-        UWROLLNUMADD(nextTask->idxRollNum, taskCB->idxRollNum);
-    }
-
-    LOS_ListDelete(&taskCB->timerList);
-}
-
-LITE_OS_SEC_TEXT VOID OsTaskScan(VOID)
-{
-    LosTaskCB *taskCB = NULL;
-    BOOL needSchedule = FALSE;
-    LOS_DL_LIST *listObject = NULL;
-    UINT16 tempStatus;
-    UINTPTR intSave;
-    intSave = LOS_IntLock();
-
-    g_taskSortLink.cursor = (g_taskSortLink.cursor + 1) % OS_TSK_SORTLINK_LEN;
-    listObject = g_taskSortLink.sortLink + g_taskSortLink.cursor;
-    if (listObject->pstNext == listObject) {
-        LOS_IntRestore(intSave);
-        return;
-    }
-
-    for (taskCB = LOS_DL_LIST_ENTRY((listObject)->pstNext, LosTaskCB, timerList);
-         &taskCB->timerList != (listObject);) {
-        tempStatus = taskCB->taskStatus;
-        if (UWROLLNUM(taskCB->idxRollNum) > 0) {
-            UWROLLNUMDEC(taskCB->idxRollNum);
-            break;
-        }
-
-        LOS_ListDelete(&taskCB->timerList);
-        if (tempStatus & OS_TASK_STATUS_PEND) {
-            taskCB->taskStatus &= ~(OS_TASK_STATUS_PEND);
-            LOS_ListDelete(&taskCB->pendList);
-            taskCB->taskSem = NULL;
-            taskCB->taskMux = NULL;
-        }
-        else if (tempStatus & OS_TASK_STATUS_EVENT) {
-            taskCB->taskStatus &= ~(OS_TASK_STATUS_EVENT);
-        }
-        else if (tempStatus & OS_TASK_STATUS_PEND_QUEUE) {
-            LOS_ListDelete(&taskCB->pendList);
-            taskCB->taskStatus &= ~(OS_TASK_STATUS_PEND_QUEUE);
+		
+		#if (0 == CFG_JTAG_ENABLE)
+        if (PmEnter != NULL) {
+            PmEnter(TRUE);
         } else {
-            taskCB->taskStatus &= ~(OS_TASK_STATUS_DELAY);
-        }
-
-        if (!(tempStatus & OS_TASK_STATUS_SUSPEND)) {
-            taskCB->taskStatus |= OS_TASK_STATUS_READY;
-            OsPriqueueEnqueue(&taskCB->pendList, taskCB->priority);
-            needSchedule = TRUE;
+            (VOID)HalEnterSleep(0);
         }
-
-        if (listObject->pstNext == listObject) {
-            break;
-        }
-
-        taskCB = LOS_DL_LIST_ENTRY(listObject->pstNext, LosTaskCB, timerList);
-    }
-
-    LOS_IntRestore(intSave);
-
-    if (needSchedule) {
-        LOS_Schedule();
+		#endif
     }
 }
 
@@ -405,19 +192,12 @@ LITE_OS_SEC_TEXT_MINOR UINT8 *OsConvertTskStatus(UINT16 taskStatus)
     } else if (taskStatus & OS_TASK_STATUS_DELAY) {
         return (UINT8 *)"Delay";
     } else if (taskStatus & OS_TASK_STATUS_PEND) {
-        if (taskStatus & OS_TASK_STATUS_TIMEOUT) {
-            return (UINT8 *)"PendTimeOut";
+        if (taskStatus & OS_TASK_STATUS_PEND_TIME) {
+            return (UINT8 *)"PendTime";
         }
-
         return (UINT8 *)"Pend";
     } else if (taskStatus & OS_TASK_STATUS_SUSPEND) {
         return (UINT8 *)"Suspend";
-    } else if (taskStatus & OS_TASK_STATUS_PEND_QUEUE) {
-        if (taskStatus & OS_TASK_STATUS_TIMEOUT) {
-            return (UINT8 *)"QueuePendTimeOut";
-        }
-
-        return (UINT8 *)"QueuePend";
     }
 
     return (UINT8 *)"Impossible";
@@ -534,10 +314,6 @@ LITE_OS_SEC_TEXT_MINOR UINT32 OsGetAllTskInfo(VOID)
 
     OsPrintAllTskInfoHeader();
 
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
-    UINT32 flag = osStackProtDisable();
-#endif
-
     for (loopNum = 0; loopNum < g_taskMaxNum; loopNum++) {
         taskCB = (((LosTaskCB *)g_taskCBArray) + loopNum);
         if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
@@ -545,9 +321,9 @@ LITE_OS_SEC_TEXT_MINOR UINT32 OsGetAllTskInfo(VOID)
         }
 
         PRINTK("%d    %d    %s    0x%x    0x%x    0x%x    0x%x    0x%x    ",
-                  taskCB->taskID, taskCB->priority, OsConvertTskStatus(taskCB->taskStatus),
-                  taskCB->stackSize, OsGetTaskWaterLine(taskCB->taskID),
-                  (UINT32)(UINTPTR)taskCB->stackPointer, taskCB->topOfStack, taskCB->eventMask);
+               taskCB->taskID, taskCB->priority, OsConvertTskStatus(taskCB->taskStatus),
+               taskCB->stackSize, OsGetTaskWaterLine(taskCB->taskID),
+               (UINT32)(UINTPTR)taskCB->stackPointer, taskCB->topOfStack, taskCB->eventMask);
 
         semID = (taskCB->taskSem == NULL) ? OS_NULL_SHORT : (((LosSemCB *)taskCB->taskSem)->semID);
         PRINTK("0x%x    ", semID);
@@ -564,10 +340,6 @@ LITE_OS_SEC_TEXT_MINOR UINT32 OsGetAllTskInfo(VOID)
         PRINTK("%s\n", taskCB->taskName);
     }
 
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
-    osStackProtRestore(flag);
-#endif
-
 #if (LOSCFG_BASE_CORE_CPUP == 1)
     (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, cpuLessOneSec);
     (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, cpuTenSec);
@@ -588,8 +360,6 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsTaskInit(VOID)
 {
     UINT32 size;
     UINT32 index;
-    LOS_DL_LIST *listObject = NULL;
-    UINT32 queueResult;
 
     size = (g_taskMaxNum + 1) * sizeof(LosTaskCB);
     g_taskCBArray = (LosTaskCB *)LOS_MemAlloc(m_aucSysMem0, size);
@@ -613,28 +383,9 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsTaskInit(VOID)
     g_losTask.runTask->taskID = index;
     g_losTask.runTask->taskStatus = (OS_TASK_STATUS_UNUSED | OS_TASK_STATUS_RUNNING);
     g_losTask.runTask->priority = OS_TASK_PRIORITY_LOWEST + 1;
-    queueResult = OsPriqueueInit();
-    if (queueResult == LOS_NOK) {
-        (VOID)LOS_MemFree(m_aucSysMem0, g_taskCBArray);
-        return LOS_ERRNO_TSK_NO_MEMORY;
-    }
 
-    size = sizeof(LOS_DL_LIST) * OS_TSK_SORTLINK_LEN;
-    listObject = (LOS_DL_LIST *)LOS_MemAlloc(m_aucSysMem0, size);
-    if (listObject == NULL) {
-        (VOID)LOS_MemFree(m_aucSysMem0, g_taskCBArray);
-        return LOS_ERRNO_TSK_NO_MEMORY;
-    }
-
-    // Ignore the return code when matching CSEC rule 6.6(3).
-    (VOID)memset_s((VOID *)listObject, size, 0, size);
-    g_taskSortLink.sortLink = listObject;
-    g_taskSortLink.cursor = 0;
-    for (index = 0; index < OS_TSK_SORTLINK_LEN; index++, listObject++) {
-        LOS_ListInit(listObject);
-    }
-
-    return LOS_OK;
+    g_idleTaskID = OS_INVALID;
+    return OsSchedInit();
 }
 
 
@@ -655,12 +406,13 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsIdleTaskCreate(VOID)
     taskInitParam.uwStackSize = LOSCFG_BASE_CORE_TSK_IDLE_STACK_SIZE;
     taskInitParam.pcName = "IdleCore000";
     taskInitParam.usTaskPrio = OS_TASK_PRIORITY_LOWEST;
-    retVal = LOS_TaskCreate(&g_idleTaskID, &taskInitParam);
+    retVal = LOS_TaskCreateOnly(&g_idleTaskID, &taskInitParam);
 
     if (retVal != LOS_OK) {
         return retVal;
     }
 
+    OsSchedSetIdleTaskSchedParam(OS_TCB_FROM_TID(g_idleTaskID));
     return LOS_OK;
 }
 
@@ -688,10 +440,11 @@ LITE_OS_SEC_TEXT UINT32 LOS_CurTaskIDGet(VOID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_NextTaskIDGet(VOID)
 {
-    if (g_losTask.newTask == NULL) {
-        return LOS_ERRNO_TSK_ID_INVALID;
-    }
-    return g_losTask.newTask->taskID;
+    UINT32 intSave = LOS_IntLock();
+    UINT32 taskID = OsGetTopTask()->taskID;
+    LOS_IntRestore(intSave);
+
+    return taskID;
 }
 
 /*****************************************************************************
@@ -713,7 +466,7 @@ LITE_OS_SEC_TEXT CHAR *LOS_CurTaskNameGet(VOID)
 }
 
 #if (LOSCFG_BASE_CORE_TSK_MONITOR == 1)
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 0)
+#if (LOSCFG_EXC_HARDWARE_STACK_PROTECTION == 0)
 /*****************************************************************************
  Function    : OsHandleRunTaskStackOverflow
  Description : handle stack overflow exception of the run task.
@@ -753,6 +506,32 @@ LITE_OS_SEC_TEXT STATIC VOID OsHandleNewTaskStackOverflow(VOID)
     OsDoExcHook(EXC_STACKOVERFLOW);
     g_losTask.runTask = tmp;
 }
+#else
+LITE_OS_SEC_TEXT STATIC VOID OsTaskStackProtect(VOID)
+{
+    MPU_CFG_PARA mpuAttr = {0};
+    STATIC INT32 id = -1;
+
+    if (id == -1) {
+        id = HalMpuUnusedRegionGet();
+        if (id < 0) {
+            PRINT_ERR("%s %d, get unused id failed!\n", __FUNCTION__, __LINE__);
+            return;
+        }
+    }
+
+    mpuAttr.baseAddr = g_losTask.newTask->topOfStack - OS_TASK_STACK_PROTECT_SIZE;
+    mpuAttr.size = OS_TASK_STACK_PROTECT_SIZE;
+    mpuAttr.memType = MPU_MEM_ON_CHIP_RAM;
+    mpuAttr.executable = MPU_NON_EXECUTABLE;
+    mpuAttr.shareability = MPU_NO_SHARE;
+    mpuAttr.permission = MPU_RO_BY_PRIVILEGED_ONLY;
+
+    HalMpuDisable();
+    (VOID)HalMpuDisableRegion(id);
+    (VOID)HalMpuSetRegion(id, &mpuAttr);
+    HalMpuEnable(1);
+}
 #endif
 #endif
 
@@ -766,8 +545,8 @@ LITE_OS_SEC_TEXT STATIC VOID OsHandleNewTaskStackOverflow(VOID)
 #if (LOSCFG_BASE_CORE_TSK_MONITOR == 1)
 LITE_OS_SEC_TEXT VOID OsTaskSwitchCheck(VOID)
 {
-    UINTPTR intSave = LOS_IntLock();
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 0)
+    UINT32 intSave = LOS_IntLock();
+#if (LOSCFG_EXC_HARDWARE_STACK_PROTECTION == 0)
     UINT32 endOfStack = g_losTask.newTask->topOfStack + g_losTask.newTask->stackSize;
 
     if ((*(UINT32 *)(UINTPTR)(g_losTask.runTask->topOfStack)) != OS_TASK_MAGIC_WORD) {
@@ -777,6 +556,8 @@ LITE_OS_SEC_TEXT VOID OsTaskSwitchCheck(VOID)
         ((UINT32)(UINTPTR)(g_losTask.newTask->stackPointer) > endOfStack)) {
         OsHandleNewTaskStackOverflow();
     }
+#else
+    OsTaskStackProtect();
 #endif
 
 #if (LOSCFG_BASE_CORE_EXC_TSK_SWITCH == 1)
@@ -796,13 +577,7 @@ LITE_OS_SEC_TEXT VOID OsTaskSwitchCheck(VOID)
     }
 #endif
 
-    if (g_pfnUsrTskSwitchHook != NULL) {
-        g_pfnUsrTskSwitchHook();
-    }
-
-#if (LOSCFG_KERNEL_TRACE == 1)
-    LOS_Trace(LOS_TRACE_SWITCH, 0);
-#endif
+    LOSCFG_BASE_CORE_TSK_SWITCH_HOOK();
 
 #if (LOSCFG_BASE_CORE_CPUP == 1)
     OsTskCycleEndStart();
@@ -817,7 +592,6 @@ LITE_OS_SEC_TEXT_MINOR VOID OsTaskMonInit(VOID)
     (VOID)memset_s(&g_taskSwitchInfo, sizeof(TaskSwitchInfo), 0, sizeof(TaskSwitchInfo));
     g_taskSwitchInfo.cntInfo.maxCnt = OS_TASK_SWITCH_INFO_COUNT;
 #endif
-    g_pfnUsrTskSwitchHook = NULL;
     return;
 }
 #endif
@@ -832,11 +606,7 @@ LITE_OS_SEC_TEXT_MINOR VOID OsTaskMonInit(VOID)
 LITE_OS_SEC_TEXT_INIT VOID OsTaskEntry(UINT32 taskID)
 {
     UINT32 retVal;
-    LosTaskCB *taskCB = NULL;
-
-    OS_TASK_ID_CHECK(taskID);
-
-    taskCB = OS_TCB_FROM_TID(taskID);
+    LosTaskCB *taskCB = OS_TCB_FROM_TID(taskID);
 
     (VOID)taskCB->taskEntry(taskCB->arg);
 
@@ -886,7 +656,6 @@ LITE_OS_SEC_TEXT_INIT STATIC_INLINE UINT32 OsTaskInitParamCheck(TSK_INIT_PARAM_S
 
 LITE_OS_SEC_TEXT_INIT UINT32 OsNewTaskInit(LosTaskCB *taskCB, TSK_INIT_PARAM_S *taskInitParam, VOID *topOfStack)
 {
-    taskCB->stackPointer    = HalTskStackInit(taskCB->taskID, taskInitParam->uwStackSize, topOfStack);
     taskCB->arg             = taskInitParam->uwArg;
     taskCB->topOfStack      = (UINT32)(UINTPTR)topOfStack;
     taskCB->stackSize       = taskInitParam->uwStackSize;
@@ -894,11 +663,15 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsNewTaskInit(LosTaskCB *taskCB, TSK_INIT_PARAM_S *
     taskCB->taskMux         = NULL;
     taskCB->taskStatus      = OS_TASK_STATUS_SUSPEND;
     taskCB->priority        = taskInitParam->usTaskPrio;
+    taskCB->timeSlice       = 0;
+    taskCB->waitTimes       = 0;
     taskCB->taskEntry       = taskInitParam->pfnTaskEntry;
     taskCB->event.uwEventID = OS_NULL_INT;
     taskCB->eventMask       = 0;
     taskCB->taskName        = taskInitParam->pcName;
     taskCB->msg             = NULL;
+    taskCB->stackPointer    = HalTskStackInit(taskCB->taskID, taskInitParam->uwStackSize, topOfStack);
+    SET_SORTLIST_VALUE(&taskCB->sortList, OS_SORT_LINK_INVALID_TIME);
     return LOS_OK;
 }
 
@@ -911,7 +684,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsNewTaskInit(LosTaskCB *taskCB, TSK_INIT_PARAM_S *
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreateOnly(UINT32 *taskID, TSK_INIT_PARAM_S *taskInitParam)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     VOID  *topOfStack = NULL;
     LosTaskCB *taskCB = NULL;
     UINT32 retVal;
@@ -938,8 +711,14 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreateOnly(UINT32 *taskID, TSK_INIT_PARAM_S
 
     LOS_IntRestore(intSave);
 
+#if (LOSCFG_EXC_HARDWARE_STACK_PROTECTION == 1)
+    UINTPTR stackPtr = (UINTPTR)LOS_MemAllocAlign(OS_TASK_STACK_ADDR, taskInitParam->uwStackSize +
+        OS_TASK_STACK_PROTECT_SIZE, OS_TASK_STACK_PROTECT_SIZE);
+    topOfStack = (VOID *)(stackPtr + OS_TASK_STACK_PROTECT_SIZE);
+#else
     topOfStack = (VOID *)LOS_MemAllocAlign(OS_TASK_STACK_ADDR, taskInitParam->uwStackSize,
         LOSCFG_STACK_POINT_ALIGN_SIZE);
+#endif
     if (topOfStack == NULL) {
         intSave = LOS_IntLock();
         LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
@@ -951,8 +730,14 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreateOnly(UINT32 *taskID, TSK_INIT_PARAM_S
     if (retVal != LOS_OK) {
         return retVal;
     }
-
+#if (LOSCFG_BASE_CORE_CPUP == 1)
+    intSave = LOS_IntLock();
+    g_cpup[taskCB->taskID].cpupID = taskCB->taskID;
+    g_cpup[taskCB->taskID].status = taskCB->taskStatus;
+    LOS_IntRestore(intSave);
+#endif
     *taskID = taskCB->taskID;
+    OsHookCall(LOS_HOOK_TYPE_TASK_CREATE, taskCB);
     return retVal;
 
 LOS_ERREND:
@@ -960,21 +745,6 @@ LOS_ERREND:
     return retVal;
 }
 
-/* ****************************************************************************
- Function    : OsTaskSchedule
- Description : Function to check task schedule and do real task schedule.
- Input       : None
- Output      : None
- Return      : None
- **************************************************************************** */
-VOID OsTaskSchedule(VOID)
-{
-#if (LOSCFG_BASE_CORE_TSK_MONITOR == 1)
-    OsTaskSwitchCheck();
-#endif
-    HalTaskSchedule();
-}
-
 /*****************************************************************************
  Function    : LOS_TaskCreate
  Description : Create a task
@@ -985,7 +755,7 @@ VOID OsTaskSchedule(VOID)
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreate(UINT32 *taskID, TSK_INIT_PARAM_S *taskInitParam)
 {
     UINT32 retVal;
-    UINTPTR intSave;
+    UINT32 intSave;
     LosTaskCB *taskCB = NULL;
 
     retVal = LOS_TaskCreateOnly(taskID, taskInitParam);
@@ -995,28 +765,14 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreate(UINT32 *taskID, TSK_INIT_PARAM_S *ta
     taskCB = OS_TCB_FROM_TID(*taskID);
 
     intSave = LOS_IntLock();
-    taskCB->taskStatus &= (~OS_TASK_STATUS_SUSPEND);
-    taskCB->taskStatus |= OS_TASK_STATUS_READY;
-
-#if (LOSCFG_BASE_CORE_CPUP == 1)
-    g_cpup[taskCB->taskID].cpupID = taskCB->taskID;
-    g_cpup[taskCB->taskID].status = taskCB->taskStatus;
-#endif
 
-    OsPriqueueEnqueue(&taskCB->pendList, taskCB->priority);
-    g_losTask.newTask = LOS_DL_LIST_ENTRY(OsPriqueueTop(), LosTaskCB, pendList);
+    OsSchedTaskEnQueue(taskCB);
+    LOS_IntRestore(intSave);
 
-    if ((g_taskScheduled) && (g_losTaskLock == 0)) {
-        if (g_losTask.runTask != g_losTask.newTask) {
-            if (LOS_CHECK_SCHEDULE) {
-                LOS_IntRestore(intSave);
-                OsTaskSchedule();
-                return LOS_OK;
-            }
-        }
+    if (g_taskScheduled) {
+        LOS_Schedule();
     }
 
-    LOS_IntRestore(intSave);
     return LOS_OK;
 }
 
@@ -1029,7 +785,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreate(UINT32 *taskID, TSK_INIT_PARAM_S *ta
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskResume(UINT32 taskID)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     LosTaskCB *taskCB = NULL;
     UINT16 tempStatus;
     UINT32 retErr = OS_ERROR;
@@ -1052,14 +808,12 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskResume(UINT32 taskID)
 
     taskCB->taskStatus &= (~OS_TASK_STATUS_SUSPEND);
     if (!(taskCB->taskStatus & OS_CHECK_TASK_BLOCK)) {
-        taskCB->taskStatus |= OS_TASK_STATUS_READY;
-        OsPriqueueEnqueue(&taskCB->pendList, taskCB->priority);
+        OsSchedTaskEnQueue(taskCB);
         if (g_taskScheduled) {
             LOS_IntRestore(intSave);
             LOS_Schedule();
             return LOS_OK;
         }
-        g_losTask.newTask = LOS_DL_LIST_ENTRY(OsPriqueueTop(), LosTaskCB, pendList);
     }
 
     LOS_IntRestore(intSave);
@@ -1079,7 +833,7 @@ LOS_ERREND:
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskSuspend(UINT32 taskID)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     LosTaskCB *taskCB = NULL;
     UINT16 tempStatus;
     UINT32 retErr;
@@ -1108,11 +862,11 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskSuspend(UINT32 taskID)
     }
 
     if (tempStatus & OS_TASK_STATUS_READY) {
-        OsPriqueueDequeue(&taskCB->pendList);
-        taskCB->taskStatus &= (~OS_TASK_STATUS_READY);
+        OsSchedTaskDeQueue(taskCB);
     }
 
     taskCB->taskStatus |= OS_TASK_STATUS_SUSPEND;
+    OsHookCall(LOS_HOOK_TYPE_MOVEDTASKTOSUSPENDEDLIST, taskCB);
     if (taskID == g_losTask.runTask->taskID) {
         LOS_IntRestore(intSave);
         LOS_Schedule();
@@ -1132,7 +886,7 @@ LITE_OS_SEC_TEXT_INIT STATIC_INLINE VOID OsRunningTaskDelete(UINT32 taskID, LosT
     LOS_ListTailInsert(&g_taskRecyleList, &taskCB->pendList);
     g_losTask.runTask = &g_taskCBArray[g_taskMaxNum];
     g_losTask.runTask->taskID = taskID;
-    g_losTask.runTask->taskStatus = taskCB->taskStatus;
+    g_losTask.runTask->taskStatus = taskCB->taskStatus | OS_TASK_STATUS_RUNNING;
     g_losTask.runTask->topOfStack = taskCB->topOfStack;
     g_losTask.runTask->taskName = taskCB->taskName;
 }
@@ -1145,8 +899,9 @@ LITE_OS_SEC_TEXT_INIT STATIC_INLINE VOID OsRunningTaskDelete(UINT32 taskID, LosT
  *****************************************************************************/
 LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskDelete(UINT32 taskID)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     LosTaskCB *taskCB = OS_TCB_FROM_TID(taskID);
+    UINTPTR stackPtr;
 
     UINT32 ret = OsCheckTaskIDValid(taskID);
     if (ret != LOS_OK) {
@@ -1166,36 +921,30 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskDelete(UINT32 taskID)
         g_losTaskLock = 0;
     }
 
-    if ((taskCB->taskStatus) & OS_TASK_STATUS_READY) {
-        OsPriqueueDequeue(&taskCB->pendList);
-        taskCB->taskStatus &= (~OS_TASK_STATUS_READY);
-    } else if (((taskCB->taskStatus) & (OS_TASK_STATUS_PEND | OS_TASK_STATUS_PEND_QUEUE))) {
-        LOS_ListDelete(&taskCB->pendList);
-    }
-
-    if ((taskCB->taskStatus) & (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_TIMEOUT)) {
-        OsTimerListDelete(taskCB);
-    }
+    OsHookCall(LOS_HOOK_TYPE_TASK_DELETE, taskCB);
+    OsSchedTaskExit(taskCB);
 
-    taskCB->taskStatus &= (~(OS_TASK_STATUS_SUSPEND));
-    taskCB->taskStatus |= OS_TASK_STATUS_UNUSED;
     taskCB->event.uwEventID = OS_NULL_INT;
     taskCB->eventMask = 0;
 #if (LOSCFG_BASE_CORE_CPUP == 1)
     // Ignore the return code when matching CSEC rule 6.6(4).
     (VOID)memset_s((VOID *)&g_cpup[taskCB->taskID], sizeof(OsCpupCB), 0, sizeof(OsCpupCB));
 #endif
-    g_losTask.newTask = LOS_DL_LIST_ENTRY(OsPriqueueTop(), LosTaskCB, pendList);
     if (taskCB->taskStatus & OS_TASK_STATUS_RUNNING) {
-        OsRunningTaskDelete(taskID, taskCB);
         taskCB->taskStatus = OS_TASK_STATUS_UNUSED;
+        OsRunningTaskDelete(taskID, taskCB);
         LOS_IntRestore(intSave);
-        OsTaskSchedule();
+        LOS_Schedule();
         return LOS_OK;
     } else {
         taskCB->taskStatus = OS_TASK_STATUS_UNUSED;
         LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
-        (VOID)LOS_MemFree(OS_TASK_STACK_ADDR, (VOID *)(UINTPTR)taskCB->topOfStack);
+#if (LOSCFG_EXC_HARDWARE_STACK_PROTECTION == 1)
+        stackPtr = taskCB->topOfStack - OS_TASK_STACK_PROTECT_SIZE;
+#else
+        stackPtr = taskCB->topOfStack;
+#endif
+        (VOID)LOS_MemFree(OS_TASK_STACK_ADDR, (VOID *)stackPtr);
         taskCB->topOfStack = (UINT32)NULL;
     }
 
@@ -1212,7 +961,7 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskDelete(UINT32 taskID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_TaskDelay(UINT32 tick)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
 
     if (OS_INT_ACTIVE) {
         return LOS_ERRNO_TSK_DELAY_IN_INT;
@@ -1222,14 +971,13 @@ LITE_OS_SEC_TEXT UINT32 LOS_TaskDelay(UINT32 tick)
         return LOS_ERRNO_TSK_DELAY_IN_LOCK;
     }
 
+    OsHookCall(LOS_HOOK_TYPE_TASK_DELAY, tick);
     if (tick == 0) {
         return LOS_TaskYield();
     } else {
         intSave = LOS_IntLock();
-        OsPriqueueDequeue(&(g_losTask.runTask->pendList));
-        g_losTask.runTask->taskStatus &= (~OS_TASK_STATUS_READY);
-        OsTaskAdd2TimerList((LosTaskCB *)g_losTask.runTask, tick);
-        g_losTask.runTask->taskStatus |= OS_TASK_STATUS_DELAY;
+        OsSchedDelay(g_losTask.runTask, tick);
+        OsHookCall(LOS_HOOK_TYPE_MOVEDTASKTODELAYEDLIST, g_losTask.runTask);
         LOS_IntRestore(intSave);
         LOS_Schedule();
     }
@@ -1239,7 +987,7 @@ LITE_OS_SEC_TEXT UINT32 LOS_TaskDelay(UINT32 tick)
 
 LITE_OS_SEC_TEXT_MINOR UINT16 LOS_TaskPriGet(UINT32 taskID)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     LosTaskCB *taskCB = NULL;
     UINT16 priority;
 
@@ -1264,7 +1012,7 @@ LITE_OS_SEC_TEXT_MINOR UINT16 LOS_TaskPriGet(UINT32 taskID)
 LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskPriSet(UINT32 taskID, UINT16 taskPrio)
 {
     BOOL isReady = FALSE;
-    UINTPTR intSave;
+    UINT32 intSave;
     LosTaskCB *taskCB = NULL;
     UINT16 tempStatus;
 
@@ -1291,18 +1039,8 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskPriSet(UINT32 taskID, UINT16 taskPrio)
         LOS_IntRestore(intSave);
         return LOS_ERRNO_TSK_NOT_CREATED;
     }
-    /* delete the task and insert with right priority into ready queue */
-    isReady = (tempStatus & OS_TASK_STATUS_READY);
-    if (isReady) {
-        OsPriqueueDequeue(&taskCB->pendList);
-        taskCB->taskStatus &= (~OS_TASK_STATUS_READY);
-        taskCB->priority = taskPrio;
-        taskCB->taskStatus |= OS_TASK_STATUS_READY;
-        OsPriqueueEnqueue(&taskCB->pendList, taskCB->priority);
-    } else {
-        taskCB->priority = taskPrio;
-    }
 
+    isReady = OsSchedModifyTaskSchedParam(taskCB, taskPrio);
     LOS_IntRestore(intSave);
     /* delete the task and insert with right priority into ready queue */
     if (isReady) {
@@ -1314,57 +1052,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskPriSet(UINT32 taskID, UINT16 taskPrio)
 
 LITE_OS_SEC_TEXT_MINOR UINT32 LOS_CurTaskPriSet(UINT16 taskPrio)
 {
-    UINT32 retVal;
-    retVal = LOS_TaskPriSet(g_losTask.runTask->taskID, taskPrio);
-    return retVal;
-}
-
-/**************************************************************************
- Function    : OsTaskWait
- Description : pend the running task in a list
- Input       : pendingList   -- The pending list
-               taskStatus    -- The status need to be converted to
-               timeout       -- Expiry time
- Output      : None
- Return      : None
-**************************************************************************/
-VOID OsTaskWait(LOS_DL_LIST *pendingList, UINT32 taskStatus, UINT32 timeout)
-{
-    LosTaskCB *runTask = NULL;
-    LOS_DL_LIST *pendObj = NULL;
-
-    runTask = g_losTask.runTask;
-    OsPriqueueDequeue(&runTask->pendList);
-    runTask->taskStatus &= (~OS_TASK_STATUS_READY);
-    pendObj = &runTask->pendList;
-    runTask->taskStatus |= taskStatus;
-    LOS_ListTailInsert(pendingList, pendObj);
-    if (timeout != LOS_WAIT_FOREVER) {
-        runTask->taskStatus |= OS_TASK_STATUS_TIMEOUT;
-        OsTaskAdd2TimerList((LosTaskCB *)runTask, timeout);
-    }
-}
-
-/**************************************************************************
- Function    : OsTaskWake
- Description : delete the task from pendlist and also add to the priqueue
- Input       : resumedTask    --  resumed task
-             : taskStatus     --  the status to be unset
- Output      : resumedTask    --  resumed task
- Return      : None
-**************************************************************************/
-VOID OsTaskWake(LosTaskCB *resumedTask, UINT32 taskStatus)
-{
-    LOS_ListDelete(&resumedTask->pendList);
-    resumedTask->taskStatus &= (~taskStatus);
-    if (resumedTask->taskStatus & OS_TASK_STATUS_TIMEOUT) {
-        OsTimerListDelete(resumedTask);
-        resumedTask->taskStatus &= (~OS_TASK_STATUS_TIMEOUT);
-    }
-    if (!(resumedTask->taskStatus & OS_TASK_STATUS_SUSPEND)) {
-        resumedTask->taskStatus |= OS_TASK_STATUS_READY;
-        OsPriqueueEnqueue(&resumedTask->pendList, resumedTask->priority);
-    }
+    return LOS_TaskPriSet(g_losTask.runTask->taskID, taskPrio);
 }
 
 /*****************************************************************************
@@ -1376,28 +1064,10 @@ VOID OsTaskWake(LosTaskCB *resumedTask, UINT32 taskStatus)
  *****************************************************************************/
 LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskYield(VOID)
 {
-    UINT32 taskCount;
-    UINTPTR intSave;
-
-    if (g_losTask.runTask->taskID >= g_taskMaxNum) {
-        return LOS_ERRNO_TSK_ID_INVALID;
-    }
-
-    if (!(g_losTask.runTask->taskStatus & OS_TASK_STATUS_READY)) {
-        return LOS_OK;
-    }
+    UINT32 intSave;
 
     intSave = LOS_IntLock();
-    taskCount = OsPriqueueSize(g_losTask.runTask->priority);
-    if (taskCount > 1) {
-        LOS_ListDelete(&(g_losTask.runTask->pendList));
-        g_losTask.runTask->taskStatus |= OS_TASK_STATUS_READY;
-        OsPriqueueEnqueue(&(g_losTask.runTask->pendList), g_losTask.runTask->priority);
-    } else {
-        LOS_IntRestore(intSave);
-        return LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK;
-    }
-
+    OsSchedYield();
     LOS_IntRestore(intSave);
     LOS_Schedule();
     return LOS_OK;
@@ -1412,7 +1082,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskYield(VOID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT_MINOR VOID LOS_TaskLock(VOID)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
 
     intSave = LOS_IntLock();
     g_losTaskLock++;
@@ -1428,7 +1098,7 @@ LITE_OS_SEC_TEXT_MINOR VOID LOS_TaskLock(VOID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT_MINOR VOID LOS_TaskUnlock(VOID)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
 
     intSave = LOS_IntLock();
     if (g_losTaskLock > 0) {
@@ -1447,9 +1117,6 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskInfoGet(UINT32 taskID, TSK_INFO_S *taskInf
 {
     UINT32 intSave;
     LosTaskCB *taskCB = NULL;
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
-    UINT32 flag;
-#endif
 
     if (taskInfo == NULL) {
         return LOS_ERRNO_TSK_PTR_NULL;
@@ -1488,18 +1155,8 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskInfoGet(UINT32 taskID, TSK_INFO_S *taskInf
     taskInfo->uwBottomOfStack = TRUNCATE(((UINT32)(taskCB->topOfStack) + (taskCB->stackSize)),
                                          OS_TASK_STACK_ADDR_ALIGN);
     taskInfo->uwCurrUsed = taskInfo->uwBottomOfStack - taskInfo->uwSP;
-
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
-    flag = osStackProtDisable();
-#endif
-
     taskInfo->uwPeakUsed = OsGetTaskWaterLine(taskID);
     taskInfo->bOvf = (taskInfo->uwPeakUsed == OS_NULL_INT) ? TRUE : FALSE;
-
-#if (LOSCFG_EXC_HRADWARE_STACK_PROTECTION == 1)
-    osStackProtRestore(flag);
-#endif
-
     LOS_IntRestore(intSave);
 
     return LOS_OK;
@@ -1536,7 +1193,7 @@ LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskStatusGet(UINT32 taskID, UINT32 *taskStatu
 #if (LOSCFG_BASE_CORE_EXC_TSK_SWITCH == 1)
 LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskSwitchInfoGet(UINT32 index, UINT32 *taskSwitchInfo)
 {
-    UINTPTR intSave;
+    UINT32 intSave;
     UINT32 curIndex;
 
     curIndex = index;
@@ -1598,10 +1255,7 @@ LITE_OS_SEC_TEXT_MINOR BOOL LOS_TaskIsRunning(VOID)
  *****************************************************************************/
 LITE_OS_SEC_TEXT UINT32 LOS_NewTaskIDGet(VOID)
 {
-    if (g_losTask.newTask == NULL) {
-        return LOS_ERRNO_TSK_ID_INVALID;
-    }
-    return g_losTask.newTask->taskID;
+    return LOS_NextTaskIDGet();
 }
 
 /*****************************************************************************
@@ -1632,70 +1286,6 @@ LITE_OS_SEC_TEXT CHAR* LOS_TaskNameGet(UINT32 taskID)
     return taskCB->taskName;
 }
 
-/* ****************************************************************************
- Function    : LOS_Schedule
- Description : Function to determine whether task scheduling is required.
- Input       : None
- Output      : None
- Return      : None
- **************************************************************************** */
-VOID LOS_Schedule(VOID)
-{
-    UINTPTR intSave;
-
-    intSave = LOS_IntLock();
-    /* Find the highest task */
-    g_losTask.newTask = LOS_DL_LIST_ENTRY(OsPriqueueTop(), LosTaskCB, pendList);
-    /* In case that running is not highest then reschedule */
-    if (g_losTask.runTask != g_losTask.newTask) {
-        if (LOS_CHECK_SCHEDULE) {
-            LOS_IntRestore(intSave);
-            OsTaskSchedule();
-            return;
-        }
-    }
-    LOS_IntRestore(intSave);
-}
-
-#if (LOSCFG_BASE_CORE_TIMESLICE == 1)
-LITE_OS_SEC_BSS OsTaskRobin g_taskTimeSlice;
-
-/*****************************************************************************
- Function     : OsTimesliceInit
- Description  : Initialztion Timeslice
- Input        : None
- Output       : None
- Return       : None
- *****************************************************************************/
-LITE_OS_SEC_TEXT_INIT VOID OsTimesliceInit(VOID)
-{
-    g_taskTimeSlice.task = (LosTaskCB *)NULL;
-    g_taskTimeSlice.tout = LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT;
-}
-
-/*****************************************************************************
- Function     : OsTimesliceCheck
- Description  : check Timeslice
- Input        : None
- Output       : None
- Return       : None
- *****************************************************************************/
-LITE_OS_SEC_TEXT VOID OsTimesliceCheck(VOID)
-{
-    if (g_taskTimeSlice.task != g_losTask.runTask) {
-        g_taskTimeSlice.task = g_losTask.runTask;
-        g_taskTimeSlice.time = ((UINT16)g_ullTickCount + g_taskTimeSlice.tout) - 1;
-    }
-
-    if (g_taskTimeSlice.time  == (UINT16)g_ullTickCount) {
-        g_taskTimeSlice.task = (LosTaskCB *)NULL;
-        if (LOS_TaskYield() != LOS_OK) {
-            PRINT_INFO("%s, %d\n", __FUNCTION__, __LINE__);
-        }
-    }
-}
-#endif
-
 LITE_OS_SEC_TEXT_MINOR VOID LOS_Msleep(UINT32 mSecs)
 {
     UINT32 interval;
@@ -1716,8 +1306,19 @@ LITE_OS_SEC_TEXT_MINOR VOID LOS_Msleep(UINT32 mSecs)
     (VOID)LOS_TaskDelay(interval);
 }
 
-#ifdef __cplusplus
-#if __cplusplus
+VOID LOS_UDelay(UINT64 microseconds)
+{
+    UINT64 endTime;
+
+    if (microseconds == 0) {
+        return;
+    }
+
+    endTime = (microseconds / OS_SYS_US_PER_SECOND) * OS_SYS_CLOCK +
+            (microseconds % OS_SYS_US_PER_SECOND) * OS_SYS_CLOCK / OS_SYS_US_PER_SECOND;
+    endTime = LOS_SysCycleGet() + endTime;
+    while (LOS_SysCycleGet() < endTime) {
+    }
+
+    return;
 }
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/los_tick.c b/kernel/liteos_m/kernel/src/los_tick.c
index ea4e66d..897a44e 100644
--- a/kernel/liteos_m/kernel/src/los_tick.c
+++ b/kernel/liteos_m/kernel/src/los_tick.c
@@ -30,17 +30,12 @@
  */
 
 #include "los_tick.h"
+#include "los_config.h"
 #include "los_task.h"
 #include "los_swtmr.h"
-#include "los_config.h"
+#include "los_sched.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
-LITE_OS_SEC_BSS UINT64 g_ullTickCount;
 LITE_OS_SEC_BSS UINT32 g_ticksPerSec;
 LITE_OS_SEC_BSS UINT32 g_uwCyclePerSec;
 LITE_OS_SEC_BSS UINT32 g_cyclesPerTick;
@@ -52,29 +47,22 @@ extern VOID platform_tick_handler(VOID);
 
 LITE_OS_SEC_TEXT VOID OsTickHandler(VOID)
 {
-#if (LOSCFG_BASE_CORE_TICK_HW_TIME == 1)
-    platform_tick_handler();
+#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)
+    OsSchedUpdateSchedTimeBase();
 #endif
 
-    g_ullTickCount++;
-
-#if (LOSCFG_BASE_CORE_TIMESLICE == 1)
-    OsTimesliceCheck();
+#if (LOSCFG_BASE_CORE_TICK_HW_TIME == 1)
+    platform_tick_handler();
 #endif
 
-    OsTaskScan();  // task timeout scan
-
-#if (LOSCFG_BASE_CORE_SWTMR == 1)
-    (VOID)OsSwtmrScan();
-#endif
+    LOS_SchedTickHandler();
 }
 
-UINT32 LOS_SysClockGet(VOID)
+UINT64 LOS_SysCycleGet(VOID)
 {
-    return g_sysClock;
+    return OsGetCurrSchedTimeCycle();
 }
 
-
 /*****************************************************************************
 Function    : LOS_TickCountGet
 Description : get current tick
@@ -84,7 +72,7 @@ Return      : current tick
 *****************************************************************************/
 LITE_OS_SEC_TEXT_MINOR UINT64 LOS_TickCountGet(VOID)
 {
-    return g_ullTickCount;
+    return OsGetCurrSchedTimeCycle() / OS_CYCLE_PER_TICK;
 }
 
 /*****************************************************************************
@@ -190,8 +178,3 @@ LITE_OS_SEC_TEXT_INIT UINT32 OsCpuTick2US(CpuTick *cpuTick, UINT32 *usHi, UINT32
 }
 
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/mm/los_membox.c b/kernel/liteos_m/kernel/src/mm/los_membox.c
old mode 100755
new mode 100644
index a4c1201..2615e73
--- a/kernel/liteos_m/kernel/src/mm/los_membox.c
+++ b/kernel/liteos_m/kernel/src/mm/los_membox.c
@@ -36,11 +36,6 @@
 #include "los_debug.h"
 #include "los_task.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 /* The magic length is 32 bits, the lower 8 bits are used to save the owner task ID,
    and the other 24 bits are used to set the magic number for verification. */
@@ -134,11 +129,7 @@ UINT32 LOS_MemboxInit(VOID *pool, UINT32 poolSize, UINT32 blkSize)
     }
 
     MEMBOX_LOCK(intSave);
-    boxInfo->uwBlkSize = LOS_MEMBOX_ALLIGNED(blkSize + OS_MEMBOX_NODE_HEAD_SIZE);
-    if (boxInfo->uwBlkSize == 0) {
-        MEMBOX_UNLOCK(intSave);
-        return LOS_NOK;
-    }
+    boxInfo->uwBlkSize = LOS_MEMBOX_ALIGNED(blkSize + OS_MEMBOX_NODE_HEAD_SIZE);
     boxInfo->uwBlkNum = (poolSize - sizeof(LOS_MEMBOX_INFO)) / boxInfo->uwBlkSize;
     boxInfo->uwBlkCnt = 0;
     if (boxInfo->uwBlkNum == 0) {
@@ -240,18 +231,18 @@ VOID LOS_ShowBox(VOID *pool)
         return;
     }
     MEMBOX_LOCK(intSave);
-    PRINT_INFO("membox(0x%x,0x%x,0x%x):\r\n", pool, boxInfo->uwBlkSize, boxInfo->uwBlkNum);
+    PRINT_INFO("membox(%p, 0x%x, 0x%x):\r\n", pool, boxInfo->uwBlkSize, boxInfo->uwBlkNum);
     PRINT_INFO("free node list:\r\n");
 
     for (node = boxInfo->stFreeList.pstNext, index = 0; node != NULL;
-         node = node->pstNext, ++index) {
-        PRINT_INFO("(%u,0x%x)\r\n", index, node);
+        node = node->pstNext, ++index) {
+        PRINT_INFO("(%u, %p)\r\n", index, node);
     }
 
     PRINT_INFO("all node list:\r\n");
     node = (LOS_MEMBOX_NODE *)(boxInfo + 1);
     for (index = 0; index < boxInfo->uwBlkNum; ++index, node = OS_MEMBOX_NEXT(node, boxInfo->uwBlkSize)) {
-        PRINT_INFO("(%u,0x%x,0x%x)\r\n", index, node, node->pstNext);
+        PRINT_INFO("(%u, %p, %p)\r\n", index, node, node->pstNext);
     }
     MEMBOX_UNLOCK(intSave);
 }
@@ -324,8 +315,3 @@ UINT32 OsMemboxExcInfoGet(UINT32 memNumMax, MemInfoCB *memExcInfo)
 }
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/kernel/src/mm/los_memory.c b/kernel/liteos_m/kernel/src/mm/los_memory.c
old mode 100755
new mode 100644
index 69ae3e2..847bb6b
--- a/kernel/liteos_m/kernel/src/mm/los_memory.c
+++ b/kernel/liteos_m/kernel/src/mm/los_memory.c
@@ -29,25 +29,18 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "los_memory.h"
 #include "securec.h"
+#include "los_arch.h"
 #include "los_config.h"
+#include "los_debug.h"
+#include "los_hook.h"
 #include "los_interrupt.h"
-#include "los_arch.h"
-#include "los_memory.h"
 #include "los_task.h"
-#include "los_debug.h"
-#ifdef LOSCFG_LIB_LIBC
-#endif
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 /* Used to cut non-essential functions. */
 #define OS_MEM_EXPAND_ENABLE    0
-#define OS_MEM_TRACE            0
 
 UINT8 *m_aucSysMem0 = NULL;
 
@@ -173,6 +166,7 @@ struct OsMemPoolHead {
 #define OS_MEM_POOL_UNLOCK_ENABLE   0x02
 
 #define MEM_LOCK(pool, state)       do {                    \
+	(state) = 0;                                            \
     if (!((pool)->info.attr & OS_MEM_POOL_UNLOCK_ENABLE)) { \
         (state) = LOS_IntLock();                            \
     }                                                       \
@@ -894,7 +888,13 @@ UINT32 LOS_MemInit(VOID *pool, UINT32 size)
         return OS_ERROR;
     }
 
-    size = OS_MEM_ALIGN(size, OS_MEM_ALIGN_SIZE);
+    if (((UINTPTR)pool & (OS_MEM_ALIGN_SIZE - 1)) || \
+        (size & (OS_MEM_ALIGN_SIZE - 1))) {
+        PRINT_ERR("LiteOS heap memory address or size configured not aligned:address:0x%x,size:0x%x, alignsize:%d\n", \
+                  (UINTPTR)pool, size, OS_MEM_ALIGN_SIZE);
+        return OS_ERROR;
+    }
+
     if (OsMemPoolInit(pool, size)) {
         return OS_ERROR;
     }
@@ -906,15 +906,11 @@ UINT32 LOS_MemInit(VOID *pool, UINT32 size)
     }
 #endif
 
-#if OS_MEM_TRACE
-    LOS_TraceReg(LOS_TRACE_MEM_TIME, OsMemTimeTrace, LOS_TRACE_MEM_TIME_NAME, LOS_TRACE_ENABLE);
-    LOS_TraceReg(LOS_TRACE_MEM_INFO, OsMemInfoTrace, LOS_TRACE_MEM_INFO_NAME, LOS_TRACE_ENABLE);
-#endif
+    OsHookCall(LOS_HOOK_TYPE_MEM_INIT, pool, size);
 
     return LOS_OK;
 }
 
-#if (LOSCFG_MEM_MUL_POOL == 1)
 UINT32 LOS_MemDeInit(VOID *pool)
 {
     if (pool == NULL) {
@@ -927,14 +923,12 @@ UINT32 LOS_MemDeInit(VOID *pool)
 
     OsMemPoolDeinit(pool);
 
-#if OS_MEM_TRACE
-    LOS_TraceUnreg(LOS_TRACE_MEM_TIME);
-    LOS_TraceUnreg(LOS_TRACE_MEM_INFO);
-#endif
+    OsHookCall(LOS_HOOK_TYPE_MEM_DEINIT, pool);
 
     return LOS_OK;
 }
 
+#if (LOSCFG_MEM_MUL_POOL == 1)
 UINT32 LOS_MemPoolList(VOID)
 {
     VOID *nextPool = g_poolHead;
@@ -960,10 +954,6 @@ STATIC INLINE VOID *OsMemAlloc(struct OsMemPoolHead *pool, UINT32 size, UINT32 i
 #endif
 
     UINT32 allocSize = OS_MEM_ALIGN(size + OS_MEM_NODE_HEAD_SIZE, OS_MEM_ALIGN_SIZE);
-    if (allocSize == 0) {
-        return NULL;
-    }
-
 #if OS_MEM_EXPAND_ENABLE
 retry:
 #endif
@@ -1003,10 +993,6 @@ retry:
 
 VOID *LOS_MemAlloc(VOID *pool, UINT32 size)
 {
-#if OS_MEM_TRACE
-    UINT64 start = HalClockGetCycles();
-#endif
-
     if ((pool == NULL) || (size == 0)) {
         return NULL;
     }
@@ -1028,28 +1014,13 @@ VOID *LOS_MemAlloc(VOID *pool, UINT32 size)
     } while (0);
     MEM_UNLOCK(poolHead, intSave);
 
-#if OS_MEM_TRACE
-    UINT64 end = HalClockGetCycles();
-    UINT32 timeUsed = MEM_TRACE_CYCLE_TO_US(end - start);
-    LOS_Trace(LOS_TRACE_MEM_TIME, (UINTPTR)pool & MEM_POOL_ADDR_MASK, MEM_TRACE_MALLOC, timeUsed);
-
-    LOS_MEM_POOL_STATUS poolStatus = {0};
-    (VOID)LOS_MemInfoGet(pool, &poolStatus);
-    UINT8 fragment = 100 - poolStatus.maxFreeNodeSize * 100 / poolStatus.totalFreeSize; /* 100: percent denominator. */
-    UINT8 usage = LOS_MemTotalUsedGet(pool) * 100 / LOS_MemPoolSizeGet(pool); /* 100: percent denominator. */
-    LOS_Trace(LOS_TRACE_MEM_INFO, (UINTPTR)pool & MEM_POOL_ADDR_MASK, fragment, usage, poolStatus.totalFreeSize,
-              poolStatus.maxFreeNodeSize, poolStatus.usedNodeNum, poolStatus.freeNodeNum);
-#endif
+    OsHookCall(LOS_HOOK_TYPE_MEM_ALLOC, pool, size);
 
     return ptr;
 }
 
 VOID *LOS_MemAllocAlign(VOID *pool, UINT32 size, UINT32 boundary)
 {
-#if OS_MEM_TRACE
-    UINT64 start = HalClockGetCycles();
-#endif
-
     UINT32 gapSize;
 
     if ((pool == NULL) || (size == 0) || (boundary == 0) || !OS_MEM_IS_POW_TWO(boundary) ||
@@ -1098,11 +1069,7 @@ VOID *LOS_MemAllocAlign(VOID *pool, UINT32 size, UINT32 boundary)
     } while (0);
     MEM_UNLOCK(poolHead, intSave);
 
-#if OS_MEM_TRACE
-    UINT64 end = HalClockGetCycles();
-    UINT32 timeUsed = MEM_TRACE_CYCLE_TO_US(end - start);
-    LOS_Trace(LOS_TRACE_MEM_TIME, (UINTPTR)pool & MEM_POOL_ADDR_MASK, MEM_TRACE_MEMALIGN, timeUsed);
-#endif
+    OsHookCall(LOS_HOOK_TYPE_MEM_ALLOCALIGN, pool, size, boundary);
 
     return ptr;
 }
@@ -1273,15 +1240,13 @@ STATIC INLINE VOID *OsGetRealPtr(const VOID *pool, VOID *ptr)
 
 UINT32 LOS_MemFree(VOID *pool, VOID *ptr)
 {
-#if OS_MEM_TRACE
-    UINT64 start = HalClockGetCycles();
-#endif
-
     if ((pool == NULL) || (ptr == NULL) || !OS_MEM_IS_ALIGNED(pool, sizeof(VOID *)) ||
         !OS_MEM_IS_ALIGNED(ptr, sizeof(VOID *))) {
         return LOS_NOK;
     }
 
+    OsHookCall(LOS_HOOK_TYPE_MEM_FREE, pool, ptr);
+
     UINT32 ret = LOS_NOK;
     struct OsMemPoolHead *poolHead = (struct OsMemPoolHead *)pool;
     struct OsMemNodeHead *node = NULL;
@@ -1298,12 +1263,6 @@ UINT32 LOS_MemFree(VOID *pool, VOID *ptr)
     } while (0);
     MEM_UNLOCK(poolHead, intSave);
 
-#if OS_MEM_TRACE
-    UINT64 end = HalClockGetCycles();
-    UINT32 timeUsed = MEM_TRACE_CYCLE_TO_US(end - start);
-    LOS_Trace(LOS_TRACE_MEM_TIME, (UINTPTR)pool & MEM_POOL_ADDR_MASK, MEM_TRACE_FREE, timeUsed);
-#endif
-
     return ret;
 }
 
@@ -1376,14 +1335,12 @@ STATIC INLINE VOID *OsMemRealloc(struct OsMemPoolHead *pool, const VOID *ptr,
 
 VOID *LOS_MemRealloc(VOID *pool, VOID *ptr, UINT32 size)
 {
-#if OS_MEM_TRACE
-    UINT64 start = HalClockGetCycles();
-#endif
-
     if ((pool == NULL) || OS_MEM_NODE_GET_USED_FLAG(size) || OS_MEM_NODE_GET_ALIGNED_FLAG(size)) {
         return NULL;
     }
 
+    OsHookCall(LOS_HOOK_TYPE_MEM_REALLOC, pool, ptr, size);
+
     if (ptr == NULL) {
         return LOS_MemAlloc(pool, size);
     }
@@ -1418,12 +1375,6 @@ VOID *LOS_MemRealloc(VOID *pool, VOID *ptr, UINT32 size)
     } while (0);
     MEM_UNLOCK(poolHead, intSave);
 
-#if OS_MEM_TRACE
-    UINT64 end = HalClockGetCycles();
-    UINT32 timeUsed = MEM_TRACE_CYCLE_TO_US(end - start);
-    LOS_Trace(LOS_TRACE_MEM_TIME, (UINTPTR)pool & MEM_POOL_ADDR_MASK, MEM_TRACE_REALLOC, timeUsed);
-#endif
-
     return newPtr;
 }
 
@@ -1546,15 +1497,15 @@ STATIC INLINE VOID OsMemMagicCheckPrint(struct OsMemNodeHead **tmpNode)
 
 STATIC UINT32 OsMemAddrValidCheckPrint(const VOID *pool, struct OsMemFreeNodeHead **tmpNode)
 {
-    if (!OsMemAddrValidCheck(pool, (*tmpNode)->prev)) {
+    if (((*tmpNode)->prev != NULL) && !OsMemAddrValidCheck(pool, (*tmpNode)->prev)) {
         PRINT_ERR("[%s], %d, memory check error!\n"
-                  " freeNode.prev: 0x%x is out of legal mem range\n",
+                  " freeNode.prev: %p is out of legal mem range\n",
                   __FUNCTION__, __LINE__, (*tmpNode)->prev);
         return LOS_NOK;
     }
-    if (!OsMemAddrValidCheck(pool, (*tmpNode)->next)) {
+    if (((*tmpNode)->next != NULL) && !OsMemAddrValidCheck(pool, (*tmpNode)->next)) {
         PRINT_ERR("[%s], %d, memory check error!\n"
-                  " freeNode.next: 0x%x is out of legal mem range\n",
+                  " freeNode.next: %p is out of legal mem range\n",
                   __FUNCTION__, __LINE__, (*tmpNode)->next);
         return LOS_NOK;
     }
@@ -1571,7 +1522,7 @@ STATIC UINT32 OsMemIntegrityCheckSub(struct OsMemNodeHead **tmpNode, const VOID
 
     if (!OsMemAddrValidCheck(pool, (*tmpNode)->ptr.prev)) {
         PRINT_ERR("[%s], %d, memory check error!\n"
-                  " node prev: 0x%x is out of legal mem range\n",
+                  " node prev: %p is out of legal mem range\n",
                   __FUNCTION__, __LINE__, (*tmpNode)->ptr.next);
         return LOS_NOK;
     }
@@ -1612,7 +1563,7 @@ STATIC VOID OsMemPoolHeadCheck(const struct OsMemPoolHead *pool)
     UINT32 flag = 0;
 
     if ((pool->info.pool != pool) || !OS_MEM_IS_ALIGNED(pool, sizeof(VOID *))) {
-        PRINT_ERR("wrong mem pool addr: 0x%x, func: %s, line: %d\n", pool, __FUNCTION__, __LINE__);
+        PRINT_ERR("wrong mem pool addr: %p, func: %s, line: %d\n", pool, __FUNCTION__, __LINE__);
         return;
     }
 
@@ -1620,14 +1571,14 @@ STATIC VOID OsMemPoolHeadCheck(const struct OsMemPoolHead *pool)
         for (tmpNode = pool->freeList[index]; tmpNode != NULL; tmpNode = tmpNode->next) {
             if (OsMemFreeListNodeCheck(pool, tmpNode)) {
                 flag = 1;
-                PRINT_ERR("FreeListIndex: %u, node: 0x%x, bNode: 0x%x, prev: 0x%x, next: 0x%x\n",
+                PRINT_ERR("FreeListIndex: %u, node: %p, bNode: %p, prev:%p, next: %p\n",
                           index, tmpNode, tmpNode->header.ptr.prev, tmpNode->prev, tmpNode->next);
             }
         }
     }
 
     if (flag) {
-        PRINTK("mem pool info: poolAddr: 0x%x, poolSize: 0x%x\n", pool, pool->info.totalSize);
+        PRINTK("mem pool info: poolAddr: %p, poolSize: 0x%x\n", pool, pool->info.totalSize);
 #if (LOSCFG_MEM_WATERLINE == 1)
         PRINTK("mem pool info: poolWaterLine: 0x%x, poolCurUsedSize: 0x%x\n", pool->info.waterLine,
                pool->info.curUsedSize);
@@ -1687,7 +1638,7 @@ STATIC VOID OsMemNodeInfo(const struct OsMemNodeHead *tmpNode,
 
     if (OS_MEM_NODE_GET_USED_FLAG(tmpNode->sizeAndFlag)) {
         usedNode = (struct OsMemUsedNodeHead *)tmpNode;
-        PRINTK("\n broken node head: 0x%x  "
+        PRINTK("\n broken node head: %p  "
 #if (LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK == 1)
                "0x%x  "
 #endif
@@ -1699,7 +1650,7 @@ STATIC VOID OsMemNodeInfo(const struct OsMemNodeHead *tmpNode,
                usedNode->header.sizeAndFlag);
     } else {
         freeNode = (struct OsMemFreeNodeHead *)tmpNode;
-        PRINTK("\n broken node head: 0x%x  0x%x  "
+        PRINTK("\n broken node head: %p  %p  %p  "
 #if (LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK == 1)
                "0x%x  "
 #endif
@@ -1713,7 +1664,7 @@ STATIC VOID OsMemNodeInfo(const struct OsMemNodeHead *tmpNode,
 
     if (OS_MEM_NODE_GET_USED_FLAG(preNode->sizeAndFlag)) {
         usedNode = (struct OsMemUsedNodeHead *)preNode;
-        PRINTK("prev node head: 0x%x  "
+        PRINTK("prev node head: %p  "
 #if (LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK == 1)
                "0x%x  "
 #endif
@@ -1725,7 +1676,7 @@ STATIC VOID OsMemNodeInfo(const struct OsMemNodeHead *tmpNode,
                usedNode->header.sizeAndFlag);
     } else {
         freeNode = (struct OsMemFreeNodeHead *)preNode;
-        PRINTK("prev node head: 0x%x  0x%x  "
+        PRINTK("prev node head: %p  %p  %p  "
 #if (LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK == 1)
                "0x%x  "
 #endif
@@ -1791,10 +1742,10 @@ STATIC VOID OsMemIntegrityCheckError(struct OsMemPoolHead *pool,
     MEM_UNLOCK(pool, intSave);
     PRINT_ERR("cur node: 0x%x, pre node: 0x%x, pre node was allocated by task: %d, %s\n",
               tmpNode, preNode, taskCB->taskID, taskCB->taskName);
-    LOS_Panic("Memory interity check error!\n");
+    LOS_Panic("Memory integrity check error!\n");
 #else
     MEM_UNLOCK(pool, intSave);
-    LOS_Panic("Memory interity check error, cur node: 0x%x, pre node: 0x%x\n", tmpNode, preNode);
+    LOS_Panic("Memory integrity check error, cur node: 0x%x, pre node: 0x%x\n", tmpNode, preNode);
 #endif
 }
 
@@ -1880,6 +1831,8 @@ UINT32 LOS_MemInfoGet(VOID *pool, LOS_MEM_POOL_STATUS *poolStatus)
         return LOS_NOK;
     }
 
+    (VOID)memset_s(poolStatus, sizeof(LOS_MEM_POOL_STATUS), 0, sizeof(LOS_MEM_POOL_STATUS));
+
     struct OsMemNodeHead *tmpNode = NULL;
     struct OsMemNodeHead *endNode = NULL;
     UINT32 intSave;
@@ -1932,7 +1885,7 @@ STATIC VOID OsMemInfoPrint(VOID *pool)
            "max free node size   used node num     free node num      UsageWaterLine\n");
     PRINTK("---------------    --------     -------       --------     "
            "--------------       -------------      ------------      ------------\n");
-    PRINTK("%-16#x   0x%-8x   0x%-8x    0x%-8x   0x%-16x   0x%-13x    0x%-13x    0x%-13x\n",
+    PRINTK("%-16p   0x%-8x   0x%-8x    0x%-8x   0x%-16x   0x%-13x    0x%-13x    0x%-13x\n",
            poolInfo->info.pool, LOS_MemPoolSizeGet(pool), status.totalUsedSize,
            status.totalFreeSize, status.maxFreeNodeSize, status.usedNodeNum,
            status.freeNodeNum, status.usageWaterLine);
@@ -1941,7 +1894,7 @@ STATIC VOID OsMemInfoPrint(VOID *pool)
            "max free node size   used node num     free node num\n");
     PRINTK("---------------    --------     -------       --------     "
            "--------------       -------------      ------------\n");
-    PRINTK("0x%-16x   0x%-8x   0x%-8x    0x%-8x   0x%-16x   0x%-13x    0x%-13x\n",
+    PRINTK("%-16p  0x%-8x   0x%-8x    0x%-8x   0x%-16x   0x%-13x    0x%-13x\n",
            (UINTPTR)poolInfo->info.pool, LOS_MemPoolSizeGet(pool), status.totalUsedSize,
            status.totalFreeSize, status.maxFreeNodeSize, status.usedNodeNum,
            status.freeNodeNum);
@@ -2006,22 +1959,27 @@ VOID LOS_MemUnlockEnable(VOID *pool)
 
 UINT32 OsMemSystemInit(VOID)
 {
-    UINT32 ret;
+	UINT32 ret;
 
 #if (LOSCFG_SYS_EXTERNAL_HEAP == 0)
-    m_aucSysMem0 = g_memStart;
+	m_aucSysMem0 = g_memStart;
+#elif LOS_BEKEN
+	extern UINT8 _empty_ram;
+	m_aucSysMem0 = (UINT8 *)&_empty_ram;
 #else
-    m_aucSysMem0 = LOSCFG_SYS_HEAP_ADDR;
+	m_aucSysMem0 = LOSCFG_SYS_HEAP_ADDR;
 #endif
 
-    if ((UINTPTR)m_aucSysMem0 & (OS_MEM_ALIGN_SIZE - 1)) {
-        m_aucSysMem0 = (UINT8 *)(((UINTPTR)m_aucSysMem0 + (OS_MEM_ALIGN_SIZE - 1)) &
-                       ~(OS_MEM_ALIGN_SIZE - 1));
-    }
+#if LOS_BEKEN
+	UINT32 HEAP_SIZE = (UINT32)LOSCFG_SYS_HEAP_ADDR_END - (UINT32)LOSCFG_SYS_HEAP_ADDR;
+	ret = LOS_MemInit(m_aucSysMem0, HEAP_SIZE);
+	PRINT_INFO("LiteOS heap memory address:0x%x,size:0x%x\n", m_aucSysMem0, HEAP_SIZE);
+#else
+	ret = LOS_MemInit(m_aucSysMem0, LOSCFG_SYS_HEAP_SIZE);
+	PRINT_INFO("LiteOS heap memory address:%p, size:0x%lx\n", m_aucSysMem0, LOSCFG_SYS_HEAP_SIZE);
+#endif
 
-    ret = LOS_MemInit(m_aucSysMem0, LOSCFG_SYS_HEAP_SIZE);
-    PRINT_INFO("LiteOS heap memory address:0x%x,size:0x%x\n", m_aucSysMem0, LOSCFG_SYS_HEAP_SIZE);
-    return ret;
+	return ret;
 }
 
 #if (LOSCFG_PLATFORM_EXC == 1)
@@ -2087,7 +2045,7 @@ UINT32 OsMemExcInfoGet(UINT32 memNumMax, MemInfoCB *memExcInfo)
         memPool = memPool->nextPool;
     }
 #else
-    OsMemExcInfoGetSub(m_aucSysMem0, buffer);
+    OsMemExcInfoGetSub((struct OsMemPoolHead *)m_aucSysMem0, (MemInfoCB *)buffer);
     count++;
 #endif
 
@@ -2095,9 +2053,4 @@ UINT32 OsMemExcInfoGet(UINT32 memNumMax, MemInfoCB *memExcInfo)
 }
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
diff --git a/kernel/liteos_m/port/mem_arch.c b/kernel/liteos_m/port/mem_arch.c
new file mode 100644
index 0000000..5cb3b04
--- /dev/null
+++ b/kernel/liteos_m/port/mem_arch.c
@@ -0,0 +1,59 @@
+#include "include.h"
+#include "arm_arch.h"
+#include <string.h>
+
+#include "sys_rtos.h"
+#include "uart_pub.h"
+#include "mem_pub.h"
+#include "rtos_pub.h"
+
+INT32 os_memcmp(const void *s1, const void *s2, UINT32 n)
+{
+    return memcmp(s1, s2, (unsigned int)n);
+}
+
+void *os_memmove(void *out, const void *in, UINT32 n)
+{
+    return memmove(out, in, n);
+}
+
+void *os_memcpy(void *out, const void *in, UINT32 n)
+{
+    return memcpy(out, in, n);
+}
+
+void *os_memset(void *b, int c, UINT32 len)
+{
+    return (void *)memset(b, c, (unsigned int)len);
+}
+
+int os_memcmp_const(const void *a, const void *b, size_t len)
+{
+    return memcmp(a, b, len);
+}
+
+void *os_realloc(void *ptr, size_t size)
+{
+	return beken_realloc(ptr, size);
+}
+
+void *os_malloc(size_t size)
+{
+    return (void *)beken_malloc(size);
+}
+
+void * os_zalloc(size_t size)
+{
+	void *n = (void *)os_malloc(size);
+
+	if (n)
+		os_memset(n, 0, size);
+	return n;
+}
+
+void os_free(void *ptr)
+{
+	beken_free(ptr);
+}
+// EOF
+
diff --git a/kernel/liteos_m/port/platform_stub.c b/kernel/liteos_m/port/platform_stub.c
new file mode 100644
index 0000000..bb38d37
--- /dev/null
+++ b/kernel/liteos_m/port/platform_stub.c
@@ -0,0 +1,84 @@
+/**
+ ******************************************************************************
+ * @file    platform_init.c
+ * @version V1.0.0
+ * @date    05-May-2014
+ * @brief   This file provide functions called by _BK_ to drive stm32f2xx
+ *          platform: - e.g. power save, reboot, platform initialize
+ ******************************************************************************
+ *  UNPUBLISHED PROPRIETARY SOURCE CODE
+ *  Copyright (c) 2016 BEKEN Inc.
+ *
+ *  The contents of this file may not be disclosed to third parties, copied or
+ *  duplicated in any form, in whole or in part, without the prior written
+ *  permission of BEKEN Corporation.
+ ******************************************************************************
+ */
+#include "include.h" 
+#include <sys/stat.h>
+#include <sys/times.h>
+#include <sys/unistd.h>
+
+#include "sys_rtos.h"
+#include "mem_pub.h"
+#include "uart_pub.h"
+#include "rtos_pub.h"
+
+/************** wrap C library functions **************/
+void * __wrap_malloc (size_t size)
+{
+	return os_malloc(size);
+}
+
+void * __wrap__malloc_r (void *p, size_t size)
+{
+	
+	return os_malloc(size);
+}
+
+void __wrap_free (void *pv)
+{
+	os_free(pv);
+}
+
+void * __wrap_calloc (size_t a, size_t b)
+{
+	void *pvReturn;
+
+    pvReturn = os_malloc( a*b );
+    if (pvReturn)
+    {
+        os_memset(pvReturn, 0, a*b);
+    }
+
+    return pvReturn;
+}
+
+void * __wrap_realloc (void* pv, size_t size)
+{
+	return os_realloc(pv, size);
+}
+
+void __wrap__free_r (void *p, void *x)
+{
+  __wrap_free(x);
+}
+
+void* __wrap__realloc_r (void *p, void* x, size_t sz)
+{
+  return __wrap_realloc (x, sz);
+}
+
+void * __wrap_zalloc(size_t size)
+{
+	return os_zalloc(size);
+}
+
+void __assert_func(const char *file, int line, const char *func, const char *failedexpr)
+{
+	os_printf("%s %d func %s expr %s\n", file, line, func, failedexpr);
+	ASSERT(0);
+}
+
+// eof
+
diff --git a/kernel/liteos_m/port/port.c b/kernel/liteos_m/port/port.c
new file mode 100644
index 0000000..39c638f
--- /dev/null
+++ b/kernel/liteos_m/port/port.c
@@ -0,0 +1,312 @@
+/*
+    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
+    All rights reserved
+*/
+
+/*-----------------------------------------------------------
+ * Implementation of functions defined in portable.h for the ST STR91x ARM9
+ * port.
+ *----------------------------------------------------------*/
+
+/* Standard includes. */
+#include <stdlib.h>
+#include <assert.h>
+#include "sys_rtos.h"
+#include "include.h"
+#include "ke_event.h"
+#include "fake_clock_pub.h"
+#include "osk_revision.h"
+#include "portmacro.h"
+
+#if (NX_POWERSAVE)
+#include "ps.h"
+#endif //(NX_POWERSAVE)
+
+/*-----------------------------------------------------------*/
+uint32_t platform_is_irq_enable( void )
+{
+    uint32_t interrupt;
+
+    __asm volatile(
+		"MRS %0,CPSR\n"
+		"AND %0,%0,#0xC0\n"
+		:"=r" (interrupt)
+		:
+		:"memory"
+	);
+
+    return (!(interrupt & ARM968_IRQ_ENABLE));
+}
+
+/*-----------------------------------------------------------*/
+uint32_t platform_is_fiq_enable( void )
+{
+    uint32_t interrupt;
+
+    __asm volatile(
+		"MRS %0,CPSR\n"
+		"AND %0,%0,#0xC0\n"
+		:"=r" (interrupt)
+		:
+		:"memory"
+	);
+
+    return (!(interrupt & ARM968_FIQ_ENABLE));
+}
+
+/*-----------------------------------------------------------*/
+void printf_lr_register(void)
+{
+    uint32_t value;
+
+    __asm volatile(
+		"MOV %0,lr\n"
+		:"=r" (value)
+		:
+		:"memory"
+	);
+
+	os_printf("lr:%x\r\n", value);
+}
+
+uint32_t platform_is_in_irq_context( void )
+{
+    uint32_t mode;
+
+    __asm volatile(
+		"MRS %0,CPSR\n"
+		"AND %0,%0,#0x1f\n"
+		:"=r" (mode)
+		:
+		:"memory"
+	);
+
+    return (ARM968_IRQ_MODE == mode);
+}
+
+/*-----------------------------------------------------------*/
+uint32_t platform_is_in_fiq_context( void )
+{
+    uint32_t mode;
+
+    __asm volatile(
+		"MRS %0,CPSR\n"
+		"AND %0,%0,#0x1f\n"
+		:"=r" (mode)
+		:
+		:"memory"
+	);
+
+    return (ARM968_FIQ_MODE == mode);
+}
+
+/*-----------------------------------------------------------*/
+uint32_t platform_entry_system_mode_zero_ptr(void)
+{
+	uint32_t system_md_value = 0xdf;
+	FUNCPTR boot = 0;
+
+    __asm volatile(
+		"MSR CPSR,%0\n"
+		:"=r" (system_md_value)
+		:
+		:"memory"
+	);
+
+	(*boot)();
+
+	return 0;
+}
+
+uint32_t platform_spsr_content( void )
+{
+    uint32_t mode;
+
+    __asm volatile(
+		"MRS %0,SPSR\n"
+		:"=r" (mode)
+		:
+		:"memory"
+	);
+
+    return mode;
+}
+
+/*-----------------------------------------------------------*/
+uint32_t platform_sp_content( void )
+{
+    uint32_t val;
+
+    __asm volatile(
+		"mov %0,SP\n"
+		:"=r" (val)
+		:
+		:"memory"
+	);
+
+    return val;
+}
+
+/*-----------------------------------------------------------*/
+uint32_t platform_cpsr_content( void )
+{
+    uint32_t mode;
+
+    __asm volatile(
+		"MRS %0,CPSR\n"
+		:"=r" (mode)
+		:
+		:"memory"
+	);
+
+    return mode;
+}
+
+uint32_t platform_interrupt_compare( void )
+{
+	uint32_t ret = 0;
+	uint32_t status = platform_cpsr_content();
+	uint32_t sta_irq = ((status & 0x80) >> 7);
+	uint32_t sta_fiq = ((status & 0x40) >> 6);
+
+	if(sta_fiq == sta_irq)
+	{
+		ret = 1;
+	}
+
+	return ret;
+}
+
+uint32_t platform_is_fiq_disable( void )
+{
+	uint32_t value = platform_cpsr_content();
+
+	return (value & 0x40);
+}
+
+uint32_t platform_is_irq_disable( void )
+{
+	uint32_t value = platform_cpsr_content();
+
+	return (value & 0x80);
+}
+
+uint32_t platform_is_in_interrupt_context( void )
+{
+    return ((platform_is_in_fiq_context())
+                || (platform_is_in_irq_context()));
+}
+
+void platform_enable_intc_at_restore_context(void)
+{
+	if(!platform_is_in_interrupt_context())
+		portENABLE_IRQ();
+
+	if(!platform_is_in_fiq_context())
+		portENABLE_FIQ();
+}
+
+void rtos_stack_overflow(char *taskname)
+{
+	os_printf("stack overflow: %s\r\n", taskname);
+	while(1);
+}
+
+#if CONTROL_IRQ_WITH_NORMAL_FUNCTION
+/*
+ * Enable Interrupts
+ */
+void port_enable_interrupts_flag(int val)
+{
+	unsigned long cpsr_val;
+	unsigned long mask;
+
+	mask = val & ARM968_IF_MASK;
+	cpsr_val = platform_cpsr_content();
+	cpsr_val &= (~ARM968_IF_MASK);
+	cpsr_val += mask;
+
+	__asm volatile(
+	"msr	cpsr_c, %0"
+	::"r" (cpsr_val)
+	:);
+}
+
+void portENABLE_IRQ(void)
+{
+	unsigned long temp;
+	__asm volatile(
+	"mrs	%0, cpsr		@ local_irq_enable\n"
+       "bic	%0, %0, #0x80\n"
+       "msr	cpsr_c, %0"
+	: "=r" (temp)
+	:
+	: "memory");
+}
+
+void portENABLE_FIQ(void)
+{
+	unsigned long temp;
+	__asm volatile(
+	"mrs	%0, cpsr		@ local_irq_enable\n"
+       "bic	%0, %0, #0x40\n"
+       "msr	cpsr_c, %0"
+	: "=r" (temp)
+	:
+	: "memory");
+}
+
+/*
+ * Disable Interrupts
+ */
+int portDISABLE_FIQ(void)
+{
+	unsigned long temp;
+	unsigned long mask;
+
+	__asm volatile(
+	"mrs	%1, cpsr		@ local_irq_disable\n"
+	"orr	%0, %1, #0x40\n"
+	"msr	cpsr_c, %0"
+	: "=r" (temp),"=r" (mask)
+	:
+	: "memory");
+
+	return (!!(mask & 0x40));
+}
+
+int port_disable_interrupts_flag(void)
+{
+	unsigned long temp;
+	unsigned long mask;
+
+	__asm volatile(
+	"mrs	%1, cpsr		@ local_irq_disable\n"
+	"orr	%0, %1, #0xC0\n"
+	"msr	cpsr_c, %0"
+	: "=r" (temp),"=r" (mask)
+	:
+	: "memory");
+
+	return (mask & 0xC0);
+}
+
+int portDISABLE_IRQ(void)
+{
+	unsigned long temp;
+	unsigned long mask;
+
+	__asm volatile(
+	"mrs	%1, cpsr		@ local_irq_disable\n"
+	"orr	%0, %1, #0x80\n"
+	"msr	cpsr_c, %0"
+	: "=r" (temp),"=r" (mask)
+	:
+	: "memory");
+
+	return (!!(mask & 0x80));
+}
+#endif
+
+//eof
+
diff --git a/kernel/liteos_m/port/portmacro.h b/kernel/liteos_m/port/portmacro.h
new file mode 100644
index 0000000..19f3900
--- /dev/null
+++ b/kernel/liteos_m/port/portmacro.h
@@ -0,0 +1,310 @@
+/*
+    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
+    All rights reserved
+
+    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
+
+    This file is part of the FreeRTOS distribution.
+
+    FreeRTOS is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License (version 2) as published by the
+    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
+
+    ***************************************************************************
+    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
+    >>!   distribute a combined work that includes FreeRTOS without being   !<<
+    >>!   obliged to provide the source code for proprietary components     !<<
+    >>!   outside of the FreeRTOS kernel.                                   !<<
+    ***************************************************************************
+
+    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
+    link: http://www.freertos.org/a00114.html
+
+    ***************************************************************************
+     *                                                                       *
+     *    FreeRTOS provides completely free yet professionally developed,    *
+     *    robust, strictly quality controlled, supported, and cross          *
+     *    platform software that is more than just the market leader, it     *
+     *    is the industry's de facto standard.                               *
+     *                                                                       *
+     *    Help yourself get started quickly while simultaneously helping     *
+     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
+     *    tutorial book, reference manual, or both:                          *
+     *    http://www.FreeRTOS.org/Documentation                              *
+     *                                                                       *
+    ***************************************************************************
+
+    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
+    the FAQ page "My application does not run, what could be wrong?".  Have you
+    defined configASSERT()?
+
+    http://www.FreeRTOS.org/support - In return for receiving this top quality
+    embedded software for free we request you assist our global community by
+    participating in the support forum.
+
+    http://www.FreeRTOS.org/training - Investing in training allows your team to
+    be as productive as possible as early as possible.  Now you can receive
+    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
+    Ltd, and the world's leading authority on the world's leading RTOS.
+
+    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
+    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
+    compatible FAT file system, and our tiny thread aware UDP/IP stack.
+
+    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
+    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
+
+    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
+    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
+    licenses offer ticketed support, indemnification and commercial middleware.
+
+    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
+    engineered and independently SIL3 certified version for use in safety and
+    mission critical applications that require provable dependability.
+
+    1 tab == 4 spaces!
+*/
+#ifndef __PORTMACRO_H__
+#define __PORTMACRO_H__
+
+/*-----------------------------------------------------------
+ * Port specific definitions.
+ *
+ * The settings in this file configure FreeRTOS correctly for the
+ * given hardware and compiler.
+ *
+ * These settings should not be altered.
+ *-----------------------------------------------------------
+ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <arch.h>
+
+/**
+ * for compiling beken378 library with thumb instruction set
+ * bellow four code blocks can't be implemented with macro or inline function
+ * portENABLE_IRQ/portENABLE_FIQ/portDISABLE_FIQ/portDISABLE_IRQ
+ * so declare these lables as extended function and implement them in port.c
+ *
+ * this feature is controled with CONTROL_IRQ_WITH_NORMAL_FUNCTION,
+ * and it is disabled as default
+ *
+ * steps to compile thumb instruction set library
+ * a. replace -marm with -mthumb
+ * b. enable macro CONTROL_IRQ_WITH_NORMAL_FUNCTION
+ */
+#define CONTROL_IRQ_WITH_NORMAL_FUNCTION    1
+
+/* Type definitions. */
+#define portCHAR			char
+#define portFLOAT			float
+#define portDOUBLE			double
+#define portLONG			long
+#define portSHORT			short
+#define portSTACK_TYPE		uint32_t
+#define portBASE_TYPE		long
+
+typedef portSTACK_TYPE StackType_t;
+typedef long BaseType_t;
+typedef unsigned long UBaseType_t;
+typedef uint32_t TickType_t;
+#define portMAX_DELAY ( TickType_t )        0xffffffffUL
+
+/* Constants required to setup the initial stack. */
+#define portINITIAL_SPSR 			    ( ( StackType_t ) 0x1f ) /* System mode, ARM mode, interrupts enabled. */
+#define portINSTRUCTION_SIZE	        ( ( StackType_t ) 4 )
+
+#define ARM968_SYS_MODE 	 	        0x1f
+#define ARM968_MODE_MASK 	 	        0x1f
+#define ARM968_IF_MASK       	        0xC0
+#define ARM968_IRQ_ENABLE    	        0x80
+#define ARM968_IF_MASK       	        0xC0
+#define ARM968_FIQ_ENABLE    	        0x40
+#define ARM968_IRQ_MODE      	        0x12
+#define ARM968_FIQ_MODE     	        0x11
+
+/* Constants required to handle critical sections. */
+#define portNO_CRITICAL_NESTING 		((uint32_t ) 0 )
+
+/*-----------------------------------------------------------*/
+enum arm_mode {
+	ARM_MODE_USR = 16,
+	ARM_MODE_FIQ = 17,
+	ARM_MODE_IRQ = 18,
+	ARM_MODE_SVC = 19,
+	ARM_MODE_MON = 22,
+	ARM_MODE_ABT = 23,
+	ARM_MODE_HYP = 26,
+	ARM_MODE_UND = 27,
+	ARM_MODE_1176_MON = 28,
+	ARM_MODE_SYS = 31,
+
+	ARM_MODE_THREAD = 0,
+	ARM_MODE_USER_THREAD = 1,
+	ARM_MODE_HANDLER = 2,
+
+	ARMV8_64_EL0T = 0x0,
+	ARMV8_64_EL1T = 0x4,
+	ARMV8_64_EL1H = 0x5,
+	ARMV8_64_EL2T = 0x8,
+	ARMV8_64_EL2H = 0x9,
+	ARMV8_64_EL3T = 0xC,
+	ARMV8_64_EL3H = 0xD,
+
+	ARM_MODE_ANY = -1
+};
+
+/*-----------------------------------------------------------*/
+/* Critical section handling. */
+void vPortEnterCritical( void );
+void vPortExitCritical( void );
+
+#define portENTER_CRITICAL()        do{     \
+                                                GLOBAL_INT_DECLARATION();\
+                                                GLOBAL_INT_DISABLE(); 
+#define portEXIT_CRITICAL()                 \
+                                                GLOBAL_INT_RESTORE();\
+                                      }while(0)
+
+/*
+ * Enable Interrupts
+ */	
+#ifdef CONTROL_IRQ_WITH_NORMAL_FUNCTION
+extern void portENABLE_IRQ(void);
+extern void portENABLE_FIQ(void);
+extern int portDISABLE_FIQ(void);
+extern int portDISABLE_IRQ(void);
+extern int port_disable_interrupts_flag(void);
+extern void port_enable_interrupts_flag(int val);
+#else
+#define portENABLE_IRQ()					\
+	({							            \
+		unsigned long temp;				    \
+		__asm volatile(					    \
+		"mrs	%0, cpsr		@ local_irq_enable\n"	\
+	       "bic	%0, %0, #0x80\n"					    \
+	       "msr	cpsr_c, %0"					            \
+		: "=r" (temp)						            \
+		:							                    \
+		: "memory");						            \
+	})
+	
+#define port_enable_interrupts_flag(val)					\
+	({							              \
+		unsigned long temp;				\
+		unsigned long mask;				\
+		mask = val & 0xC0;				\
+		__asm volatile(					\
+		"mrs	%0, cpsr		@ local_irq_enable\n"	\
+	       "bic	%0, %0, %1\n"				        	\
+	       "msr	cpsr_c, %0"					            \
+		: "=r" (temp)						            \
+		: "r" (mask)				                    \
+		: );						            \
+	})
+	
+#define portENABLE_FIQ()					\
+	({							              \
+		unsigned long temp;				\
+		__asm volatile(					\
+		"mrs	%0, cpsr		@ local_irq_enable\n"	\
+	       "bic	%0, %0, #0x40\n"					\
+	       "msr	cpsr_c, %0"					       \
+		: "=r" (temp)						       \
+		:							              \
+		: "memory");						       \
+	})
+	
+static inline  int portDISABLE_FIQ(void)
+{						                     
+	unsigned long temp;				       
+	unsigned long mask;		
+	
+	__asm volatile(					
+	"mrs	%1, cpsr		@ local_irq_disable\n"	
+	"orr	%0, %1, #0x40\n"					
+	"msr	cpsr_c, %0"					       
+	: "=r" (temp),"=r" (mask)						       
+	:							              
+	: "memory");		
+
+	return (!!(mask & 0x40));
+}
+
+static inline  int port_disable_interrupts_flag(void)
+{						                     
+	unsigned long temp;				       
+	unsigned long mask;		
+	
+	__asm volatile(					
+	"mrs	%1, cpsr		@ local_irq_disable\n"	
+	"orr	%0, %1, #0xC0\n"					
+	"msr	cpsr_c, %0"					       
+	: "=r" (temp),"=r" (mask)						       
+	:							              
+	: "memory");		
+
+	return (mask & 0xC0);
+}
+
+static inline  int portDISABLE_IRQ(void)
+{						                     
+	unsigned long temp;				       
+	unsigned long mask;		
+	
+	__asm volatile(					
+	"mrs	%1, cpsr		@ local_irq_disable\n"	
+	"orr	%0, %1, #0x80\n"					
+	"msr	cpsr_c, %0"					       
+	: "=r" (temp),"=r" (mask)						       
+	:							              
+	: "memory");		
+
+	return (!!(mask & 0x80));
+}
+#endif
+
+extern uint32_t platform_is_in_interrupt_context( void );
+extern uint32_t platform_is_in_fiq_context( void );
+extern uint32_t platform_is_in_irq_context( void );
+extern uint32_t platform_interrupt_compare( void );
+
+#define portENABLE_INTERRUPTS()			do{		\
+												if(platform_is_in_fiq_context())\
+													break;\
+												if(platform_is_in_irq_context()) {\
+													portENABLE_FIQ();\
+													break;\
+												}\
+												portENABLE_IRQ();\
+												portENABLE_FIQ();\
+										    }while(0)
+            
+										    
+/*
+ * Disable Interrupts
+ */
+#define portDISABLE_INTERRUPTS()		do{		\
+												if(platform_is_in_fiq_context())\
+													break;\
+												if(platform_is_in_irq_context()) {\
+													portDISABLE_FIQ();\
+													break;\
+												}\
+												portDISABLE_FIQ();\
+												portDISABLE_IRQ();\
+										    }while(0)
+
+uint32_t platform_is_irq_disable( void );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PORTMACRO_H_ */
+// eof
diff --git a/kernel/liteos_m/port/rtos_pub.c b/kernel/liteos_m/port/rtos_pub.c
new file mode 100644
index 0000000..454172b
--- /dev/null
+++ b/kernel/liteos_m/port/rtos_pub.c
@@ -0,0 +1,1176 @@
+#include "include.h"
+#include "rtos_pub.h"
+#include "los_config.h"
+#include "los_context.h"
+#include "los_task.h"
+#include "los_queue.h"
+#include "los_sem.h"
+#include "los_mux.h"
+#include "los_memory.h"
+#include "los_interrupt.h"
+#include "los_swtmr.h"
+#include "bk_los_timer.h"
+
+/* OS_TASK_PRIORITY_HIGHEST and OS_TASK_PRIORITY_LOWEST is reserved for internal TIMER and IDLE task use only. */
+#define ISVALID_LOS_PRIORITY(losPrio) ((losPrio) > OS_TASK_PRIORITY_HIGHEST && (losPrio) < OS_TASK_PRIORITY_LOWEST)
+/**
+* @brief Enumerates thread states.
+*
+*/
+typedef enum {
+  /** The thread is inactive. */
+  osThreadInactive        =  0,
+  /** The thread is ready. */
+  osThreadReady           =  1,
+  /** The thread is running. */
+  osThreadRunning         =  2,
+  /** The thread is blocked. */
+  osThreadBlocked         =  3,
+  /** The thread is terminated. */
+  osThreadTerminated      =  4,
+  /** The thread is abnormal. */
+  osThreadError           = -1,
+  /** Reserved */
+  osThreadReserved        = 0x7FFFFFFF
+} osThreadState_t;
+  
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+  /**
+  * @brief Enumerates timer permissions.
+  *
+  * @since 1.0
+  * @version 1.0
+  */
+  typedef enum	{
+	/** The timer is not allowed to wake up the RTOS. */
+	osTimerRousesIgnore 	  = 	0,
+	/** The timer is allowed to wake up the RTOS. */
+	osTimerRousesAllow		  = 	1
+  } osTimerRouses_t;
+  
+  /**
+  * @brief Enumerates timer alignment modes.
+  *
+  */
+  typedef enum	{
+	/** The timer ignores alignment. */
+	osTimerAlignIgnore		  = 	0,
+	/** The timer allows alignment. */
+	osTimerAlignAllow		  = 	1
+  } osTimerAlign_t;
+#endif //(LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+
+/******************************************************
+ *               Function Declarations
+ ******************************************************/
+uint32_t ms_to_tick_ratio = LOS_TICK_MS; // wangzhilei
+beken_time_t beken_time_offset = 0;
+
+/******************************************************
+ *               Function Definitions
+ ******************************************************/
+OSStatus rtos_create_thread( beken_thread_t *thread, uint8_t priority, const char *name, 
+						beken_thread_function_t function, uint32_t stack_size, beken_thread_arg_t arg )
+{
+    uint32_t uwTid;
+    UINT32 uwRet = LOS_OK;
+	OSStatus ret;
+    LosTaskCB *pstTaskCB = NULL;
+    TSK_INIT_PARAM_S stTskInitParam = {NULL};
+    UINT16 usPriority;
+
+	ret = kNoErr;
+    if (OS_INT_ACTIVE) {
+        ret = kGeneralErr;
+		goto tinit_exit;
+    }
+
+    usPriority = priority;
+    if (!ISVALID_LOS_PRIORITY(usPriority)) {
+        ret = kUnsupportedErr;/* unsupported priority */
+		goto tinit_exit;
+    }
+
+    stTskInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)function;
+    stTskInitParam.uwArg = (uint32_t)arg;
+    stTskInitParam.uwStackSize = stack_size;
+    stTskInitParam.pcName = (CHAR *)name;
+    stTskInitParam.usTaskPrio = usPriority;
+
+    uwRet = LOS_TaskCreate((UINT32 *)&uwTid, &stTskInitParam);
+	bk_printf("[wzl_debug]LOS_TaskCreate:%s:%d\r\n", name, uwRet);
+	if(LOS_OK != uwRet)
+	{
+		ret = kGeneralErr;
+		goto tinit_exit;
+	}
+    pstTaskCB = OS_TCB_FROM_TID(uwTid);
+
+	if(thread)
+	{
+		*thread = (beken_thread_t *)pstTaskCB;
+	}
+
+tinit_exit:
+	ASSERT(LOS_OK == uwRet);
+	return ret;
+}
+
+OSStatus rtos_delete_thread(beken_thread_t *thread)
+{
+    UINT32 uwRet;
+	uint32_t selfTid;
+    LosTaskCB *pstTaskCB = NULL;
+
+    if (OS_INT_ACTIVE) {
+        return kUnknownErr;
+    }
+
+    if (thread && (*thread == NULL)) {
+        return kParamErr;
+    }
+
+	if(NULL == thread)
+	{
+	    selfTid = LOS_CurTaskIDGet();
+	    pstTaskCB = OS_TCB_FROM_TID(selfTid);
+	}
+	else
+	{
+	    pstTaskCB = (LosTaskCB *)*thread;
+	}
+
+    uwRet = LOS_TaskDelete(pstTaskCB->taskID);
+
+    switch (uwRet) {
+        case LOS_ERRNO_TSK_OPERATE_IDLE:
+        case LOS_ERRNO_TSK_SUSPEND_SWTMR_NOT_ALLOWED:
+        case LOS_ERRNO_TSK_ID_INVALID:
+            return kParamErr;
+
+        case LOS_ERRNO_TSK_NOT_CREATED:
+            return kNoResourcesErr;
+
+        default:
+            return kNoErr;
+    }
+}
+
+uint32_t _thread_get_status(beken_thread_t *thread)
+{
+    UINT16 taskStatus;
+    osThreadState_t stState;
+    LosTaskCB *pstTaskCB = NULL;
+
+	ASSERT(thread);
+    if (OS_INT_ACTIVE || *thread == NULL) {
+        return osThreadError;
+    }
+
+    pstTaskCB = (LosTaskCB *)*thread;
+    taskStatus = pstTaskCB->taskStatus;
+
+    if (taskStatus & OS_TASK_STATUS_RUNNING) {
+        stState = osThreadRunning;
+    } else if (taskStatus & OS_TASK_STATUS_READY) {
+        stState = osThreadReady;
+    } else if (taskStatus &
+        (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND | OS_TASK_STATUS_SUSPEND)) {
+        stState = osThreadBlocked;
+    } else if (taskStatus & OS_TASK_STATUS_UNUSED) {
+        stState = osThreadInactive;
+    } else {
+        stState = osThreadError;
+    }
+
+    return stState;
+}
+
+OSStatus rtos_thread_join(beken_thread_t *thread)
+{
+	ASSERT(thread);
+    while ( _thread_get_status( *thread ) != osThreadInactive )
+    {
+        rtos_delay_milliseconds(10);
+    }
+    
+    return kNoErr;
+}
+
+BOOL rtos_is_current_thread( beken_thread_t *thread )
+{
+    uint32_t selfTid = LOS_CurTaskIDGet();
+    LosTaskCB *tcb = OS_TCB_FROM_TID(selfTid);
+	
+    if ( tcb == (LosTaskCB *)*thread )
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
+beken_thread_t *rtos_get_current_thread(void)
+{
+    uint32_t selfTid = LOS_CurTaskIDGet();
+    LosTaskCB *tcb = OS_TCB_FROM_TID(selfTid);
+	
+    return (beken_thread_t *)tcb;
+}
+
+/* Re-write vTaskList to add a buffer size parameter */
+OSStatus rtos_print_threads_status( char* pcWriteBuffer, int xWriteBufferLen )
+{
+    return kNoErr;
+}
+
+OSStatus rtos_check_stack(void)
+{
+    //  TODO: Add stack checking here.
+    return kNoErr;
+}
+
+OSStatus rtos_thread_force_awake( beken_thread_t *thread )
+{
+    return kNoErr;
+}
+
+void rtos_thread_sleep(uint32_t seconds)
+{
+    UINT32 uwRet = LOS_OK;
+	
+	uwRet = LOS_TaskDelay(seconds * LOS_TICKS_PER_SECOND);
+	(void)uwRet;
+}
+
+void rtos_suspend_thread(beken_thread_t *thread)
+{
+    UINT32 uwRet;
+    LosTaskCB *pstTaskCB = NULL;
+	beken_thread_t bk_thread;
+
+    if (OS_INT_ACTIVE) {
+        return;
+    }
+
+	bk_thread = *thread;
+    if (bk_thread == NULL) {
+        bk_thread = rtos_get_current_thread();
+    }
+
+    pstTaskCB = (LosTaskCB *)bk_thread;
+    uwRet = LOS_TaskSuspend(pstTaskCB->taskID);
+    switch (uwRet) {
+        case LOS_ERRNO_TSK_OPERATE_IDLE:
+        case LOS_ERRNO_TSK_SUSPEND_SWTMR_NOT_ALLOWED:
+        case LOS_ERRNO_TSK_ID_INVALID:
+            return;
+
+        case LOS_ERRNO_TSK_NOT_CREATED:
+        case LOS_ERRNO_TSK_ALREADY_SUSPENDED:
+        case LOS_ERRNO_TSK_SUSPEND_LOCKED:
+            return;
+
+        default:
+            return;
+    }
+}
+
+void rtos_resume_thread(beken_thread_t *thread)
+{
+    UINT32 uwRet;
+    LosTaskCB *pstTaskCB = NULL;
+	beken_thread_t bk_thread;
+
+    if (OS_INT_ACTIVE) {
+        return;
+    }
+
+	bk_thread = *thread;
+    if (bk_thread == NULL) {
+        bk_thread = rtos_get_current_thread();
+    }
+
+
+    pstTaskCB = (LosTaskCB *)bk_thread;
+    uwRet = LOS_TaskResume(pstTaskCB->taskID);
+
+    switch (uwRet) {
+        case LOS_ERRNO_TSK_ID_INVALID:
+            return;
+
+        case LOS_ERRNO_TSK_NOT_CREATED:
+        case LOS_ERRNO_TSK_NOT_SUSPENDED:
+            return;
+
+        default:
+            return;
+    }
+}
+
+uint32_t rtos_get_tick_count(void)
+{
+	return (uint32_t)LOS_TickCountGet();
+}
+
+uint32_t beken_tick_ms(void)
+{
+	return ms_to_tick_ratio;
+}
+
+OSStatus beken_time_get_time(beken_time_t* time_ptr)
+{
+    *time_ptr = (beken_time_t) ( LOS_TickCountGet() * ms_to_tick_ratio ) + beken_time_offset;
+    return kNoErr;
+}
+
+OSStatus beken_time_set_time(beken_time_t* time_ptr)
+{
+    beken_time_offset = *time_ptr - (beken_time_t) ( LOS_TickCountGet() * ms_to_tick_ratio );
+    return kNoErr;
+}
+
+OSStatus rtos_init_semaphore(beken_semaphore_t *semaphore, int max_count )
+{
+    return rtos_init_semaphore_adv(semaphore, max_count, 0);
+}
+
+OSStatus rtos_init_semaphore_adv(beken_semaphore_t *semaphore, int max_count, int init_count)
+{
+    UINT32 uwRet;
+    UINT32 uwSemId;
+
+    if (OS_INT_ACTIVE) {
+        *semaphore = (beken_semaphore_t)NULL;
+		goto init_aexit;
+    }
+
+    if (1 == max_count) {
+        uwRet = LOS_BinarySemCreate((UINT16)init_count, &uwSemId);
+    } else {
+        uwRet = LOS_SemCreate((UINT16)init_count, &uwSemId);
+    }
+	ASSERT(LOS_OK == uwRet);
+
+    if (uwRet == LOS_OK) {
+        *semaphore = (beken_semaphore_t)(GET_SEM(uwSemId));
+    } else {
+        *semaphore = (beken_semaphore_t)NULL;
+    }
+
+init_aexit:
+    return ( *semaphore != NULL ) ? kNoErr : kGeneralErr;
+}
+
+OSStatus rtos_get_semaphore(beken_semaphore_t *semaphore, uint32_t timeout_ms )
+{
+    UINT32 uwRet;
+    uint32_t timeout;
+
+	ASSERT(semaphore);
+    if(timeout_ms == BEKEN_WAIT_FOREVER)
+        timeout = LOS_WAIT_FOREVER;
+    else
+        timeout = timeout_ms / ms_to_tick_ratio;     
+
+    if (*semaphore == NULL) {
+        return kParamErr;
+    }
+
+    if (OS_INT_ACTIVE && (timeout != LOS_NO_WAIT)) {
+        return kUnknownErr;
+    }
+
+    uwRet = LOS_SemPend(((LosSemCB *)*semaphore)->semID, timeout);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_SEM_TIMEOUT) {
+        return kTimeoutErr;
+    } else if (uwRet == LOS_ERRNO_SEM_INVALID) {
+        return kParamErr;
+    } else if (uwRet == LOS_ERRNO_SEM_PEND_INTERR) {
+        return kInProgressErr;
+    } else {
+        return kGeneralErr;
+    } 
+}
+
+int rtos_get_sema_count(beken_semaphore_t *semaphore )
+{
+    uint32_t uwIntSave;
+    uint32_t uwCount;
+
+    if (OS_INT_ACTIVE) {
+        return 0;
+    }
+
+	ASSERT(semaphore);
+
+    if (*semaphore == NULL) {
+        return 0;
+    }
+
+    uwIntSave = LOS_IntLock();
+    uwCount = ((LosSemCB *)*semaphore)->semCount;
+    LOS_IntRestore(uwIntSave);
+
+    return uwCount;
+}
+
+int rtos_set_semaphore(beken_semaphore_t *semaphore )
+{
+    UINT32 uwRet;
+
+	ASSERT(semaphore);
+
+    if (*semaphore == NULL) {
+        return kParamErr;
+    }
+
+    uwRet = LOS_SemPost(((LosSemCB *)*semaphore)->semID);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_SEM_INVALID) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_deinit_semaphore(beken_semaphore_t *semaphore )
+{
+    UINT32 uwRet;
+
+    if (OS_INT_ACTIVE) {
+        return kGeneralErr;
+    }
+
+	ASSERT(semaphore);
+
+    if (*semaphore == NULL) {
+        return kParamErr;
+    }
+
+    uwRet = LOS_SemDelete(((LosSemCB *)*semaphore)->semID);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_SEM_INVALID) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+void rtos_enter_critical(void)
+{
+}
+
+void rtos_exit_critical(void)
+{
+}
+
+OSStatus rtos_init_mutex(beken_mutex_t *mutex)
+{
+    UINT32 uwRet;
+    UINT32 uwMuxId;
+
+    if (OS_INT_ACTIVE) {
+        *mutex = NULL;
+		goto init_exit;
+    }
+
+	ASSERT(mutex);
+
+    uwRet = LOS_MuxCreate(&uwMuxId);
+    if (uwRet == LOS_OK) {
+        *mutex = (beken_mutex_t)(GET_MUX(uwMuxId));
+    } else {
+        *mutex = (beken_mutex_t)NULL;
+    }
+	ASSERT(LOS_OK == uwRet);
+
+init_exit:
+    if ( *mutex == NULL )
+    {
+        return kGeneralErr;
+    }
+
+    return kNoErr;
+}
+
+OSStatus rtos_trylock_mutex(beken_mutex_t *mutex)
+{
+    UINT32 uwRet;
+
+    if (*mutex == NULL) {
+        return kParamErr;
+    }
+
+	ASSERT(mutex);
+
+    uwRet = LOS_MuxPend(((LosMuxCB *)*mutex)->muxID, 0);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_MUX_TIMEOUT) {
+        return kTimeoutErr;
+    } else if (uwRet == LOS_ERRNO_MUX_INVALID) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_lock_mutex(beken_mutex_t *mutex)
+{
+    UINT32 uwRet;
+
+	ASSERT(mutex);
+
+    if (*mutex == NULL) {
+        return kParamErr;
+    }
+
+    uwRet = LOS_MuxPend(((LosMuxCB *)*mutex)->muxID, LOS_WAIT_FOREVER);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_MUX_TIMEOUT) {
+        return kTimeoutErr;
+    } else if (uwRet == LOS_ERRNO_MUX_INVALID) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_unlock_mutex(beken_mutex_t *mutex)
+{
+    UINT32 uwRet;
+
+    if (*mutex == NULL) {
+        return kParamErr;
+    }
+
+	ASSERT(mutex);
+
+    uwRet = LOS_MuxPost(((LosMuxCB *)*mutex)->muxID);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_deinit_mutex(beken_mutex_t *mutex)
+{
+    UINT32 uwRet;
+
+    if (OS_INT_ACTIVE) {
+        return kStateErr;
+    }
+
+	ASSERT(mutex);
+
+    if (*mutex == NULL) {
+        return kParamErr;
+    }
+
+    uwRet = LOS_MuxDelete(((LosMuxCB *)*mutex)->muxID);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_MUX_INVALID) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_init_queue( beken_queue_t *queue, const char* name, uint32_t msg_size, uint32_t msg_count )
+{
+    UINT32 uwRet;
+    UINT32 uwQueueID;
+	OSStatus ret = kNoErr;
+
+	ASSERT(queue);
+
+    if (0 == msg_count || 0 == msg_size || OS_INT_ACTIVE) {
+        *queue = (beken_queue_t)NULL;
+		ret = kParamErr;
+		goto qinit_exit;
+    }
+
+    uwRet = LOS_QueueCreate((char *)name, (UINT16)msg_count, &uwQueueID, 0, (UINT16)msg_size);
+	bk_printf("[wzl_debug]LOS_QueueCreate:%s:%d\r\n", name, uwRet);
+    if (uwRet == LOS_OK) {
+        *queue = (beken_queue_t)(GET_QUEUE_HANDLE(uwQueueID));
+    } else {
+        *queue = (beken_queue_t)NULL;
+		ret = kNoResourcesErr;
+    }
+	ASSERT(LOS_OK == uwRet);
+
+qinit_exit:
+    return ret;
+}
+
+OSStatus rtos_push_to_queue( beken_queue_t *queue, void* msg_ptr, uint32_t timeout_ms )
+{
+    UINT32 uwRet;
+    uint32_t timeout;
+    uint32_t uwBufferSize;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+	ASSERT(queue);
+
+    if(timeout_ms == BEKEN_WAIT_FOREVER)
+        timeout = LOS_WAIT_FOREVER;
+    else
+        timeout = timeout_ms / ms_to_tick_ratio;    
+
+    if (pstQueue == NULL || msg_ptr == NULL || ((OS_INT_ACTIVE) && (0 != timeout))) {
+        return kParamErr;
+    }
+    if (pstQueue->queueSize < sizeof(uint32_t)) {
+        return kParamErr;
+    }
+    uwBufferSize = (uint32_t)(pstQueue->queueSize - sizeof(uint32_t));
+    uwRet = LOS_QueueWriteCopy((uint32_t)pstQueue->queueID, (void *)msg_ptr, uwBufferSize, timeout);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_INVALID || uwRet == LOS_ERRNO_QUEUE_NOT_CREATE) {
+        return kParamErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_TIMEOUT) {
+        return kTimeoutErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_push_to_queue_front( beken_queue_t *queue, void *msg_ptr, uint32_t timeout_ms )
+{
+    UINT32 uwRet;
+    uint32_t timeout;
+    uint32_t uwBufferSize;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+	ASSERT(queue);
+
+    if(timeout_ms == BEKEN_WAIT_FOREVER)
+        timeout = LOS_WAIT_FOREVER;
+    else
+        timeout = timeout_ms / ms_to_tick_ratio;    
+
+    if (pstQueue == NULL || msg_ptr == NULL || ((OS_INT_ACTIVE) && (0 != timeout))) {
+        return kParamErr;
+    }
+    if (pstQueue->queueSize < sizeof(uint32_t)) {
+        return kParamErr;
+    }
+    uwBufferSize = (uint32_t)(pstQueue->queueSize - sizeof(uint32_t));
+    uwRet = LOS_QueueWriteHead((uint32_t)pstQueue->queueID, (void *)msg_ptr, uwBufferSize, timeout);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_INVALID || uwRet == LOS_ERRNO_QUEUE_NOT_CREATE) {
+        return kParamErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_TIMEOUT) {
+        return kTimeoutErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_pop_from_queue( beken_queue_t *queue, void *msg_ptr, uint32_t timeout_ms )
+{
+    UINT32 uwRet;
+    uint32_t timeout;
+    UINT32 uwBufferSize;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+	ASSERT(queue);
+
+    if(timeout_ms == BEKEN_WAIT_FOREVER)
+        timeout = LOS_WAIT_FOREVER;
+    else
+        timeout = timeout_ms / ms_to_tick_ratio;    
+
+    if (pstQueue == NULL || msg_ptr == NULL || ((OS_INT_ACTIVE) && (0 != timeout))) {
+        return kParamErr;
+    }
+
+    uwBufferSize = (uint32_t)(pstQueue->queueSize - sizeof(uint32_t));
+    uwRet = LOS_QueueReadCopy((uint32_t)pstQueue->queueID, msg_ptr, &uwBufferSize, timeout);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_INVALID || uwRet == LOS_ERRNO_QUEUE_NOT_CREATE) {
+        return kParamErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_TIMEOUT) {
+        return kTimeoutErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_deinit_queue(beken_queue_t *queue)
+{
+    UINT32 uwRet;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+	ASSERT(queue);
+
+    if (pstQueue == NULL) {
+        return kParamErr;
+    }
+
+    if (OS_INT_ACTIVE) {
+        return kGeneralErr;
+    }
+
+    uwRet = LOS_QueueDelete((uint32_t)pstQueue->queueID);
+    if (uwRet == LOS_OK) {
+        return kNoErr;
+    } else if (uwRet == LOS_ERRNO_QUEUE_NOT_FOUND || uwRet == LOS_ERRNO_QUEUE_NOT_CREATE) {
+        return kParamErr;
+    } else {
+        return kUnknownErr;
+    }
+}
+
+uint32_t _queue_get_capacity(beken_queue_t *queue)
+{
+    uint32_t capacity;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+    if (pstQueue == NULL) {
+        capacity = 0U;
+    } else {
+        capacity = pstQueue->queueLen;
+    }
+
+    return (capacity);
+}
+
+uint32_t _queue_get_count(beken_queue_t *queue)
+{
+    uint32_t count;
+    UINTPTR uwIntSave;
+    LosQueueCB *pstQueue = (LosQueueCB *)*queue;
+
+	ASSERT(queue);
+
+    if (pstQueue == NULL) {
+        count = 0U;
+    } else {
+        uwIntSave = LOS_IntLock();
+        count = (uint32_t)(pstQueue->readWriteableCnt[OS_QUEUE_READ]);
+        LOS_IntRestore(uwIntSave);
+    }
+    return count;
+}
+
+BOOL rtos_is_queue_full(beken_queue_t *queue)
+{
+	ASSERT(queue);
+    return ( _queue_get_capacity(queue) == _queue_get_count(queue) ) ? true : false;
+}
+
+BOOL rtos_is_queue_empty(beken_queue_t *queue)
+{
+	ASSERT(queue);
+    return ( 0 == _queue_get_count(queue) ) ? true : false;
+}
+
+static void timer_callback2( void *handle )
+{
+    beken2_timer_t *timer = (beken2_timer_t *) handle;
+
+	if(BEKEN_MAGIC_WORD != timer->beken_magic)
+	{
+		return;
+	}
+    if ( timer->function )
+    {
+        timer->function( timer->left_arg, timer->right_arg );
+    }
+}
+
+static void timer_callback1( void *handle )
+{
+    beken_timer_t *timer = (beken_timer_t*) handle;
+
+    if ( timer->function )
+    {
+        timer->function( timer->arg);
+    }
+}
+
+OSStatus rtos_init_oneshot_timer( beken2_timer_t *timer, 
+									uint32_t time_ms, 
+									timer_2handler_t func,
+									void* larg, 
+									void* rarg )
+{
+    SWTMR_CTRL_S *pstSwtmr;
+	OSStatus ret = kNoErr;
+    UINT32 usSwTmrID;
+    UINT8 mode;
+
+	timer->handle = NULL;
+    if (NULL == func) {
+		ret = kParamErr;
+		goto tinit_exit;
+    }
+
+    mode = LOS_SWTMR_MODE_NO_SELFDELETE;
+	timer->beken_magic = BEKEN_MAGIC_WORD;
+	timer->function = func;
+	timer->left_arg = larg;
+	timer->right_arg = rarg;
+	
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)timer_callback2, &usSwTmrID, (uint32_t)(UINTPTR)timer,
+        osTimerRousesAllow, osTimerAlignIgnore)) {
+        ret = kGeneralErr;
+		goto tinit_exit;
+    }
+#else
+    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)func, &usSwTmrID, (uint32_t)(UINTPTR)larg)) {
+        ret = kGeneralErr;
+		goto tinit_exit;
+    }
+#endif
+
+	pstSwtmr = (SWTMR_CTRL_S *)OS_SWT_FROM_SID(usSwTmrID);
+    timer->handle = (void *)pstSwtmr;
+
+	if(pstSwtmr){
+		pstSwtmr->uwInterval = time_ms / ms_to_tick_ratio;
+	}
+
+tinit_exit:
+    return ret;
+}
+
+OSStatus rtos_start_oneshot_timer(beken2_timer_t *timer)
+{
+	return rtos_start_timer((beken_timer_t *)timer);
+}
+
+OSStatus rtos_deinit_oneshot_timer(beken2_timer_t *timer)
+{
+	timer->beken_magic = 0;
+	timer->left_arg = 0;
+	timer->right_arg = 0;
+	timer->function = NULL;
+	
+	return rtos_deinit_timer((beken_timer_t *)timer);
+}
+
+OSStatus rtos_stop_oneshot_timer(beken2_timer_t *timer)
+{
+    return rtos_stop_timer((beken_timer_t *)timer);
+}
+
+BOOL rtos_is_oneshot_timer_init(beken2_timer_t *timer)
+{
+    return (NULL != timer->handle) ? true : false;
+}
+
+BOOL rtos_is_oneshot_timer_running(beken2_timer_t *timer)
+{
+    return rtos_is_timer_running((beken_timer_t *)timer);
+}
+
+OSStatus rtos_oneshot_reload_timer(beken2_timer_t *timer)
+{
+    return rtos_start_timer((beken_timer_t *)timer);
+}
+
+OSStatus rtos_oneshot_reload_timer_ex(beken2_timer_t *timer,
+										uint32_t time_ms,
+										timer_2handler_t function,
+										void *larg,
+										void *rarg)
+{
+	return kUnsupportedErr;
+}
+
+OSStatus rtos_init_timer(beken_timer_t *timer, 
+									uint32_t time_ms, 
+									timer_handler_t func, 
+									void* argument )
+{
+    SWTMR_CTRL_S *pstSwtmr;
+	OSStatus ret = kNoErr;
+    UINT32 usSwTmrID;
+    UINT8 mode;
+
+	timer->handle = NULL;
+	
+    if (NULL == func) {
+		ret = kParamErr;
+		goto tinit_exit;
+    }
+
+    mode = LOS_SWTMR_MODE_PERIOD;
+	timer->function = func;
+	timer->arg = argument;
+	
+#if (LOSCFG_BASE_CORE_SWTMR_ALIGN == 1)
+    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)timer_callback1, &usSwTmrID, (uint32_t)(UINTPTR)timer,
+        osTimerRousesAllow, osTimerAlignIgnore)) {
+		ret = kGeneralErr;
+		goto tinit_exit;
+    }
+#else
+    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)timer_callback1, &usSwTmrID, (uint32_t)(UINTPTR)timer)) {
+		ret = kGeneralErr;
+		goto tinit_exit;
+    }
+#endif
+
+    timer->handle = (void *)OS_SWT_FROM_SID(usSwTmrID);
+	pstSwtmr = (SWTMR_CTRL_S *)timer->handle;
+
+
+	if(pstSwtmr){
+		pstSwtmr->uwInterval = time_ms / ms_to_tick_ratio;
+	}
+
+tinit_exit:
+    return ret;
+}
+
+OSStatus rtos_start_timer(beken_timer_t *timer)
+{
+    UINT32 uwRet;
+    SWTMR_CTRL_S *pstSwtmr;
+
+    if (NULL == timer) {
+        return kParamErr;
+    }
+
+    UINTPTR intSave = LOS_IntLock();
+    pstSwtmr = (SWTMR_CTRL_S *)timer;
+    uwRet = LOS_SwtmrStart(pstSwtmr->usTimerID);
+    LOS_IntRestore(intSave);
+    if (LOS_OK == uwRet) {
+        return kNoErr;
+    } else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet) {
+        return kParamErr;
+    } else {
+        return kTimeoutErr;
+    }
+}
+
+OSStatus rtos_stop_timer(beken_timer_t *timer)
+{
+    UINT32 uwRet;
+    SWTMR_CTRL_S *pstSwtmr;
+
+    if (NULL == timer) {
+        return kParamErr;
+    }
+
+	pstSwtmr = (SWTMR_CTRL_S *)timer->handle;
+    uwRet = LOS_SwtmrStop(pstSwtmr->usTimerID);
+    if (LOS_OK == uwRet) {
+        return kNoErr;
+    } else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_reload_timer(beken_timer_t *timer)
+{
+    return rtos_start_timer(timer);
+}
+
+OSStatus rtos_change_period(beken_timer_t *timer, uint32_t time_ms)
+{
+    UINT32 uwRet;
+	UINTPTR intSave;
+    SWTMR_CTRL_S *pstSwtmr;
+	
+    if (NULL == timer) {
+        return kParamErr;
+    }
+	rtos_stop_timer(timer);
+
+    intSave = LOS_IntLock();
+    pstSwtmr = (SWTMR_CTRL_S *)timer->handle;
+    pstSwtmr->uwInterval = time_ms / ms_to_tick_ratio;
+    uwRet = LOS_SwtmrStart(pstSwtmr->usTimerID);
+    LOS_IntRestore(intSave);
+    if (LOS_OK == uwRet) {
+        return kNoErr;
+    } else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+OSStatus rtos_deinit_timer(beken_timer_t *timer)
+{
+    UINT32 uwRet;
+    SWTMR_CTRL_S *pstSwtmr;
+
+	pstSwtmr = (SWTMR_CTRL_S *)timer->handle;
+    if (NULL == pstSwtmr) {
+        return kParamErr;
+    }
+
+    uwRet = LOS_SwtmrDelete(pstSwtmr->usTimerID);
+    if (LOS_OK == uwRet) {
+		timer->handle = NULL;
+		timer->arg = 0;
+		timer->function = NULL;
+        return kNoErr;
+    } else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet) {
+        return kParamErr;
+    } else {
+        return kGeneralErr;
+    }
+}
+
+uint32_t rtos_get_timer_expiry_time(beken_timer_t *timer)
+{
+	uint32_t val;
+    UINTPTR intSave;
+    SWTMR_CTRL_S *pstSwtmr;
+
+	intSave = LOS_IntLock();
+    pstSwtmr = (SWTMR_CTRL_S *)timer->handle;
+    val = pstSwtmr->uwInterval;
+    LOS_IntRestore(intSave);
+	
+    return val;
+}
+
+uint32_t rtos_get_next_expire_time(void)
+{
+    return kGeneralErr;
+}
+
+uint32_t rtos_get_current_timer_count(void)
+{
+    return kGeneralErr;
+}
+
+BOOL rtos_is_timer_init(beken_timer_t *timer)
+{
+    return (NULL != timer->handle) ? true : false;
+}
+
+BOOL rtos_is_timer_running(beken_timer_t *timer)
+{
+    if (NULL == timer->handle) {
+        return 0;
+    }
+
+    return (OS_SWTMR_STATUS_TICKING == ((SWTMR_CTRL_S *)timer->handle)->ucState);
+}
+
+OSStatus rtos_init_event_flags( beken_event_flags_t* event_flags )
+{
+    UNUSED_PARAMETER( event_flags );
+	
+    return kUnsupportedErr;
+}
+
+OSStatus rtos_wait_for_event_flags( beken_event_flags_t* event_flags, uint32_t flags_to_wait_for, uint32_t* flags_set, beken_bool_t clear_set_flags, beken_event_flags_wait_option_t wait_option, uint32_t timeout_ms )
+{
+    UNUSED_PARAMETER( event_flags );
+    UNUSED_PARAMETER( flags_to_wait_for );
+    UNUSED_PARAMETER( flags_set );
+    UNUSED_PARAMETER( clear_set_flags );
+    UNUSED_PARAMETER( wait_option );
+    UNUSED_PARAMETER( timeout_ms );
+
+    return kUnsupportedErr;
+}
+
+OSStatus rtos_set_event_flags( beken_event_flags_t* event_flags, uint32_t flags_to_set )
+{
+    UNUSED_PARAMETER( event_flags );
+    UNUSED_PARAMETER( flags_to_set );
+	
+    return kUnsupportedErr;
+}
+
+OSStatus rtos_deinit_event_flags( beken_event_flags_t* event_flags )
+{
+    UNUSED_PARAMETER( event_flags );
+	
+    return kUnsupportedErr;
+}
+
+/**
+ * Gets time in milliseconds since RTOS start
+ *
+ * @Note: since this is only 32 bits, it will roll over every 49 days, 17 hours.
+ *
+ * @returns Time in milliseconds since RTOS started.
+ */
+beken_time_t rtos_get_time(void)
+{
+    return (beken_time_t) ( LOS_TickCountGet() * ms_to_tick_ratio );
+}
+
+/**
+ * Delay for a number of milliseconds
+ *
+ * Processing of this function depends on the minimum sleep
+ * time resolution of the RTOS.
+ * The current thread sleeps for the longest period possible which
+ * is less than the delay required, then makes up the difference
+ * with a tight loop
+ *
+ * @return OSStatus : kNoErr if delay was successful
+ *
+ */
+OSStatus rtos_delay_milliseconds( uint32_t num_ms )
+{
+    uint32_t ticks;
+
+    ticks = num_ms / ms_to_tick_ratio;
+    if (ticks == 0)
+        ticks = 1;
+
+    LOS_TaskDelay( ticks );
+
+    return kNoErr;
+}
+
+/*-----------------------------------------------------------*/
+void *beken_malloc( size_t xWantedSize )
+{
+	return (void *)LOS_MemAlloc(m_aucSysMem0, xWantedSize);;
+}
+
+/*-----------------------------------------------------------*/
+void beken_free( void *pv )
+{
+	LOS_MemFree(m_aucSysMem0, pv);
+}
+
+/*-----------------------------------------------------------*/
+void *beken_realloc( void *pv, size_t xWantedSize )
+{
+	return LOS_MemRealloc(m_aucSysMem0, pv, xWantedSize);
+}
+
+void rtos_dump_all_thread(void)
+{
+	//To be completed
+}
+
+void rtos_dump_stack(beken_thread_t *task)
+{
+}
+
+// eof
+
diff --git a/kernel/liteos_m/port/str_arch.c b/kernel/liteos_m/port/str_arch.c
new file mode 100644
index 0000000..63b232c
--- /dev/null
+++ b/kernel/liteos_m/port/str_arch.c
@@ -0,0 +1,139 @@
+#include "include.h"
+#include "arm_arch.h"
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "str_pub.h"
+#include "mem_pub.h"
+
+char *os_strchr(const char *s, int c)
+{
+    return strchr(s, c);
+}
+
+UINT32 os_strlen(const char *str)
+{
+    return strlen(str);
+}
+
+INT32 os_strcmp(const char *s1, const char *s2)
+{
+    return strcmp(s1, s2);
+}
+
+UINT32 os_strtoul(const char *nptr, char **endptr, int base)
+{
+    return strtoul(nptr, endptr, base);
+}
+
+char *os_strcpy(char *out, const char *in)
+{
+    return strcpy(out, in);
+}
+
+char *os_strncpy(char *out, const char *in, const UINT32 n)
+{
+    return strncpy(out, in, (unsigned int)n);
+}
+
+size_t os_strlcpy(char *dest, const char *src, size_t siz)
+{
+    const char *s = src;
+    size_t left = siz;
+
+    if (left)
+    {
+        /* Copy string up to the maximum size of the dest buffer */
+        while (--left != 0)
+        {
+            if ((*dest++ = *s++) == '\0')
+                break;
+        }
+    }
+
+    if (left == 0)
+    {
+        /* Not enough room for the string; force NUL-termination */
+        if (siz != 0)
+            *dest = '\0';
+
+        while (*s++)
+            ; /* determine total src string length */
+    }
+
+    return s - src - 1;
+}
+
+INT32 os_strncmp(const char *s1, const char *s2, const UINT32 n)
+{
+    return strncmp(s1, s2, (unsigned int)n);
+}
+
+INT32 os_snprintf(char *buf, UINT32 size, const char *fmt, ...)
+{
+    va_list args;
+    INT32 rc;
+
+    va_start(args, fmt);
+    rc = vsnprintf(buf, size, fmt, args);
+    va_end(args);
+
+    /* if want to print more than the limitation */
+    if (rc > size)
+        rc = (INT32)size - rc;
+
+    return rc;
+}
+
+INT32 os_vsnprintf(char *buf, UINT32 size, const char *fmt, va_list ap)
+{
+    return vsnprintf(buf, size, fmt, ap);
+}
+
+char *os_strdup(const char *s)
+{
+    char *res;
+    size_t len;
+
+    if (s == NULL)
+        return NULL;
+
+    len = os_strlen(s);
+    res = os_malloc(len + 1);
+    if (res)
+        os_memcpy(res, s, len + 1);
+
+    return res;
+}
+
+
+int os_strcasecmp(const char *s1, const char *s2)
+{
+    /*
+     * Ignoring case is not required for main functionality, so just use
+     * the case sensitive version of the function.
+     */
+    return os_strcmp(s1, s2);
+}
+
+
+int os_strncasecmp(const char *s1, const char *s2, size_t n)
+{
+    /*
+     * Ignoring case is not required for main functionality, so just use
+     * the case sensitive version of the function.
+     */
+    return os_strncmp(s1, s2, n);
+}
+
+char *os_strrchr(const char *s, int c)
+{
+    return strrchr(s, c);
+}
+
+char *os_strstr(const char *haystack, const char *needle)
+{
+    return strstr(haystack, needle);
+}
+// EOF
diff --git a/kernel/liteos_m/port/wifi_ui_extra.c b/kernel/liteos_m/port/wifi_ui_extra.c
new file mode 100644
index 0000000..7990055
--- /dev/null
+++ b/kernel/liteos_m/port/wifi_ui_extra.c
@@ -0,0 +1,186 @@
+#include "include.h"
+#include "wlan_ui_pub.h"
+#include "rw_pub.h"
+#include "vif_mgmt.h"
+#include "sa_station.h"
+#include "param_config.h"
+#include "common/ieee802_11_defs.h"
+#include "driver_beken.h"
+#include "mac_ie.h"
+#include "sa_ap.h"
+#include "main_none.h"
+#include "sm.h"
+#include "mac.h"
+#include "sm_task.h"
+#include "scan_task.h"
+#include "hal_machw.h"
+#include "error.h"
+#include "lwip_netif_address.h"
+#include "lwip/inet.h"
+#include <stdbool.h>
+#include "rw_pub.h"
+#include "power_save_pub.h"
+#include "rwnx.h"
+#include "net.h"
+#include "mm_bcn.h"
+#include "mm_task.h"
+#include "mcu_ps_pub.h"
+#include "manual_ps_pub.h"
+#include "gpio_pub.h"
+#include "phy_trident.h"
+#include "rw_msg_rx.h"
+#include "app.h"
+#include "ate_app.h"
+#include "wdt_pub.h"
+#include "start_type_pub.h"
+#include "wpa_psk_cache.h"
+#include "drv_model_pub.h"
+#include "str_pub.h"
+#include "bk7011_cal_pub.h"
+#include "wifi_ui_extra.h"
+#include "common_utils.h"
+
+extern void bk_wlan_set_coexist_at_init_phase(uint8_t current_role);
+
+void los_wlan_ap_para_info_get(network_InitTypeDef_st *ap_info, unsigned char *security, unsigned char *chann)
+{
+	if ((NULL == ap_info)
+		|| (NULL == security)
+		|| (NULL == chann)
+		|| (NULL == g_ap_param_ptr))
+		return;
+
+	os_memcpy(ap_info->wifi_ssid, g_ap_param_ptr->ssid.array, 32);
+	os_memcpy(ap_info->wifi_key, g_ap_param_ptr->key, g_ap_param_ptr->key_len);
+	g_ap_param_ptr->key_len = g_ap_param_ptr->key_len;
+
+	*chann = g_ap_param_ptr->chann;
+	*security = g_ap_param_ptr->cipher_suite;
+}
+
+void los_wlan_ap_para_info_set(network_InitTypeDef_st *ap_info, unsigned char security, unsigned char chann)
+{
+	if (ap_info == NULL)
+		return;
+
+	os_memcpy(g_ap_param_ptr->ssid.array, ap_info->wifi_ssid, os_strlen(ap_info->wifi_ssid));
+	g_ap_param_ptr->ssid.length = os_strlen(ap_info->wifi_ssid);
+
+	os_memcpy(g_ap_param_ptr->key, ap_info->wifi_key, os_strlen(ap_info->wifi_key));
+	g_ap_param_ptr->key_len = os_strlen(ap_info->wifi_key);
+
+	g_ap_param_ptr->chann = chann;
+	g_ap_param_ptr->cipher_suite = security;
+}
+
+static void los_wlan_ap_init(network_InitTypeDef_st *inNetworkInitPara, unsigned char security, unsigned char chann)
+{
+	if (!g_ap_param_ptr)
+		ASSERT(g_ap_param_ptr);
+
+	if (MAC_ADDR_NULL((u8 *)&g_ap_param_ptr->bssid))
+		wifi_get_mac_address((char *)(&g_ap_param_ptr->bssid), CONFIG_ROLE_AP);
+
+	if (!g_wlan_general_param) {
+		g_wlan_general_param = (general_param_t *)os_zalloc(sizeof(general_param_t));
+		ASSERT(g_wlan_general_param);
+	}
+	g_wlan_general_param->role = CONFIG_ROLE_AP;
+	bk_wlan_set_coexist_at_init_phase(CONFIG_ROLE_AP);
+
+	if (inNetworkInitPara) {
+		if (inNetworkInitPara->dhcp_mode == DHCP_SERVER)
+			g_wlan_general_param->dhcp_enable = 1;
+		else
+			g_wlan_general_param->dhcp_enable = 0;
+		inet_aton(inNetworkInitPara->local_ip_addr, &(g_wlan_general_param->ip_addr));
+		inet_aton(inNetworkInitPara->net_mask, &(g_wlan_general_param->ip_mask));
+		inet_aton(inNetworkInitPara->gateway_ip_addr, &(g_wlan_general_param->ip_gw));
+	}
+
+	if (inNetworkInitPara) {
+		UINT32 reg = RF_HOLD_BY_AP_BIT;
+		sddev_control(SCTRL_DEV_NAME, CMD_RF_HOLD_BIT_SET, &reg);
+	}
+
+	sa_ap_init();
+}
+
+void los_wlan_start_ap(network_InitTypeDef_st *inNetworkInitParaAP, unsigned char security, unsigned char chann)
+{
+	/* stop lwip netif */
+	uap_ip_down();
+
+	/* set AP parameter, ssid, akm, etc. */
+	los_wlan_ap_init(inNetworkInitParaAP, security, chann);
+
+	// enable hostapd
+	wlan_ap_enable();
+
+	// reload bss configuration
+	wlan_ap_reload();
+
+	/* now ap has started, set ip address to this interface */
+	ip_address_set(BK_SOFT_AP,
+				   inNetworkInitParaAP->dhcp_mode,
+				   inNetworkInitParaAP->local_ip_addr,
+				   inNetworkInitParaAP->net_mask,
+				   inNetworkInitParaAP->gateway_ip_addr,
+				   inNetworkInitParaAP->dns_server_ip_addr);
+
+	/* restart lwip network */
+	uap_ip_start();
+
+}
+
+int los_wlan_start_sta(network_InitTypeDef_st *inNetworkInitPara, char *psk, unsigned int psk_len, int chan)
+{
+#if CFG_WPA_CTRL_IFACE
+	/* diconnect previous connection if may */
+	sta_ip_down();	// XXX: WLAN_DISCONNECT_EVENT may handle this
+	wlan_sta_disconnect();
+#endif
+	mhdr_set_station_status(RW_EVT_STA_CONNECTING);
+
+#if (RF_USE_POLICY == BLE_DEFAULT_WIFI_REQUEST)
+	wifi_station_status_event_notice(0, RW_EVT_STA_CONNECTING);
+#endif
+
+#if (CFG_SOC_NAME == SOC_BK7231N)
+	if (get_ate_mode_state()) {
+		// cunliang20210407 set blk_standby_cfg with blk_txen_cfg like txevm, qunshan confirmed
+		rwnx_cal_en_extra_txpa();
+	}
+#endif
+	bk_wlan_sta_init(inNetworkInitPara);
+	if (psk == NULL)
+		psk_len = 0;
+	wpa_psk_request(g_sta_param_ptr->ssid.array, g_sta_param_ptr->ssid.length, (char *)g_sta_param_ptr->key, (unsigned char *)psk, psk_len);
+
+#if CFG_WPA_CTRL_IFACE
+	/* enable wpa_supplicant */
+	wlan_sta_enable();
+	/* set network parameters: ssid, passphase */
+	wlan_sta_set((uint8_t *)inNetworkInitPara->wifi_ssid, os_strlen(inNetworkInitPara->wifi_ssid), (uint8_t *)inNetworkInitPara->wifi_key);
+	/* connect to AP */
+	wlan_sta_connect(chan);
+#endif
+
+	/* set IP mode */
+	ip_address_set(inNetworkInitPara->wifi_mode,
+				   inNetworkInitPara->dhcp_mode,
+				   inNetworkInitPara->local_ip_addr,
+				   inNetworkInitPara->net_mask,
+				   inNetworkInitPara->gateway_ip_addr,
+				   inNetworkInitPara->dns_server_ip_addr);
+
+	return kNoErr;
+}
+
+UINT8* bk_ble_get_mac_addr(void)
+{
+    return (UINT8*)&common_default_bdaddr;
+}
+
+// eof
+
diff --git a/kernel/liteos_m/port/wifi_ui_extra.h b/kernel/liteos_m/port/wifi_ui_extra.h
new file mode 100644
index 0000000..576ce11
--- /dev/null
+++ b/kernel/liteos_m/port/wifi_ui_extra.h
@@ -0,0 +1,14 @@
+#ifndef _WIFI_UI_EXTRA_H_
+#define _WIFI_UI_EXTRA_H_
+
+#include "wlan_ui_pub.h"
+
+void los_wlan_ap_para_info_get(network_InitTypeDef_st *ap_info, unsigned char *security, unsigned char *chann);
+void los_wlan_ap_para_info_set(network_InitTypeDef_st *ap_info, unsigned char security, unsigned char chann);
+void los_wlan_start_ap(network_InitTypeDef_st *inNetworkInitParaAP, unsigned char security, unsigned char chann);
+int los_wlan_start_sta(network_InitTypeDef_st *inNetworkInitPara, char *psk, unsigned int psk_len, int chan);
+UINT8* bk_ble_get_mac_addr(void);
+
+#endif // _WIFI_UI_EXTRA_H_
+// eof
+
diff --git a/kernel/liteos_m/targets/bk72xx/bk_los_timer.c b/kernel/liteos_m/targets/bk72xx/bk_los_timer.c
new file mode 100644
index 0000000..24f0ff9
--- /dev/null
+++ b/kernel/liteos_m/targets/bk72xx/bk_los_timer.c
@@ -0,0 +1,101 @@
+#include "include.h"
+#include "bk_los_timer.h"
+#include "bk_timer.h"
+#include "los_context.h"
+#include "rtos_pub.h"
+#include "arm_arch.h"
+#include "los_interrupt.h"
+
+static OS_TICK_HANDLER g_tickHandler = NULL;
+
+void HalTickHandler(u8 param)
+{
+    if (g_tickHandler != NULL) {
+        g_tickHandler();
+    }
+}
+
+unsigned int HalTickStart(OS_TICK_HANDLER handler)
+{
+	unsigned int intSave;
+	UINT32 timer_channel;
+
+	intSave = LOS_IntLock();
+	timer_param_t param;
+	param.channel = LOS_TICK_TIMER_ID;
+	param.div = 1;
+	param.period = LOS_TICK_MS;
+	param.t_Int_Handler= HalTickHandler;
+	g_tickHandler = handler;
+
+	bk_timer_ctrl( CMD_TIMER_INIT_PARAM, &param);
+	timer_channel = param.channel;
+	bk_timer_ctrl( CMD_TIMER_UNIT_ENABLE, &timer_channel);
+	LOS_IntRestore(intSave);
+
+    return 0;
+}
+
+void HalTickLock(void)
+{
+    unsigned int timer_channel = LOS_TICK_TIMER_ID;
+    (void)bk_timer_ctrl(CMD_TIMER_UNIT_DISABLE, &timer_channel);
+}
+
+void HalTickUnlock(void)
+{
+    unsigned int timer_channel = LOS_TICK_TIMER_ID;
+    (void)bk_timer_ctrl(CMD_TIMER_UNIT_ENABLE, &timer_channel);
+}
+
+static void HalClockIrqClear(void)
+{
+    unsigned int status1 = 0x7 << TIMERCTLB_INT_POSI;
+
+    do {
+        REG_WRITE(LOS_TICK_CTRL_REG, (REG_READ(LOS_TICK_CTRL_REG) & (~(0x7 << TIMERCTLB_INT_POSI))) | status1);
+    } while (REG_READ(LOS_TICK_CTRL_REG) & status1 & (0x7 << TIMERCTLB_INT_POSI));
+}
+
+void HalSysTickReload(unsigned long long nextResponseTime)
+{
+	UINT32 inSave;
+
+	inSave = HalIntLock();
+    HalTickLock();
+	
+	HalClockIrqClear();
+    REG_WRITE(REG_TIMERCTL_PERIOD_ADDR(LOS_TICK_TIMER_GROUP, LOS_TICK_TIMER_ID), nextResponseTime);
+    HalTickUnlock();
+	HalIntRestore(inSave);
+}
+
+unsigned long long HalGetTickCycle(unsigned int *period)
+{
+    unsigned int val = 0;
+    unsigned int i_time_out = 0;
+
+    *period = REG_READ(REG_TIMERCTL_PERIOD_ADDR(LOS_TICK_TIMER_GROUP, LOS_TICK_TIMER_ID));
+
+    //get val
+    REG_WRITE(LOS_TICK_RD_CTRL_REG, (LOS_TICK_TIMER_RD_ID << 2) | 1);
+    while (REG_READ(LOS_TICK_RD_CTRL_REG) & 1) {
+         i_time_out++;
+         if (i_time_out > (120 * 1000)) {
+             break;
+         }
+    }
+
+    if (i_time_out <= (120 * 1000)) {
+        val = REG_READ(LOS_TICK_RD_VAL_REG);
+    }
+
+    return (unsigned long long)val;
+}
+
+UINT64 OsGetCurrSecond(VOID)
+{
+	return rtos_get_tick_count() * LOS_TICK_MS / 1000;
+}
+// eof
+
diff --git a/kernel/liteos_m/targets/bk72xx/bk_los_timer.h b/kernel/liteos_m/targets/bk72xx/bk_los_timer.h
new file mode 100644
index 0000000..4abf6b9
--- /dev/null
+++ b/kernel/liteos_m/targets/bk72xx/bk_los_timer.h
@@ -0,0 +1,30 @@
+#ifndef _BK_LOS_TIMER_H_
+#define _BK_LOS_TIMER_H_
+
+#include "include.h"
+#include "bk_timer_pub.h"
+
+#if CFG_HUAWEI_ORIGINAL_ADAPT
+#define LOS_TICK_TIMER_ID                  BKTIMER3
+#define LOS_TICK_CTRL_REG                  TIMER3_5_CTL
+#define LOS_TICK_RD_CTRL_REG               TIMER3_5_READ_CTL
+#define LOS_TICK_RD_VAL_REG                TIMER3_5_READ_VALUE
+#define LOS_TICK_UNIT_CLOCK                32000 
+#else
+#define LOS_TICK_TIMER_ID                  BKTIMER0
+#define LOS_TICK_CTRL_REG                  TIMER0_2_CTL
+#define LOS_TICK_RD_CTRL_REG               TIMER0_2_READ_CTL
+#define LOS_TICK_RD_VAL_REG                TIMER0_2_READ_VALUE
+#define LOS_TICK_UNIT_CLOCK                26000000 
+#endif
+
+#define LOS_TICK_TIMER_GROUP               ((LOS_TICK_TIMER_ID) >= 3 ? 1 : 0)
+#define LOS_TICK_TIMER_RD_ID               (LOS_TICK_TIMER_ID - 3 * (LOS_TICK_TIMER_GROUP))
+
+#define LOS_TICK_MS                        2
+#define LOS_TICKS_PER_SECOND              (1000UL/LOS_TICK_MS)
+
+extern UINT64 OsGetCurrSecond(VOID);
+
+#endif // _BK_LOS_TIMER_H_
+// eof
diff --git a/kernel/liteos_m/utils/BUILD.gn b/kernel/liteos_m/utils/BUILD.gn
index 86fa369..00bbb5d 100644
--- a/kernel/liteos_m/utils/BUILD.gn
+++ b/kernel/liteos_m/utils/BUILD.gn
@@ -1,42 +1,43 @@
-# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
-# Copyright (c) 2020-2021, Huawei Device Co., Ltd. All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of
-#    conditions and the following disclaimer.
-#
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list
-#    of conditions and the following disclaimer in the documentation and/or other materials
-#    provided with the distribution.
-#
-# 3. Neither the name of the copyright holder nor the names of its contributors may be used
-#    to endorse or promote products derived from this software without specific prior written
-#    permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-static_library("utils") {
-  sources = [
-    "los_debug.c",
-    "los_error.c",
-  ]
-
-  include_dirs = [
-    "../kernel/include",
-    "../kernel/arch/include",
-    "./",
-    "//third_party/bounds_checking_function/include",
-  ]
-}
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("utils") {
+  sources = [
+    "los_debug.c",
+    "los_error.c",
+    "los_hook.c",
+  ]
+
+  include_dirs = [
+    "../kernel/include",
+    "../kernel/arch/include",
+    ".",
+    "//third_party/bounds_checking_function/include",
+  ]
+}
diff --git a/kernel/liteos_m/utils/internal/los_hook_types.h b/kernel/liteos_m/utils/internal/los_hook_types.h
new file mode 100644
index 0000000..4190e96
--- /dev/null
+++ b/kernel/liteos_m/utils/internal/los_hook_types.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_HOOK_TYPES_H
+#define _LOS_HOOK_TYPES_H
+
+#include "los_compiler.h"
+#include "los_config.h"
+#include "los_context.h"
+#include "los_event.h"
+#include "los_mux.h"
+#include "los_queue.h"
+#include "los_sem.h"
+#include "los_task.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#if (LOSCFG_DEBUG_HOOK == 1)
+#define LOS_HOOK_ALL_TYPES_DEF                                                                              \
+    /* Hook types supported by memory modules */                                                            \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_INIT, (VOID *pool, UINT32 size))                                    \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_DEINIT, (VOID *pool))                                               \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_ALLOC, (VOID *pool, UINT32 size))                                   \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_FREE, (VOID *pool, VOID *ptr))                                      \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_REALLOC, (VOID *pool, VOID *ptr, UINT32 size))                      \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MEM_ALLOCALIGN, (VOID *pool, UINT32 size, UINT32 boundary))             \
+    /* Hook types supported by event modules */                                                             \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_EVENT_INIT, (PEVENT_CB_S eventCB))                                                     \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_EVENT_READ, (PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode))       \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_EVENT_WRITE, (PEVENT_CB_S eventCB))                                     \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_EVENT_CLEAR, (PEVENT_CB_S eventCB))                                     \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_EVENT_DESTROY, (PEVENT_CB_S eventCB))                                                  \
+    /* Hook types supported by queue modules */                                                             \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_QUEUE_CREATE, (const LosQueueCB *queueCB))                              \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_QUEUE_READ, (const LosQueueCB *queueCB))                                \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_QUEUE_WRITE, (const LosQueueCB *queueCB))                               \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_QUEUE_DELETE, (const LosQueueCB *queueCB))                              \
+    /* Hook types supported by semphore modules */                                                          \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_SEM_CREATE, (const LosSemCB *semCreated))                               \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_SEM_POST, (const LosSemCB *semPosted, const LosTaskCB *resumedTask))    \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_SEM_PEND, (const LosSemCB *semPended, const LosTaskCB *runningTask))    \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_SEM_DELETE, (const LosSemCB *semDeleted))                               \
+    /* Hook types supported by mutex modules */                                                             \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MUX_CREATE, (const LosMuxCB *muxCreated))                               \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MUX_POST, (const LosMuxCB *muxPosted))                                  \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MUX_PEND, (const LosMuxCB *muxPended))                                  \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MUX_DELETE, (const LosMuxCB *muxDeleted))                               \
+    /* Hook types supported by task modules */                                                              \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_TASK_CREATE, (const LosTaskCB *taskCB))                                 \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_TASK_DELAY, (UINT32 tick))                                              \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_TASK_PRIMODIFY, (const LosTaskCB *pxTask, UINT32 uxNewPriority))        \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_TASK_DELETE, (const LosTaskCB *taskCB))                                 \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_TASK_SWITCHEDIN, (VOID))                                                \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MOVEDTASKTOREADYSTATE, (const LosTaskCB *pstTaskCB))                    \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MOVEDTASKTODELAYEDLIST, (const LosTaskCB *pstTaskCB))                   \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_MOVEDTASKTOSUSPENDEDLIST, (const LosTaskCB *pstTaskCB))                 \
+    /* Hook types supported by interrupt modules */                                                         \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_ISR_EXITTOSCHEDULER, (VOID))                                            \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_ISR_ENTER, (UINT32 hwiIndex))                                           \
+    LOS_HOOK_TYPE_DEF(LOS_HOOK_TYPE_ISR_EXIT, (UINT32 hwiIndex))
+
+/**
+ * Defines the types of all hooks.
+ */
+#define LOS_HOOK_TYPE_DEF(type, paramList)                  type,
+
+typedef enum {
+    /* Used to manage hook pools */
+    LOS_HOOK_TYPE_START = 0,
+    /* All supported hook types */
+    LOS_HOOK_ALL_TYPES_DEF
+    /* Used to manage hook pools */
+    LOS_HOOK_TYPE_END
+} HookType;
+
+#undef LOS_HOOK_TYPE_DEF
+
+/**
+ * Declare the type and interface of the hook functions.
+ */
+#define LOS_HOOK_TYPE_DEF(type, paramList)                  \
+    typedef VOID (*type##_FN) paramList;                    \
+    extern UINT32 type##_RegHook(type##_FN func);           \
+    extern UINT32 type##_UnRegHook(type##_FN func);         \
+    extern VOID type##_CallHook paramList;
+
+LOS_HOOK_ALL_TYPES_DEF
+
+#undef LOS_HOOK_TYPE_DEF
+
+#endif /* LOSCFG_DEBUG_HOOK */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_HOOK_TYPES_H */
diff --git a/kernel/liteos_m/utils/internal/los_hook_types_parse.h b/kernel/liteos_m/utils/internal/los_hook_types_parse.h
new file mode 100644
index 0000000..28596ae
--- /dev/null
+++ b/kernel/liteos_m/utils/internal/los_hook_types_parse.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_HOOK_TYPES_PARSE_H
+#define _LOS_HOOK_TYPES_PARSE_H
+
+#define ADDR(a) (&(a))
+#define ARGS(a) (a)
+#define ADDRn(...) _CONCAT(ADDR, _NARGS(__VA_ARGS__))(__VA_ARGS__)
+#define ARGSn(...) _CONCAT(ARGS, _NARGS(__VA_ARGS__))(__VA_ARGS__)
+#define ARGS0()
+#define ADDR0()
+#define ARGS1(a) ARGS(a)
+#define ADDR1(a) ADDR(a)
+
+#define ARG_const _ARG_const(
+#define _ARG_const(a) ARG_CP_##a)
+#define ARG_CP_LosSemCB ADDR(
+#define ARG_CP_LosTaskCB ADDR(
+#define ARG_CP_UINT32 ADDR(
+#define ARG_CP_LosMuxCB ADDR(
+#define ARG_CP_LosQueueCB ADDR(
+#define ARG_UINT32 ARGS(
+#define ARG_PEVENT_CB_S ARGS(
+#define ARG_void ADDRn(
+#define ARG(a) ARG_##a)
+
+#define PARAM_TO_ARGS1(a) ARG(a)
+#define PARAM_TO_ARGS2(a, b) ARG(a), PARAM_TO_ARGS1(b)
+#define PARAM_TO_ARGS3(a, b, c) ARG(a), PARAM_TO_ARGS2(b, c)
+#define PARAM_TO_ARGS4(a, b, c, d) ARG(a), PARAM_TO_ARGS3(b, c, d)
+#define PARAM_TO_ARGS5(a, b, c, d, e) ARG(a), PARAM_TO_ARGS4(b, c, d, e)
+#define PARAM_TO_ARGS6(a, b, c, d, e, f) ARG(a), PARAM_TO_ARGS5(b, c, d, e, f)
+#define PARAM_TO_ARGS7(a, b, c, d, e, f, g) ARG(a), PARAM_TO_ARGS6(b, c, d, e, f, g)
+
+#define _ZERO_ARGS  7, 6, 5, 4, 3, 2, 1, 0
+#define ___NARGS(a, b, c, d, e, f, g, h, n, ...)    n
+#define __NARGS(...) ___NARGS(__VA_ARGS__)
+#define _NARGS(...) __NARGS(x, __VA_ARGS__##_ZERO_ARGS, 7, 6, 5, 4, 3, 2, 1, 0)
+#define __CONCAT(a, b) a##b
+#define _CONCAT(a, b) __CONCAT(a, b)
+
+#define PARAM_TO_ARGS(...) _CONCAT(PARAM_TO_ARGS, _NARGS(__VA_ARGS__))(__VA_ARGS__)
+#define OS_HOOK_PARAM_TO_ARGS(paramList) (PARAM_TO_ARGS paramList)
+
+#endif /* _LOS_HOOK_TYPES_PARSE_H */
diff --git a/kernel/liteos_m/utils/los_compiler.h b/kernel/liteos_m/utils/los_compiler.h
old mode 100755
new mode 100644
index 94d0841..fc36cc9
--- a/kernel/liteos_m/utils/los_compiler.h
+++ b/kernel/liteos_m/utils/los_compiler.h
@@ -70,6 +70,14 @@ extern "C" {
 #define CLZ           __iar_builtin_CLZ
 #endif
 
+#ifndef NORETURN
+#define NORETURN      __attribute__ ((__noreturn__))
+#endif
+
+#ifndef UNREACHABLE
+#define UNREACHABLE   while (1)
+#endif
+
 /* for ARM Compiler */
 #elif defined(__CC_ARM)
 
@@ -97,6 +105,14 @@ extern "C" {
 #define CLZ           __clz
 #endif
 
+#ifndef NORETURN
+#define NORETURN      __declspec(noreturn)
+#endif
+
+#ifndef UNREACHABLE
+#define UNREACHABLE   while (1)
+#endif
+
 #pragma anon_unions
 
 /* for GNU Compiler */
@@ -126,6 +142,14 @@ extern "C" {
 #define CLZ           __builtin_clz
 #endif
 
+#ifndef NORETURN
+#define NORETURN      __attribute__ ((__noreturn__))
+#endif
+
+#ifndef UNREACHABLE
+#define UNREACHABLE   __builtin_unreachable()
+#endif
+
 #else
 #error Unknown compiler.
 #endif
@@ -311,7 +335,7 @@ typedef signed int             INTPTR;
 #ifdef __cplusplus
 #define NULL          0L
 #else
-#define NULL          ((VOID *)0)
+#define NULL          ((void*)0)
 #endif
 #endif
 
@@ -387,10 +411,7 @@ static inline UINT32 LOS_Align(UINT32 addr, UINT32 boundary)
         } while (0)
 
 #ifndef UNUSED
-#define UNUSED(var)    \
-        do {           \
-            (void)var; \
-        } while (0)
+#define UNUSED(X) (void)X
 #endif
 
 #ifdef __cplusplus
diff --git a/kernel/liteos_m/utils/los_debug.c b/kernel/liteos_m/utils/los_debug.c
old mode 100755
new mode 100644
index 3bb28b6..435641e
--- a/kernel/liteos_m/utils/los_debug.c
+++ b/kernel/liteos_m/utils/los_debug.c
@@ -31,13 +31,8 @@
 
 #include "los_debug.h"
 #include "stdarg.h"
-#include "los_context.h"
+#include "los_interrupt.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 #if (LOSCFG_KERNEL_PRINTF == 1)
 STATIC const CHAR *g_logString[] = {
@@ -66,13 +61,13 @@ VOID OsBackTraceHookCall(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR S
         g_backTraceHook(LR, LRSize, jumpCount, SP);
     } else {
         PRINT_ERR("Record LR failed, because of g_backTraceHook is not registered, "
-                  "should call LOS_BackTraceInit firstly\n");
+                  "should call OSBackTraceInit firstly\n");
     }
 }
 
 VOID OsExcHookRegister(ExcHookFn excHookFn)
 {
-    UINTPTR intSave = LOS_IntLock();
+    UINT32 intSave = LOS_IntLock();
     if (!g_excHook) {
         g_excHook = excHookFn;
     }
@@ -81,7 +76,7 @@ VOID OsExcHookRegister(ExcHookFn excHookFn)
 
 VOID OsDoExcHook(EXC_TYPE excType)
 {
-    UINTPTR intSave = LOS_IntLock();
+    UINT32 intSave = LOS_IntLock();
     if (g_excHook) {
         g_excHook(excType);
     }
@@ -109,8 +104,3 @@ WEAK VOID HalConsoleOutput(LogModuleType type, INT32 level, const CHAR *fmt, ...
 }
 #endif
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/utils/los_debug.h b/kernel/liteos_m/utils/los_debug.h
old mode 100755
new mode 100644
index 5528763..1ace7f1
--- a/kernel/liteos_m/utils/los_debug.h
+++ b/kernel/liteos_m/utils/los_debug.h
@@ -86,19 +86,14 @@ VOID OsExcHookRegister(ExcHookFn excHookFn);
 VOID OsDoExcHook(EXC_TYPE excType);
 
 #define LOG_EMG_LEVEL       0
-
 #define LOG_COMMON_LEVEL    (LOG_EMG_LEVEL + 1)
-
 #define LOG_ERR_LEVEL       (LOG_COMMON_LEVEL + 1)
-
 #define LOG_WARN_LEVEL      (LOG_ERR_LEVEL + 1)
-
 #define LOG_INFO_LEVEL      (LOG_WARN_LEVEL + 1)
-
 #define LOG_DEBUG_LEVEL     (LOG_INFO_LEVEL + 1)
 
 #ifndef PRINT_LEVEL
-#define PRINT_LEVEL         LOG_ERR_LEVEL
+#define PRINT_LEVEL         LOG_EMG_LEVEL
 #endif
 
 typedef enum {
@@ -130,11 +125,12 @@ typedef enum {
  * @since none
  */
 #if (LOSCFG_KERNEL_PRINTF == 1)
-extern INT32 printf(const CHAR *fmt, ...);
+extern void bk_printf(const CHAR *fmt, ...);
 extern INT32 OsLogLevelCheck(INT32 level);
+
 #define LOS_Printf(type, level, fmt, args...)   do { \
     if (!OsLogLevelCheck(level)) {                   \
-        printf(fmt, ##args);                         \
+        bk_printf(fmt, ##args);                      \
     }                                                \
 } while (0)
 #elif (LOSCFG_KERNEL_PRINTF == 0)
@@ -169,200 +165,6 @@ typedef VOID (*BACK_TRACE_HOOK)(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UI
 extern VOID OsBackTraceHookSet(BACK_TRACE_HOOK hook);
 extern VOID OsBackTraceHookCall(UINTPTR *LR, UINT32 LRSize, UINT32 jumpCount, UINTPTR SP);
 
-/**
- * @ingroup los_trace
- * Task error code: Insufficient memory for trace struct.
- *
- * Value: 0x02001400
- *
- * Solution: Decrease the maximum number of tasks.
- */
-#define  LOS_ERRNO_TRACE_NO_MEMORY              LOS_ERRNO_OS_ERROR(LOS_MOD_TRACE, 0x00)
-
-/**
- * @ingroup los_trace
- * Task error code: User type is invalid when register new trace.
- *
- * Value: 0x02001401
- *
- * Solution: Use valid type to regeister the new trace.
- */
-#define  LOS_ERRNO_TRACE_TYPE_INVALID           LOS_ERRNO_OS_ERROR(LOS_MOD_TRACE, 0x01)
-
-
-/**
- * @ingroup los_trace
- * Task error code: The callback function is null when register new trace.
- *
- * Value: 0x02001402
- *
- * Solution: Use valid callback function to regeister the new trace.
- */
-#define  LOS_ERRNO_TRACE_FUNCTION_NULL          LOS_ERRNO_OS_ERROR(LOS_MOD_TRACE, 0x02)
-
-/**
- * @ingroup los_trace
- * Task error code: The filled size is 0 when register new trace.
- *
- * Value: 0x02001403
- *
- * Solution: Use valid filled size to regeister the new trace.
- */
-#define  LOS_ERRNO_TRACE_MAX_SIZE_INVALID       LOS_ERRNO_OS_ERROR(LOS_MOD_TRACE, 0x03)
-
-/**
- * @ingroup los_trace
- * It's the total size of trace buffer. It's in the unit of char
- */
-#define LOS_TRACE_BUFFER_SIZE 1024
-
-/**
- * @ingroup los_trace
- * It's the legth of tag, filled by los_trace system
- */
-#define LOS_TRACE_TAG_LENGTH  sizeof(UINT32)
-
-/**
- * @ingroup los_trace
- * Stands for the trace type can be registered.
- */
-typedef enum enTraceType {
-    LOS_TRACE_SWITCH = 0,         /**< trace for task switch, 0 is reserved for taskswitch   */
-    LOS_TRACE_INTERRUPT = 1,      /**< trace for Interrrupt, 1 is reserved for interrupt      */
-    LOS_TRACE_TYPE_NUM =  10,     /**< num for the register type, user can use 2~ LOS_TRACE_TYPE_NUM-1 */
-} TRACE_TYPE_E;
-
-
-/**
- * @ingroup los_trace
- * struct to store the task switch infomation
- */
-typedef struct tagTraceTaskSwitch {
-    UINT8  ucSrcTaskId;           /**< source taskid    */
-    UINT8  ucDestTaskId;          /**< destination taskid    */
-    UINT32 uwSwitchTick;          /**< Time at which the task switch happens    */
-} TRACE_TASKSWITCH_S;
-
-/**
- * @ingroup los_trace
- * struct to store the interrupt infomation
- */
-typedef struct tagTraceInterrupt {
-    UINT8  ucIRQEntryExit;        /**< 1 stands for that the trace is happend before interrupt function */
-                                  /**< 0 stands for that the trace is after before interrupt function */
-    UINT16 usIRQNo;               /**< IRQ number which trigger the interrupt     */
-    UINT32 uwTick;                /**< Time at which the the trace is called    */
-} TRACE_INTERRUPT_S;
-
-/**
- * @ingroup los_trace
- * union struct to store the interrupt and task switch infomation
- */
-typedef struct tagTrace {
-    union {
-        TRACE_TASKSWITCH_S  stTraceTask;       /**< It used for trace the task    */
-        TRACE_INTERRUPT_S   stTraceInterrupt;  /**< It used for trace the interrrupt    */
-    };
-} TRACE_S;
-
-/**
- * @ingroup los_trace
- * Main struct to store the interrupt and task swithc infomation
- */
-typedef struct tagTraceBuffer {
-    UINT16            usTracePos;
-    UINT16            usTraceWrapPos;
-    UINT8             ucBuffer[LOS_TRACE_BUFFER_SIZE];
-} TRACE_BUFFER_S;
-
-
-/**
- * @ingroup los_trace
- * Struct to store the trace infomaion for each trace type
- */
-typedef struct tagTraceInfo {
-    TRACE_TYPE_E  eType;                             /**< trace type, selected from TRACE_TYPE_E */
-    UINT16 (*pfnHook)(UINT8 *outBuffer, VOID *pInfo); /**< callback function for the specific trace type.
-                                                       * This function is used to store the infomation
-                                                       * which want to be traced */
-} TRACE_INFO_S;
-
-/**
- * @ingroup los_trace
- * @brief  Intialize the trace when the system startup.
- *
- * @par Description:
- * This API is used to intilize the trace for system level.
- * @attention
- * <ul>
- * <li>This API can be called only after the memory is initialized. Otherwise, the CPU usage fails to be obtained.</li>
- * </ul>
- *
- * @param None.
- *
- * @retval #LOS_ERRNO_TRACE_NO_MEMORY         0x02001400: The memory is not enough for initilize.
- * @retval #LOS_OK                            0x00000000: The intialization is successful.
- * @par Dependency:
- * <ul><li>los_trace.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_TraceInit
- */
-extern UINT32 LOS_TraceInit(VOID);
-
-
-/**
- * @ingroup los_trace
- * @brief main trace function is called by user to logger the information.
- *
- * @par Description:
- * This API is used to trace the infomation.
- * @attention
- * <ul>
- * <li>This API can be called only after trace type is intialized. Otherwise, the trace will be failed.</li>
- * </ul>
- *
- * @param  traceType     [IN] TRACE_TYPE_E. Type of trace information.
- * @param  traceInfo     [IN] VOID*. It's a input buffer to store trace infomation
- *
- * @retval NONE.
- *
- * @par Dependency:
- * <ul><li>los_trace.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_Trace
- */
-extern VOID LOS_Trace(TRACE_TYPE_E traceType, VOID *traceInfo);
-
-
-
-/**
- * @ingroup los_trace
- * @brief register the hook for specific trace type.
- *
- * @par Description:
- * This API is used to register the hook for specific trace type.
- * @attention
- * <ul>
- * <li>This API can be called only after trace type is called. therwise, the trace will be failed.</li>
- * </ul>
- *
- * @param  traceType     [IN] TRACE_TYPE_E. Type of trace information.
- * @param  hook          [IN] UINT16 (*)(UINT8*, VOID*). It's an callback function to store the useful trace
- *                            information
- * @param  size          [IN] UINT16. The maximum size the trace will use for the specific trace type.
- *
- * @retval #LOS_ERRNO_TRACE_NO_MEMORY          0x02001400: The memory is not enough for initilize.
- * @retval #LOS_ERRNO_TRACE_TYPE_INVALID       0x02001401: The trace type is invalid. Valid type is from
- *                                                         LOS_TRACE_TYPE_NUM-1
- * @retval #LOS_ERRNO_TRACE_FUNCTION_NULL      0x02001402: The input callback function is NULL
- * @retval #LOS_ERRNO_TRACE_MAX_SIZE_INVALID   0x02001403: The information maxmum size is 0 to store.
- * @retval #LOS_OK                             0x00000000: The registeration is successful.
- *
- * @par Dependency:
- * <ul><li>los_trace.h: the header file that contains the API declaration.</li></ul>
- * @see LOS_TraceUserReg
- */
-extern UINT32 LOS_TraceUserReg(TRACE_TYPE_E traceType, UINT16 (*hook)(UINT8 *, VOID *), UINT16 size);
-
-
 #ifdef __cplusplus
 #if __cplusplus
 }
diff --git a/kernel/liteos_m/utils/los_error.c b/kernel/liteos_m/utils/los_error.c
index 38cf2cd..0b783b3 100644
--- a/kernel/liteos_m/utils/los_error.c
+++ b/kernel/liteos_m/utils/los_error.c
@@ -31,11 +31,6 @@
 
 #include "los_error.h"
 
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#endif /* __cplusplus */
 
 LITE_OS_SEC_BSS UserErrFunc      g_userErrFunc;
 
@@ -65,8 +60,3 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_ErrHandle(CHAR  *fileName,
     return LOS_OK;
 }
 
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __cplusplus */
diff --git a/kernel/liteos_m/utils/los_error.h b/kernel/liteos_m/utils/los_error.h
index 3c09072..0e5e1a2 100644
--- a/kernel/liteos_m/utils/los_error.h
+++ b/kernel/liteos_m/utils/los_error.h
@@ -168,7 +168,7 @@ typedef struct tagUserErrFunc {
 } UserErrFunc;
 
 
-enum LOS_MOUDLE_ID {
+enum LOS_MODULE_ID {
     LOS_MOD_SYS              = 0x0,
     LOS_MOD_MEM              = 0x1,
     LOS_MOD_TSK              = 0x2,
@@ -193,20 +193,17 @@ enum LOS_MOUDLE_ID {
     LOS_MOD_MPU              = 0x12,
     LOS_MOD_NMHWI            = 0x13,
     LOS_MOD_TRACE            = 0x14,
-    LOS_MOD_KNLSTAT          = 0x15,
-    LOS_MOD_EVTTIME          = 0x16,
-    LOS_MOD_THRDCPUP         = 0x17,
     LOS_MOD_IPC              = 0x18,
-    LOS_MOD_STKMON           = 0x19,
     LOS_MOD_TIMER            = 0x1a,
-    LOS_MOD_RESLEAKMON       = 0x1b,
     LOS_MOD_EVENT            = 0x1c,
     LOS_MOD_MUX              = 0X1d,
     LOS_MOD_CPUP             = 0x1e,
+    LOS_MOD_HOOK             = 0x1f,
+    LOS_MOD_PM               = 0x20,
     LOS_MOD_SHELL            = 0x31,
     LOS_MOD_BUTT
 };
-			
+
 /**
  * @ingroup los_err
  * Define the error magic word.
@@ -288,7 +285,7 @@ enum LOS_MOUDLE_ID {
         goto ERR_HANDLER; \
     } while (0)
 
-			
+
 #ifdef __cplusplus
 #if __cplusplus
 }
diff --git a/kernel/liteos_m/utils/los_hook.c b/kernel/liteos_m/utils/los_hook.c
new file mode 100644
index 0000000..9495d45
--- /dev/null
+++ b/kernel/liteos_m/utils/los_hook.c
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_hook.h"
+#include "internal/los_hook_types_parse.h"
+
+
+#if (LOSCFG_DEBUG_HOOK == 1)
+#define LOS_HOOK_TYPE_DEF(type, paramList)                  \
+    STATIC type##_FN g_fn##type;                            \
+    UINT32 type##_RegHook(type##_FN func) {                 \
+        if ((func) == NULL) {                               \
+            return LOS_ERRNO_HOOK_REG_INVALID;              \
+        }                                                   \
+        if (g_fn##type) {                                   \
+            return LOS_ERRNO_HOOK_POOL_IS_FULL;             \
+        }                                                   \
+        g_fn##type = (func);                                \
+        return LOS_OK;                                      \
+    }                                                       \
+    UINT32 type##_UnRegHook(type##_FN func) {               \
+        if (((func) == NULL) || (g_fn##type != (func))) {   \
+            return LOS_ERRNO_HOOK_UNREG_INVALID;            \
+        }                                                   \
+        g_fn##type = NULL;                                  \
+        return LOS_OK;                                      \
+    }                                                       \
+    VOID type##_CallHook paramList {                        \
+        if (g_fn##type) {                                   \
+            g_fn##type(PARAM_TO_ARGS paramList);            \
+        }                                                   \
+    }
+
+LOS_HOOK_ALL_TYPES_DEF;
+
+#undef LOS_HOOK_TYPE_DEF
+
+#endif /* LOSCFG_DEBUG_HOOK */
+
diff --git a/kernel/liteos_m/utils/los_hook.h b/kernel/liteos_m/utils/los_hook.h
new file mode 100644
index 0000000..b4665a7
--- /dev/null
+++ b/kernel/liteos_m/utils/los_hook.h
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LOS_HOOK_H
+#define _LOS_HOOK_H
+
+#include "internal/los_hook_types.h"
+#include "los_config.h"
+#include "los_error.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#if (LOSCFG_DEBUG_HOOK == 1)
+/**
+ * @ingroup los_hook
+ * Hook error code: The hook pool is insufficient.
+ *
+ * Value: 0x02001f00
+ *
+ * Solution: Deregister the registered hook.
+ */
+#define LOS_ERRNO_HOOK_POOL_IS_FULL             LOS_ERRNO_OS_ERROR(LOS_MOD_HOOK, 0x00)
+
+/**
+ * @ingroup los_hook
+ * Hook error code: Invalid parameter.
+ *
+ * Value: 0x02001f01
+ *
+ * Solution: Check the input parameters of LOS_HookReg.
+ */
+#define LOS_ERRNO_HOOK_REG_INVALID              LOS_ERRNO_OS_ERROR(LOS_MOD_HOOK, 0x01)
+
+/**
+ * @ingroup los_hook
+ * Hook error code: Invalid parameter.
+ *
+ * Value: 0x02001f02
+ *
+ * Solution: Check the input parameters of LOS_HookUnReg.
+ */
+#define LOS_ERRNO_HOOK_UNREG_INVALID            LOS_ERRNO_OS_ERROR(LOS_MOD_HOOK, 0x02)
+
+/**
+ * @ingroup los_hook
+ * @brief Registration of hook function.
+ *
+ * @par Description:
+ * This API is used to register hook function.
+ *
+ * @attention
+ * <ul>
+ * <li> None.</li>
+ * </ul>
+ *
+ * @param hookType  [IN] Register the type of the hook.
+ * @param hookFn  [IN] The function to be registered.
+ *
+ * @retval None.
+ * @par Dependency:
+ * <ul><li>los_hook.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+#define LOS_HookReg(hookType, hookFn)           hookType##_RegHook(hookFn)
+
+/**
+ * @ingroup los_hook
+ * @brief Deregistration of hook function.
+ *
+ * @par Description:
+ * This API is used to deregister hook function.
+ *
+ * @attention
+ * <ul>
+ * <li> None.</li>
+ * </ul>
+ *
+ * @param hookType  [IN] Deregister the type of the hook.
+ * @param hookFn  [IN] The function to be deregistered.
+ *
+ * @retval None.
+ * @par Dependency:
+ * <ul><li>los_hook.h: the header file that contains the API declaration.</li></ul>
+ * @see
+ */
+#define LOS_HookUnReg(hookType, hookFn)         hookType##_UnRegHook(hookFn)
+
+/**
+ * Call hook functions.
+ */
+#define OsHookCall(hookType, ...)               hookType##_CallHook(__VA_ARGS__)
+
+#else
+#define LOS_HookReg(hookType, hookFn)
+#define LOS_HookUnReg(hookType, hookFn)
+#define OsHookCall(hookType, ...)
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_HOOK_H */
diff --git a/kernel/liteos_m/utils/los_list.h b/kernel/liteos_m/utils/los_list.h
index 9f1bb94..90fcf4b 100644
--- a/kernel/liteos_m/utils/los_list.h
+++ b/kernel/liteos_m/utils/los_list.h
@@ -151,6 +151,30 @@ LITE_OS_SEC_ALW_INLINE STATIC_INLINE VOID LOS_ListTailInsert(LOS_DL_LIST *list,
     LOS_ListAdd(list->pstPrev, node);
 }
 
+/**
+ * @ingroup los_list
+ * @brief Insert a node to the head of a doubly linked list.
+ *
+ * @par Description:
+ * This API is used to insert a new node to the head of a doubly linked list.
+ * @attention
+ * <ul>
+ * <li>The parameters passed in should be ensured to be legal pointers.</li>
+ * </ul>
+ *
+ * @param list     [IN] Doubly linked list where the new node is inserted.
+ * @param node     [IN] New node to be inserted.
+ *
+ * @retval None.
+ * @par Dependency:
+ * <ul><li>los_list.h: the header file that contains the API declaration.</li></ul>
+ * @see LOS_ListAdd | LOS_ListTailInsert
+ */
+LITE_OS_SEC_ALW_INLINE STATIC_INLINE VOID LOS_ListHeadInsert(LOS_DL_LIST *list, LOS_DL_LIST *node)
+{
+    LOS_ListAdd(list, node);
+}
+
 /**
  * @ingroup los_list
  * @brief Delete a specified node from a doubly linked list.
